[
  {
    "description": "Object that exposes Chartbulider's d4 chart constructors",
    "tags": [
      {
        "title": "name",
        "name": "cb_charts"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 7,
          "column": 0
        },
        "end": {
          "line": 19,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-charts.js",
      "code": "var cb_xy = require(\"./cb-xy/draw-xy\");\nvar cb_bar_grid = require(\"./cb-chart-grid/draw-bar-grid\");\n\n/**\n * Object that exposes Chartbulider's d4 chart constructors\n */\nvar cb_charts = {\n\t/**\n\t * Chartbuilder's XY chart constructor. It is capable of rendering line, column, and\n\t * dot (scatter) charts, and any combination of those, as well as dual axes.\n\t * @return {object} xy\n\t */\n\tcb_xy: cb_xy,\n\t/**\n\t * Chartbuilder's bar grid constructor. It is a slightly modified version of d4's row chart\n\t * @return {object} bar_grid\n\t */\n\tcb_bar_grid: cb_bar_grid\n};\n\nmodule.exports = cb_charts;",
      "path": "src/js/charts/cb-charts.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-charts.js#L7-L19"
    },
    "name": "cb_charts",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Chartbuilder's bar grid constructor. It is a slightly modified version of d4's row chart",
          "tags": [
            {
              "title": "returns",
              "description": "bar_grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "cb_bar_grid"
            },
            {
              "title": "memberof",
              "description": "cb_charts"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 18,
                "column": 1
              },
              "end": {
                "line": 18,
                "column": 25
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-charts.js",
            "code": "{\n\t/**\n\t * Chartbuilder's XY chart constructor. It is capable of rendering line, column, and\n\t * dot (scatter) charts, and any combination of those, as well as dual axes.\n\t * @return {object} xy\n\t */\n\tcb_xy: cb_xy,\n\t/**\n\t * Chartbuilder's bar grid constructor. It is a slightly modified version of d4's row chart\n\t * @return {object} bar_grid\n\t */\n\tcb_bar_grid: cb_bar_grid\n}",
            "path": "src/js/charts/cb-charts.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-charts.js#L18-L18"
          },
          "returns": [
            {
              "title": "returns",
              "description": "bar_grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "cb_bar_grid",
          "memberof": "cb_charts",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cb_charts",
            "cb_bar_grid"
          ]
        },
        {
          "description": "Chartbuilder's XY chart constructor. It is capable of rendering line, column, and\ndot (scatter) charts, and any combination of those, as well as dual axes.",
          "tags": [
            {
              "title": "returns",
              "description": "xy",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "cb_xy"
            },
            {
              "title": "memberof",
              "description": "cb_charts"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 13,
                "column": 1
              },
              "end": {
                "line": 13,
                "column": 13
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-charts.js",
            "code": "{\n\t/**\n\t * Chartbuilder's XY chart constructor. It is capable of rendering line, column, and\n\t * dot (scatter) charts, and any combination of those, as well as dual axes.\n\t * @return {object} xy\n\t */\n\tcb_xy: cb_xy,\n\t/**\n\t * Chartbuilder's bar grid constructor. It is a slightly modified version of d4's row chart\n\t * @return {object} bar_grid\n\t */\n\tcb_bar_grid: cb_bar_grid\n}",
            "path": "src/js/charts/cb-charts.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-charts.js#L13-L13"
          },
          "returns": [
            {
              "title": "returns",
              "description": "xy",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "cb_xy",
          "memberof": "cb_charts",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cb_charts",
            "cb_xy"
          ]
        }
      ]
    },
    "path": [
      "cb_charts"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "cb_d4_mixins"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 7,
          "column": 0
        },
        "end": {
          "line": 223,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-d4-mixins.js",
      "code": "var SessionStore = require(\"../stores/SessionStore\");\nvar separators = SessionStore.get(\"separators\");\n\n/**\n * @name cb_d4_mixins\n */\nmixins = {\n\t/**\n\t * Render a label with a rect background to conceal what is underneath the text\n\t * @name concealer_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"concealer_label\": {\n\t\t\"name\": \"concealer_label\",\n\t\t\"feature\": d4.feature('concealer-label', function(name) {\n\n\t\t\t// FIXME: We should not need to sniff this out.\n\t\t\tvar dataInColumns = function(d) {\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn d4.isContinuousScale(this.y);\n\t\t\t};\n\n\t\t\tvar anchorText = function(d) {\n\t\t\t\treturn dataInColumns.bind(this)(d) ? 'middle' : 'start';\n\t\t\t};\n\n\t\t\tvar useDiscretePosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\treturn axis(d[axis.$key]) + (axis.rangeBand() / 2);\n\t\t\t};\n\n\t\t\tvar useContinuousPosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\tvar offset = Math.abs(axis(d.y0) - axis(d.y0 + d.y)) / 2;\n\n\t\t\t\t// FIXME: Remove this hardcoding.\n\t\t\t\tvar padding = 10;\n\t\t\t\tvar val;\n\t\t\t\tif (dimension === 'x') {\n\t\t\t\t\toffset *= -1;\n\t\t\t\t\tpadding *= -1;\n\t\t\t\t}\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\tval = d.y0 + d.y;\n\t\t\t\t\treturn (val <= 0 ? axis(d.y0) : axis(val)) + offset;\n\t\t\t\t} else {\n\t\t\t\t\treturn (d[axis.$key] <= 0 ? axis(0) : axis(d[axis.$key])) - padding;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tclasses: 'concealer-label',\n\n\t\t\t\t\tkey: d4.functor(d4.defaultKey),\n\n\t\t\t\t\tstagger: true,\n\n\t\t\t\t\ttextAnchor: function(d) {\n\t\t\t\t\t\treturn anchorText.bind(this)(d);\n\t\t\t\t\t},\n\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + 17 / 2;\n\t\t\t\t\t},\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(d[this.x.$key]) + 6;\n\t\t\t\t\t},\n\t\t\t\t\ttext: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\tdy: function(d) {\n\t\t\t\t\t\treturn \"1em\";\n\t\t\t\t\t},\n\t\t\t\t\tformat: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar afterBar = 6;\n\t\t\t\t\tvar afterLabel = 6;\n\n\t\t\t\t\tvar group = d4.appendOnce(selection, 'g.' + name);\n\n\t\t\t\t\tvar labelGroups = group.selectAll('g')\n\t\t\t\t\t\t.data(data, d4.functor(scope.accessors.key).bind(this));\n\n\t\t\t\t\tlabelGroups.enter().append('g')\n\t\t\t\t\t\t.attr('class', function(d, i) {\n\t\t\t\t\t\t\treturn 'series' + i + ' ' + this.x.$key;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\n\t\t\t\t\tvar text_group = labelGroups.selectAll('g.text-group')\n\t\t\t\t\t\t.data(function(d) {\n\t\t\t\t\t\t\treturn d.values;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tgenter = text_group.enter().append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", \"text-group concealer-label\")\n\t\t\t\t\t\t.attr(\"data-index\", function(d,i)  {return i; });\n\n\t\t\t\t\tgenter.append('rect');\n\t\t\t\t\tgenter.append('text');\n\n\t\t\t\t\tvar text = text_group.selectAll(\"text\");\n\t\t\t\t\tvar rect = text_group.selectAll(\"rect\");\n\n\t\t\t\t\tvar x_func = d4.functor(scope.accessors.x).bind(this);\n\t\t\t\t\tvar y_func = d4.functor(scope.accessors.y).bind(this);\n\t\t\t\t\tvar dy_func = d4.functor(scope.accessors.dy).bind(this);\n\t\t\t\t\tvar text_func = d4.functor(scope.accessors.text).bind(this);\n\t\t\t\t\tvar format_func = d4.functor(scope.accessors.format).bind(this);\n\n\t\t\t\t\ttext_group\n\t\t\t\t\t\t.attr('transform', function(d,i){\n\t\t\t\t\t\t\treturn \"translate(\" +[x_func(d,i), y_func(d,i)] + \")\";\n\t\t\t\t\t\t});\n\n\t\t\t\t\ttext\n\t\t\t\t\t\t.text(function(d,i){\n\t\t\t\t\t\t\tindex = parseFloat(this.parentNode.getAttribute(\"data-index\"));\n\t\t\t\t\t\t\treturn format_func(text_func(d,index),index);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.attr('text-anchor', d4.functor(scope.accessors.textAnchor).bind(this))\n\t\t\t\t\t\t.attr('dy', d4.functor(scope.accessors.dy).bind(this));\n\n\t\t\t\t\ttext_group.each(function(){\n\t\t\t\t\t\tvar client_rect = this.getElementsByTagName(\"text\")[0].getBoundingClientRect();\n\t\t\t\t\t\td3.select(this.getElementsByTagName(\"rect\")[0])\n\t\t\t\t\t\t\t.attr(\"width\",client_rect.width + afterBar + afterLabel)\n\t\t\t\t\t\t\t.attr(\"height\",client_rect.height)\n\t\t\t\t\t\t\t.attr(\"x\", -afterBar)\n\t\t\t\t\t\t\t.attr(\"y\",function(d,i){\n\t\t\t\t\t\t\t\treturn (parseFloat(dy_func(d,i)) - 1) + \"em\";\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (d4.functor(scope.accessors.stagger).bind(this)()) {\n\n\t\t\t\t\t\t// FIXME: This should be moved into a helper injected using DI.\n\t\t\t\t\t\tif (d4.isContinuousScale(this.y)) {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextVertically, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextHorizontally, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\t\t\t\t\ttext_group.exit().remove();\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a label to identify a series by its name. Used in chart grids\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"series_label\": {\n\t\t\"name\": \"series-label\",\n\t\t\"feature\": d4.feature(\"label\", function(name) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar text = d4.appendOnce(selection, \"text.label\")\n\t\t\t\t\t\t.data(data);\n\n\t\t\t\t\ttext.text(function(d) { return d.label || d.name; })\n\t\t\t\t\t\t.attr('y',this.padding.top)\n\t\t\t\t\t\t.attr('x',d4.functor(scope.accessors.x).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a tick (line) for charts that don't have labels. Used in bar grid\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"no_label_tick\": {\n\t\t\"name\": \"no-label-tick\",\n\t\t\"feature\": d4.feature(\"line\", function(line) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx1: 0,\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n\t\t\t\t\t},\n\t\t\t\t\tx2: function(d) {\n\t\t\t\t\t\treturn this.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar lineGroup = d4.appendOnce(selection, \"g.tick.no-label-tick\");\n\n\t\t\t\t\tvar lines = lineGroup.selectAll('.no-label-tick')\n\t\t\t\t\t\t.data(data[0].values);\n\n\t\t\t\t\tlines.enter().append('line')\n\t\t\t\t\t\t.attr('class', 'no-label-tick')\n\t\t\t\t\t\t.attr('x1', d4.functor(scope.accessors.x1).bind(this))\n\t\t\t\t\t\t.attr('x2', d4.functor(scope.accessors.x2).bind(this))\n\t\t\t\t\t\t.attr('y2', d4.functor(scope.accessors.y).bind(this))\n\t\t\t\t\t\t.attr('y1', d4.functor(scope.accessors.y).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t}\n};\n\n\n\nmodule.exports = mixins;",
      "path": "src/js/charts/cb-d4-mixins.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-d4-mixins.js#L7-L223"
    },
    "name": "cb_d4_mixins",
    "kind": "function",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Render a label with a rect background to conceal what is underneath the text",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "concealer_label"
            },
            {
              "title": "memberof",
              "description": "cb_d4_mixins"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 14,
                "column": 1
              },
              "end": {
                "line": 161,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-d4-mixins.js",
            "code": "{\n\t/**\n\t * Render a label with a rect background to conceal what is underneath the text\n\t * @name concealer_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"concealer_label\": {\n\t\t\"name\": \"concealer_label\",\n\t\t\"feature\": d4.feature('concealer-label', function(name) {\n\n\t\t\t// FIXME: We should not need to sniff this out.\n\t\t\tvar dataInColumns = function(d) {\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn d4.isContinuousScale(this.y);\n\t\t\t};\n\n\t\t\tvar anchorText = function(d) {\n\t\t\t\treturn dataInColumns.bind(this)(d) ? 'middle' : 'start';\n\t\t\t};\n\n\t\t\tvar useDiscretePosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\treturn axis(d[axis.$key]) + (axis.rangeBand() / 2);\n\t\t\t};\n\n\t\t\tvar useContinuousPosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\tvar offset = Math.abs(axis(d.y0) - axis(d.y0 + d.y)) / 2;\n\n\t\t\t\t// FIXME: Remove this hardcoding.\n\t\t\t\tvar padding = 10;\n\t\t\t\tvar val;\n\t\t\t\tif (dimension === 'x') {\n\t\t\t\t\toffset *= -1;\n\t\t\t\t\tpadding *= -1;\n\t\t\t\t}\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\tval = d.y0 + d.y;\n\t\t\t\t\treturn (val <= 0 ? axis(d.y0) : axis(val)) + offset;\n\t\t\t\t} else {\n\t\t\t\t\treturn (d[axis.$key] <= 0 ? axis(0) : axis(d[axis.$key])) - padding;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tclasses: 'concealer-label',\n\n\t\t\t\t\tkey: d4.functor(d4.defaultKey),\n\n\t\t\t\t\tstagger: true,\n\n\t\t\t\t\ttextAnchor: function(d) {\n\t\t\t\t\t\treturn anchorText.bind(this)(d);\n\t\t\t\t\t},\n\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + 17 / 2;\n\t\t\t\t\t},\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(d[this.x.$key]) + 6;\n\t\t\t\t\t},\n\t\t\t\t\ttext: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\tdy: function(d) {\n\t\t\t\t\t\treturn \"1em\";\n\t\t\t\t\t},\n\t\t\t\t\tformat: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar afterBar = 6;\n\t\t\t\t\tvar afterLabel = 6;\n\n\t\t\t\t\tvar group = d4.appendOnce(selection, 'g.' + name);\n\n\t\t\t\t\tvar labelGroups = group.selectAll('g')\n\t\t\t\t\t\t.data(data, d4.functor(scope.accessors.key).bind(this));\n\n\t\t\t\t\tlabelGroups.enter().append('g')\n\t\t\t\t\t\t.attr('class', function(d, i) {\n\t\t\t\t\t\t\treturn 'series' + i + ' ' + this.x.$key;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\n\t\t\t\t\tvar text_group = labelGroups.selectAll('g.text-group')\n\t\t\t\t\t\t.data(function(d) {\n\t\t\t\t\t\t\treturn d.values;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tgenter = text_group.enter().append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", \"text-group concealer-label\")\n\t\t\t\t\t\t.attr(\"data-index\", function(d,i)  {return i; });\n\n\t\t\t\t\tgenter.append('rect');\n\t\t\t\t\tgenter.append('text');\n\n\t\t\t\t\tvar text = text_group.selectAll(\"text\");\n\t\t\t\t\tvar rect = text_group.selectAll(\"rect\");\n\n\t\t\t\t\tvar x_func = d4.functor(scope.accessors.x).bind(this);\n\t\t\t\t\tvar y_func = d4.functor(scope.accessors.y).bind(this);\n\t\t\t\t\tvar dy_func = d4.functor(scope.accessors.dy).bind(this);\n\t\t\t\t\tvar text_func = d4.functor(scope.accessors.text).bind(this);\n\t\t\t\t\tvar format_func = d4.functor(scope.accessors.format).bind(this);\n\n\t\t\t\t\ttext_group\n\t\t\t\t\t\t.attr('transform', function(d,i){\n\t\t\t\t\t\t\treturn \"translate(\" +[x_func(d,i), y_func(d,i)] + \")\";\n\t\t\t\t\t\t});\n\n\t\t\t\t\ttext\n\t\t\t\t\t\t.text(function(d,i){\n\t\t\t\t\t\t\tindex = parseFloat(this.parentNode.getAttribute(\"data-index\"));\n\t\t\t\t\t\t\treturn format_func(text_func(d,index),index);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.attr('text-anchor', d4.functor(scope.accessors.textAnchor).bind(this))\n\t\t\t\t\t\t.attr('dy', d4.functor(scope.accessors.dy).bind(this));\n\n\t\t\t\t\ttext_group.each(function(){\n\t\t\t\t\t\tvar client_rect = this.getElementsByTagName(\"text\")[0].getBoundingClientRect();\n\t\t\t\t\t\td3.select(this.getElementsByTagName(\"rect\")[0])\n\t\t\t\t\t\t\t.attr(\"width\",client_rect.width + afterBar + afterLabel)\n\t\t\t\t\t\t\t.attr(\"height\",client_rect.height)\n\t\t\t\t\t\t\t.attr(\"x\", -afterBar)\n\t\t\t\t\t\t\t.attr(\"y\",function(d,i){\n\t\t\t\t\t\t\t\treturn (parseFloat(dy_func(d,i)) - 1) + \"em\";\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (d4.functor(scope.accessors.stagger).bind(this)()) {\n\n\t\t\t\t\t\t// FIXME: This should be moved into a helper injected using DI.\n\t\t\t\t\t\tif (d4.isContinuousScale(this.y)) {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextVertically, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextHorizontally, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\t\t\t\t\ttext_group.exit().remove();\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a label to identify a series by its name. Used in chart grids\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"series_label\": {\n\t\t\"name\": \"series-label\",\n\t\t\"feature\": d4.feature(\"label\", function(name) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar text = d4.appendOnce(selection, \"text.label\")\n\t\t\t\t\t\t.data(data);\n\n\t\t\t\t\ttext.text(function(d) { return d.label || d.name; })\n\t\t\t\t\t\t.attr('y',this.padding.top)\n\t\t\t\t\t\t.attr('x',d4.functor(scope.accessors.x).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a tick (line) for charts that don't have labels. Used in bar grid\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"no_label_tick\": {\n\t\t\"name\": \"no-label-tick\",\n\t\t\"feature\": d4.feature(\"line\", function(line) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx1: 0,\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n\t\t\t\t\t},\n\t\t\t\t\tx2: function(d) {\n\t\t\t\t\t\treturn this.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar lineGroup = d4.appendOnce(selection, \"g.tick.no-label-tick\");\n\n\t\t\t\t\tvar lines = lineGroup.selectAll('.no-label-tick')\n\t\t\t\t\t\t.data(data[0].values);\n\n\t\t\t\t\tlines.enter().append('line')\n\t\t\t\t\t\t.attr('class', 'no-label-tick')\n\t\t\t\t\t\t.attr('x1', d4.functor(scope.accessors.x1).bind(this))\n\t\t\t\t\t\t.attr('x2', d4.functor(scope.accessors.x2).bind(this))\n\t\t\t\t\t\t.attr('y2', d4.functor(scope.accessors.y).bind(this))\n\t\t\t\t\t\t.attr('y1', d4.functor(scope.accessors.y).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t}\n}",
            "path": "src/js/charts/cb-d4-mixins.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-d4-mixins.js#L14-L161"
          },
          "name": "concealer_label",
          "memberof": "cb_d4_mixins",
          "scope": "static",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cb_d4_mixins",
            "concealer_label"
          ]
        },
        {
          "description": "Render a tick (line) for charts that don't have labels. Used in bar grid",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "series_label"
            },
            {
              "title": "memberof",
              "description": "cb_d4_mixins"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 194,
                "column": 1
              },
              "end": {
                "line": 222,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-d4-mixins.js",
            "code": "{\n\t/**\n\t * Render a label with a rect background to conceal what is underneath the text\n\t * @name concealer_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"concealer_label\": {\n\t\t\"name\": \"concealer_label\",\n\t\t\"feature\": d4.feature('concealer-label', function(name) {\n\n\t\t\t// FIXME: We should not need to sniff this out.\n\t\t\tvar dataInColumns = function(d) {\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn d4.isContinuousScale(this.y);\n\t\t\t};\n\n\t\t\tvar anchorText = function(d) {\n\t\t\t\treturn dataInColumns.bind(this)(d) ? 'middle' : 'start';\n\t\t\t};\n\n\t\t\tvar useDiscretePosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\treturn axis(d[axis.$key]) + (axis.rangeBand() / 2);\n\t\t\t};\n\n\t\t\tvar useContinuousPosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\tvar offset = Math.abs(axis(d.y0) - axis(d.y0 + d.y)) / 2;\n\n\t\t\t\t// FIXME: Remove this hardcoding.\n\t\t\t\tvar padding = 10;\n\t\t\t\tvar val;\n\t\t\t\tif (dimension === 'x') {\n\t\t\t\t\toffset *= -1;\n\t\t\t\t\tpadding *= -1;\n\t\t\t\t}\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\tval = d.y0 + d.y;\n\t\t\t\t\treturn (val <= 0 ? axis(d.y0) : axis(val)) + offset;\n\t\t\t\t} else {\n\t\t\t\t\treturn (d[axis.$key] <= 0 ? axis(0) : axis(d[axis.$key])) - padding;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tclasses: 'concealer-label',\n\n\t\t\t\t\tkey: d4.functor(d4.defaultKey),\n\n\t\t\t\t\tstagger: true,\n\n\t\t\t\t\ttextAnchor: function(d) {\n\t\t\t\t\t\treturn anchorText.bind(this)(d);\n\t\t\t\t\t},\n\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + 17 / 2;\n\t\t\t\t\t},\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(d[this.x.$key]) + 6;\n\t\t\t\t\t},\n\t\t\t\t\ttext: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\tdy: function(d) {\n\t\t\t\t\t\treturn \"1em\";\n\t\t\t\t\t},\n\t\t\t\t\tformat: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar afterBar = 6;\n\t\t\t\t\tvar afterLabel = 6;\n\n\t\t\t\t\tvar group = d4.appendOnce(selection, 'g.' + name);\n\n\t\t\t\t\tvar labelGroups = group.selectAll('g')\n\t\t\t\t\t\t.data(data, d4.functor(scope.accessors.key).bind(this));\n\n\t\t\t\t\tlabelGroups.enter().append('g')\n\t\t\t\t\t\t.attr('class', function(d, i) {\n\t\t\t\t\t\t\treturn 'series' + i + ' ' + this.x.$key;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\n\t\t\t\t\tvar text_group = labelGroups.selectAll('g.text-group')\n\t\t\t\t\t\t.data(function(d) {\n\t\t\t\t\t\t\treturn d.values;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tgenter = text_group.enter().append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", \"text-group concealer-label\")\n\t\t\t\t\t\t.attr(\"data-index\", function(d,i)  {return i; });\n\n\t\t\t\t\tgenter.append('rect');\n\t\t\t\t\tgenter.append('text');\n\n\t\t\t\t\tvar text = text_group.selectAll(\"text\");\n\t\t\t\t\tvar rect = text_group.selectAll(\"rect\");\n\n\t\t\t\t\tvar x_func = d4.functor(scope.accessors.x).bind(this);\n\t\t\t\t\tvar y_func = d4.functor(scope.accessors.y).bind(this);\n\t\t\t\t\tvar dy_func = d4.functor(scope.accessors.dy).bind(this);\n\t\t\t\t\tvar text_func = d4.functor(scope.accessors.text).bind(this);\n\t\t\t\t\tvar format_func = d4.functor(scope.accessors.format).bind(this);\n\n\t\t\t\t\ttext_group\n\t\t\t\t\t\t.attr('transform', function(d,i){\n\t\t\t\t\t\t\treturn \"translate(\" +[x_func(d,i), y_func(d,i)] + \")\";\n\t\t\t\t\t\t});\n\n\t\t\t\t\ttext\n\t\t\t\t\t\t.text(function(d,i){\n\t\t\t\t\t\t\tindex = parseFloat(this.parentNode.getAttribute(\"data-index\"));\n\t\t\t\t\t\t\treturn format_func(text_func(d,index),index);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.attr('text-anchor', d4.functor(scope.accessors.textAnchor).bind(this))\n\t\t\t\t\t\t.attr('dy', d4.functor(scope.accessors.dy).bind(this));\n\n\t\t\t\t\ttext_group.each(function(){\n\t\t\t\t\t\tvar client_rect = this.getElementsByTagName(\"text\")[0].getBoundingClientRect();\n\t\t\t\t\t\td3.select(this.getElementsByTagName(\"rect\")[0])\n\t\t\t\t\t\t\t.attr(\"width\",client_rect.width + afterBar + afterLabel)\n\t\t\t\t\t\t\t.attr(\"height\",client_rect.height)\n\t\t\t\t\t\t\t.attr(\"x\", -afterBar)\n\t\t\t\t\t\t\t.attr(\"y\",function(d,i){\n\t\t\t\t\t\t\t\treturn (parseFloat(dy_func(d,i)) - 1) + \"em\";\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (d4.functor(scope.accessors.stagger).bind(this)()) {\n\n\t\t\t\t\t\t// FIXME: This should be moved into a helper injected using DI.\n\t\t\t\t\t\tif (d4.isContinuousScale(this.y)) {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextVertically, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextHorizontally, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\t\t\t\t\ttext_group.exit().remove();\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a label to identify a series by its name. Used in chart grids\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"series_label\": {\n\t\t\"name\": \"series-label\",\n\t\t\"feature\": d4.feature(\"label\", function(name) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar text = d4.appendOnce(selection, \"text.label\")\n\t\t\t\t\t\t.data(data);\n\n\t\t\t\t\ttext.text(function(d) { return d.label || d.name; })\n\t\t\t\t\t\t.attr('y',this.padding.top)\n\t\t\t\t\t\t.attr('x',d4.functor(scope.accessors.x).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a tick (line) for charts that don't have labels. Used in bar grid\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"no_label_tick\": {\n\t\t\"name\": \"no-label-tick\",\n\t\t\"feature\": d4.feature(\"line\", function(line) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx1: 0,\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n\t\t\t\t\t},\n\t\t\t\t\tx2: function(d) {\n\t\t\t\t\t\treturn this.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar lineGroup = d4.appendOnce(selection, \"g.tick.no-label-tick\");\n\n\t\t\t\t\tvar lines = lineGroup.selectAll('.no-label-tick')\n\t\t\t\t\t\t.data(data[0].values);\n\n\t\t\t\t\tlines.enter().append('line')\n\t\t\t\t\t\t.attr('class', 'no-label-tick')\n\t\t\t\t\t\t.attr('x1', d4.functor(scope.accessors.x1).bind(this))\n\t\t\t\t\t\t.attr('x2', d4.functor(scope.accessors.x2).bind(this))\n\t\t\t\t\t\t.attr('y2', d4.functor(scope.accessors.y).bind(this))\n\t\t\t\t\t\t.attr('y1', d4.functor(scope.accessors.y).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t}\n}",
            "path": "src/js/charts/cb-d4-mixins.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-d4-mixins.js#L194-L222"
          },
          "name": "series_label",
          "memberof": "cb_d4_mixins",
          "scope": "static",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cb_d4_mixins",
            "series_label"
          ]
        },
        {
          "description": "Render a label to identify a series by its name. Used in chart grids",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "series_label"
            },
            {
              "title": "memberof",
              "description": "cb_d4_mixins"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 168,
                "column": 1
              },
              "end": {
                "line": 187,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-d4-mixins.js",
            "code": "{\n\t/**\n\t * Render a label with a rect background to conceal what is underneath the text\n\t * @name concealer_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"concealer_label\": {\n\t\t\"name\": \"concealer_label\",\n\t\t\"feature\": d4.feature('concealer-label', function(name) {\n\n\t\t\t// FIXME: We should not need to sniff this out.\n\t\t\tvar dataInColumns = function(d) {\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn d4.isContinuousScale(this.y);\n\t\t\t};\n\n\t\t\tvar anchorText = function(d) {\n\t\t\t\treturn dataInColumns.bind(this)(d) ? 'middle' : 'start';\n\t\t\t};\n\n\t\t\tvar useDiscretePosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\treturn axis(d[axis.$key]) + (axis.rangeBand() / 2);\n\t\t\t};\n\n\t\t\tvar useContinuousPosition = function(dimension, d) {\n\t\t\t\tvar axis = this[dimension];\n\t\t\t\tvar offset = Math.abs(axis(d.y0) - axis(d.y0 + d.y)) / 2;\n\n\t\t\t\t// FIXME: Remove this hardcoding.\n\t\t\t\tvar padding = 10;\n\t\t\t\tvar val;\n\t\t\t\tif (dimension === 'x') {\n\t\t\t\t\toffset *= -1;\n\t\t\t\t\tpadding *= -1;\n\t\t\t\t}\n\t\t\t\tif (d4.isDefined(d.y0)) {\n\t\t\t\t\tval = d.y0 + d.y;\n\t\t\t\t\treturn (val <= 0 ? axis(d.y0) : axis(val)) + offset;\n\t\t\t\t} else {\n\t\t\t\t\treturn (d[axis.$key] <= 0 ? axis(0) : axis(d[axis.$key])) - padding;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tclasses: 'concealer-label',\n\n\t\t\t\t\tkey: d4.functor(d4.defaultKey),\n\n\t\t\t\t\tstagger: true,\n\n\t\t\t\t\ttextAnchor: function(d) {\n\t\t\t\t\t\treturn anchorText.bind(this)(d);\n\t\t\t\t\t},\n\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + 17 / 2;\n\t\t\t\t\t},\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(d[this.x.$key]) + 6;\n\t\t\t\t\t},\n\t\t\t\t\ttext: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t},\n\t\t\t\t\tdy: function(d) {\n\t\t\t\t\t\treturn \"1em\";\n\t\t\t\t\t},\n\t\t\t\t\tformat: function(d,i) {\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar afterBar = 6;\n\t\t\t\t\tvar afterLabel = 6;\n\n\t\t\t\t\tvar group = d4.appendOnce(selection, 'g.' + name);\n\n\t\t\t\t\tvar labelGroups = group.selectAll('g')\n\t\t\t\t\t\t.data(data, d4.functor(scope.accessors.key).bind(this));\n\n\t\t\t\t\tlabelGroups.enter().append('g')\n\t\t\t\t\t\t.attr('class', function(d, i) {\n\t\t\t\t\t\t\treturn 'series' + i + ' ' + this.x.$key;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\n\t\t\t\t\tvar text_group = labelGroups.selectAll('g.text-group')\n\t\t\t\t\t\t.data(function(d) {\n\t\t\t\t\t\t\treturn d.values;\n\t\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\tgenter = text_group.enter().append(\"g\")\n\t\t\t\t\t\t.attr(\"class\", \"text-group concealer-label\")\n\t\t\t\t\t\t.attr(\"data-index\", function(d,i)  {return i; });\n\n\t\t\t\t\tgenter.append('rect');\n\t\t\t\t\tgenter.append('text');\n\n\t\t\t\t\tvar text = text_group.selectAll(\"text\");\n\t\t\t\t\tvar rect = text_group.selectAll(\"rect\");\n\n\t\t\t\t\tvar x_func = d4.functor(scope.accessors.x).bind(this);\n\t\t\t\t\tvar y_func = d4.functor(scope.accessors.y).bind(this);\n\t\t\t\t\tvar dy_func = d4.functor(scope.accessors.dy).bind(this);\n\t\t\t\t\tvar text_func = d4.functor(scope.accessors.text).bind(this);\n\t\t\t\t\tvar format_func = d4.functor(scope.accessors.format).bind(this);\n\n\t\t\t\t\ttext_group\n\t\t\t\t\t\t.attr('transform', function(d,i){\n\t\t\t\t\t\t\treturn \"translate(\" +[x_func(d,i), y_func(d,i)] + \")\";\n\t\t\t\t\t\t});\n\n\t\t\t\t\ttext\n\t\t\t\t\t\t.text(function(d,i){\n\t\t\t\t\t\t\tindex = parseFloat(this.parentNode.getAttribute(\"data-index\"));\n\t\t\t\t\t\t\treturn format_func(text_func(d,index),index);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.attr('text-anchor', d4.functor(scope.accessors.textAnchor).bind(this))\n\t\t\t\t\t\t.attr('dy', d4.functor(scope.accessors.dy).bind(this));\n\n\t\t\t\t\ttext_group.each(function(){\n\t\t\t\t\t\tvar client_rect = this.getElementsByTagName(\"text\")[0].getBoundingClientRect();\n\t\t\t\t\t\td3.select(this.getElementsByTagName(\"rect\")[0])\n\t\t\t\t\t\t\t.attr(\"width\",client_rect.width + afterBar + afterLabel)\n\t\t\t\t\t\t\t.attr(\"height\",client_rect.height)\n\t\t\t\t\t\t\t.attr(\"x\", -afterBar)\n\t\t\t\t\t\t\t.attr(\"y\",function(d,i){\n\t\t\t\t\t\t\t\treturn (parseFloat(dy_func(d,i)) - 1) + \"em\";\n\t\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tif (d4.functor(scope.accessors.stagger).bind(this)()) {\n\n\t\t\t\t\t\t// FIXME: This should be moved into a helper injected using DI.\n\t\t\t\t\t\tif (d4.isContinuousScale(this.y)) {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextVertically, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgroup.selectAll('text').call(d4.helpers.staggerTextHorizontally, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelGroups.exit().remove();\n\t\t\t\t\ttext_group.exit().remove();\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a label to identify a series by its name. Used in chart grids\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"series_label\": {\n\t\t\"name\": \"series-label\",\n\t\t\"feature\": d4.feature(\"label\", function(name) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx: function(d) {\n\t\t\t\t\t\treturn this.x(0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar text = d4.appendOnce(selection, \"text.label\")\n\t\t\t\t\t\t.data(data);\n\n\t\t\t\t\ttext.text(function(d) { return d.label || d.name; })\n\t\t\t\t\t\t.attr('y',this.padding.top)\n\t\t\t\t\t\t.attr('x',d4.functor(scope.accessors.x).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t},\n\t/**\n\t * Render a tick (line) for charts that don't have labels. Used in bar grid\n\t * @name series_label\n\t * @memberof cb_d4_mixins\n\t * @static\n\t */\n\t\"no_label_tick\": {\n\t\t\"name\": \"no-label-tick\",\n\t\t\"feature\": d4.feature(\"line\", function(line) {\n\t\t\treturn {\n\t\t\t\taccessors: {\n\t\t\t\t\tx1: 0,\n\t\t\t\t\ty: function(d) {\n\t\t\t\t\t\treturn this.y(d[this.y.$key]) + (this.y.rangeBand() / 2);\n\t\t\t\t\t},\n\t\t\t\t\tx2: function(d) {\n\t\t\t\t\t\treturn this.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trender: function(scope, data, selection) {\n\t\t\t\t\tvar lineGroup = d4.appendOnce(selection, \"g.tick.no-label-tick\");\n\n\t\t\t\t\tvar lines = lineGroup.selectAll('.no-label-tick')\n\t\t\t\t\t\t.data(data[0].values);\n\n\t\t\t\t\tlines.enter().append('line')\n\t\t\t\t\t\t.attr('class', 'no-label-tick')\n\t\t\t\t\t\t.attr('x1', d4.functor(scope.accessors.x1).bind(this))\n\t\t\t\t\t\t.attr('x2', d4.functor(scope.accessors.x2).bind(this))\n\t\t\t\t\t\t.attr('y2', d4.functor(scope.accessors.y).bind(this))\n\t\t\t\t\t\t.attr('y1', d4.functor(scope.accessors.y).bind(this));\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t}\n}",
            "path": "src/js/charts/cb-d4-mixins.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-d4-mixins.js#L168-L187"
          },
          "name": "series_label",
          "memberof": "cb_d4_mixins",
          "scope": "static",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "cb_d4_mixins",
            "series_label"
          ]
        }
      ]
    },
    "path": [
      "cb_d4_mixins"
    ]
  },
  {
    "description": "### Configuration of a Chart grid",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "chart_grid_config"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 26,
          "column": 0
        },
        "end": {
          "line": 49,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-config.js",
      "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of a Chart grid\n * @name chart_grid_config\n */\n\n/**\n* display\n* @static\n* @memberof chart_grid_config\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} paddingBerBar - Space btwn two bars in a bar grid\n* @property {Nem|number} barHeight - Height of an individual bar in a bar grid\n* @property {Nem|number} afterXYBottom - Vert distance btwn two chart grids that are stacked\n* @property {Nem|number} afterXYRight - Horiz distance btwn two chart grids that are next to each other\n* @property {Nem|number} columnExtraPadding - Extra padding given if a chart grid XY has columns\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} xy - Copy of `xy_config.display`, used in XY chart grids\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tafterTitle: \"1.25em\", // distance between top of title and top of legend or chart\n\tafterLegend: \"0.5em\", // distance between top of legend and top of chart\n\tblockerRectOffset: 6, // distance between text and background blocker rect\n\tpaddingPerBar: \"0.7em\", // extra space around bars\n\tbarHeight: \"0.9em\", // height of each bars\n\tafterXYBottom: \"2em\",\n\tafterXYRight: \"0.8em\",\n\tcolumnExtraPadding: \"0.5em\",\n\tbottomPaddingWithoutFooter: \"0.5em\",\n\txy: require(\"../cb-xy/xy-config\").display,\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: \"0.5em\",\n\t\tright: 0,\n\t\tbottom: \"1.5em\",\n\t\tleft: 0\n\t}\n};\n/**\n* @name chart_grid_defaultProps\n* @static\n* @memberof chart_grid_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {object} input\n\t * @property {array} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _grid - Grid settings\n\t * @property {number} _grid.rows - Number of rows in the grid\n\t * @property {number} _grid.cols - Number of columns in the grid\n\t * @property {string} _grid.type - Grid type `(bars|lines|dots|columns)`\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tchartProps: {\n\t\tinput: {},\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\tcolorIndex: 0,\n\t\t\t\tbarHeight: \"0.85em\"\n\t\t\t}\n\t\t],\n\t\t_grid: {\n\t\t\trows: 1,\n\t\t\ttype: null\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tmetadata: {\n\t\tid: null,\n\t\tchartType: \"chartgrid\",\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar chart_grid_config = new ChartConfig({\n\tdisplayName: \"Chart grid\",\n\tparser: require(\"./parse-chart-grid\"),\n\tcalculateDimensions: require(\"./chart-grid-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = chart_grid_config;",
      "path": "src/js/charts/cb-chart-grid/chart-grid-config.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-config.js#L26-L49"
    },
    "name": "chart_grid_config",
    "members": {
      "instance": [
        {
          "description": "see [ChartConfig#calculateDimensions](#chartconfig/calculatedimensions)",
          "tags": [
            {
              "title": "see",
              "description": "ChartConfig#calculateDimensions"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "chart_grid_config"
            },
            {
              "title": "name",
              "name": "chartGridDimensions"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 9,
                "column": 0
              },
              "end": {
                "line": 38,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-dimensions.js",
            "code": "var chartSizes = require(\"../../config/chart-sizes\");\n\n/**\n * see [ChartConfig#calculateDimensions](#chartconfig/calculatedimensions)\n * @see ChartConfig#calculateDimensions\n * @instance\n * @memberof chart_grid_config\n */\nfunction chartGridDimensions(width, opts) {\n\tvar height;\n\tvar model = opts.model;\n\tvar metadata = model.metadata;\n\tvar grid = model.chartProps._grid;\n\n\tif (metadata.size == \"auto\" || opts.enableResponsive) {\n\t\t// use current width\n\t} else {\n\t\twidth = chartSizes[metadata.size].width;\n\t}\n\n\tif (grid.type == \"bar\") {\n\t\tvar numDataPoints = model.chartProps.data[0].values.length;\n\t\theight = calculate_bar_height(numDataPoints, grid, opts.displayConfig, opts.extraHeight);\n\t} else {\n\t\theight = calculate_cartesian_height(width, grid, opts.displayConfig, opts.extraHeight);\n\t}\n\n\tif (model.metadata.title.length > 0 && opts.showMetadata) {\n\t\theight += opts.displayConfig.afterTitle;\n\t} else if (!opts.showMetadata) {\n\t\theight -= opts.displayConfig.padding.bottom;\n\t}\n\n\treturn {\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n\nfunction calculate_bar_height(numDataPoints, grid, displayConfig, extraHeight) {\n\tvar perChart = (displayConfig.afterLegend + displayConfig.padding.top + displayConfig.afterXYBottom);\n\tvar perBar = (displayConfig.paddingPerBar + displayConfig.barHeight);\n\tvar singleChart = (perChart + (perBar * numDataPoints));\n\tvar allBars = singleChart * grid.rows;\n\treturn extraHeight + allBars;\n}\n\nfunction calculate_cartesian_height(width, grid, displayConfig, extraHeight) {\n\tvar height =\n\t\t(grid.rows * (((width / grid.cols) * displayConfig.xy.aspectRatio.wide) + displayConfig.afterLegend)) +\n\t\t(grid.rows - 1) * displayConfig.afterXYBottom +\n\t\textraHeight + displayConfig.xy.padding.bottom;\n\n\treturn height;\n}\n\nmodule.exports = chartGridDimensions;",
            "path": "src/js/charts/cb-chart-grid/chart-grid-dimensions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-dimensions.js#L9-L38"
          },
          "scope": "instance",
          "memberof": "chart_grid_config",
          "name": "chartGridDimensions",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "chart_grid_config",
            "chartGridDimensions"
          ]
        },
        {
          "description": "see [ChartConfig#parser](#chartconfig/parser)",
          "tags": [
            {
              "title": "see",
              "description": "ChartConfig#parser"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "chart_grid_config"
            },
            {
              "title": "name",
              "name": "parseChartgrid"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 14,
                "column": 0
              },
              "end": {
                "line": 107,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/parse-chart-grid.js",
            "code": "var clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar assign = require(\"lodash/object/assign\");\n\nvar dataBySeries = require(\"../../util/parse-data-by-series\");\nvar help = require(\"../../util/helper\");\n\n/**\n * see [ChartConfig#parser](#chartconfig/parser)\n * @see ChartConfig#parser\n * @instance\n * @memberof chart_grid_config\n */\nfunction parseChartgrid(config, _chartProps, callback, parseOpts) {\n\t// Build chart settings from defaults or provided settings\n\tvar chartProps = JSON.parse(JSON.stringify(_chartProps));\n\tvar chartgrid_defaults = config.defaultProps.chartProps;\n\tvar primaryScale = chartProps.scale.primaryScale || clone(config.defaultProps.chartProps.scale.primaryScale);\n\tvar scaleData = [];\n\tvar domain;\n\tvar height;\n\tvar isColumnOrBar;\n\n\tparseOpts = parseOpts || {};\n\n\t// dont check for date column if grid type is bar\n\tvar checkForDate = chartProps._grid.type !== \"bar\";\n\tvar bySeries = dataBySeries(chartProps.input.raw, { checkForDate: checkForDate });\n\n\tvar gridSettings = {\n\t\trows: +chartProps._grid.rows || chartgrid_defaults._grid.rows,\n\t\tcols: +chartProps._grid.cols || bySeries.series.length\n\t};\n\n\tvar chartSettings = map(bySeries.series, function(dataSeries, i) {\n\t\tvar settings;\n\t\t// add data points to relevant scale\n\t\tscaleData = scaleData.concat(map(dataSeries.values, function(d) {\n\t\t\treturn +d.value;\n\t\t}));\n\n\t\tif (chartProps.chartSettings[i]) {\n\t\t\tsettings = chartProps.chartSettings[i];\n\t\t} else {\n\t\t\tsettings = clone(chartgrid_defaults.chartSettings[0]);\n\t\t\tsettings.colorIndex = i;\n\t\t}\n\n\t\tif (parseOpts.columnsChanged) {\n\t\t\tsettings.label = dataSeries.name;\n\t\t} else {\n\t\t\tsettings.label = settings.label || dataSeries.name;\n\t\t}\n\n\t\treturn settings;\n\t});\n\n\tchartProps.scale.hasDate = bySeries.hasDate;\n\n\tif (bySeries.hasDate) {\n\t\tchartProps.scale.dateSettings = chartProps.scale.dateSettings || clone(config.defaultProps.chartProps.scale.dateSettings);\n\t\t// for dates, default type should be line\n\t\tgridSettings.type = _chartProps._grid.type || \"line\";\n\t\tisColumnOrBar = (gridSettings.type === \"column\" || gridSettings.type === \"bar\");\n\t\tdomain = help.computeScaleDomain(primaryScale, scaleData, {\n\t\t\tnice: true,\n\t\t\tminZero: isColumnOrBar\n\t\t});\n\t\tassign(primaryScale, domain);\n\t} else {\n\t\t// for non-dates, default type should be bar\n\t\tgridSettings.type = _chartProps._grid.type || \"bar\";\n\t\tisColumnOrBar = (gridSettings.type == \"column\" || gridSettings.type == \"bar\");\n\t\tdomain = help.computeScaleDomain(primaryScale, scaleData, {\n\t\t\tminZero: isColumnOrBar\n\t\t});\n\t\tassign(primaryScale, domain);\n\t}\n\n\tchartProps.scale.primaryScale = primaryScale;\n\tif (!chartProps.mobile) {\n\t\tchartProps.mobile = {};\n\t}\n\n\tif (chartProps.mobile.scale) {\n\t\tchartProps.mobile.scale.hasDate = bySeries.hasDate;\n\t}\n\n\tif (gridSettings.type != \"bar\") {\n\t\tprimaryScale.ticks = primaryScale.ticks || 5;\n\t\tprimaryScale.precision = primaryScale.precision || 0;\n\t}\n\n\tvar newChartProps = assign(chartProps, {\n\t\tchartSettings: chartSettings,\n\t\tscale: chartProps.scale,\n\t\tinput: bySeries.input,\n\t\t_grid: gridSettings,\n\t\tdata: bySeries.series\n\t});\n\n\tif (callback) {\n\t\tcallback(newChartProps);\n\t} else {\n\t\treturn newChartProps;\n\t}\n}\n\nmodule.exports = parseChartgrid;",
            "path": "src/js/charts/cb-chart-grid/parse-chart-grid.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/parse-chart-grid.js#L14-L107"
          },
          "scope": "instance",
          "memberof": "chart_grid_config",
          "name": "parseChartgrid",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "chart_grid_config",
            "parseChartgrid"
          ]
        }
      ],
      "static": [
        {
          "description": "",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "chart_grid_defaultProps"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "chart_grid_config"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 55,
                "column": 0
              },
              "end": {
                "line": 118,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-config.js",
            "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of a Chart grid\n * @name chart_grid_config\n */\n\n/**\n* display\n* @static\n* @memberof chart_grid_config\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} paddingBerBar - Space btwn two bars in a bar grid\n* @property {Nem|number} barHeight - Height of an individual bar in a bar grid\n* @property {Nem|number} afterXYBottom - Vert distance btwn two chart grids that are stacked\n* @property {Nem|number} afterXYRight - Horiz distance btwn two chart grids that are next to each other\n* @property {Nem|number} columnExtraPadding - Extra padding given if a chart grid XY has columns\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} xy - Copy of `xy_config.display`, used in XY chart grids\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tafterTitle: \"1.25em\", // distance between top of title and top of legend or chart\n\tafterLegend: \"0.5em\", // distance between top of legend and top of chart\n\tblockerRectOffset: 6, // distance between text and background blocker rect\n\tpaddingPerBar: \"0.7em\", // extra space around bars\n\tbarHeight: \"0.9em\", // height of each bars\n\tafterXYBottom: \"2em\",\n\tafterXYRight: \"0.8em\",\n\tcolumnExtraPadding: \"0.5em\",\n\tbottomPaddingWithoutFooter: \"0.5em\",\n\txy: require(\"../cb-xy/xy-config\").display,\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: \"0.5em\",\n\t\tright: 0,\n\t\tbottom: \"1.5em\",\n\t\tleft: 0\n\t}\n};\n/**\n* @name chart_grid_defaultProps\n* @static\n* @memberof chart_grid_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {object} input\n\t * @property {array} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _grid - Grid settings\n\t * @property {number} _grid.rows - Number of rows in the grid\n\t * @property {number} _grid.cols - Number of columns in the grid\n\t * @property {string} _grid.type - Grid type `(bars|lines|dots|columns)`\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tchartProps: {\n\t\tinput: {},\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\tcolorIndex: 0,\n\t\t\t\tbarHeight: \"0.85em\"\n\t\t\t}\n\t\t],\n\t\t_grid: {\n\t\t\trows: 1,\n\t\t\ttype: null\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tmetadata: {\n\t\tid: null,\n\t\tchartType: \"chartgrid\",\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar chart_grid_config = new ChartConfig({\n\tdisplayName: \"Chart grid\",\n\tparser: require(\"./parse-chart-grid\"),\n\tcalculateDimensions: require(\"./chart-grid-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = chart_grid_config;",
            "path": "src/js/charts/cb-chart-grid/chart-grid-config.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-config.js#L55-L118"
          },
          "name": "chart_grid_defaultProps",
          "scope": "static",
          "memberof": "chart_grid_config",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "",
                "tags": [
                  {
                    "title": "name",
                    "description": null,
                    "name": "chartProps"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for date and primary scales",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "scale"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "input"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for a given series (column) of data",
                    "type": {
                      "type": "NameExpression",
                      "name": "array"
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Additional padding. This is a dynamic\nvalue and is mostly changed within the component itself",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "extraPadding"
                  },
                  {
                    "title": "property",
                    "description": "Grid settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_grid"
                  },
                  {
                    "title": "property",
                    "description": "Number of rows in the grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "_grid.rows"
                  },
                  {
                    "title": "property",
                    "description": "Number of columns in the grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "_grid.cols"
                  },
                  {
                    "title": "property",
                    "description": "Grid type `(bars|lines|dots|columns)`",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "_grid.type"
                  },
                  {
                    "title": "property",
                    "description": "Mobile-specific override settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "mobile"
                  },
                  {
                    "title": "static",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "chart_grid_defaultProps"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 71,
                      "column": 1
                    },
                    "end": {
                      "line": 102,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-config.js",
                  "code": "{\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {object} input\n\t * @property {array} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _grid - Grid settings\n\t * @property {number} _grid.rows - Number of rows in the grid\n\t * @property {number} _grid.cols - Number of columns in the grid\n\t * @property {string} _grid.type - Grid type `(bars|lines|dots|columns)`\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tchartProps: {\n\t\tinput: {},\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\tcolorIndex: 0,\n\t\t\t\tbarHeight: \"0.85em\"\n\t\t\t}\n\t\t],\n\t\t_grid: {\n\t\t\trows: 1,\n\t\t\ttype: null\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tmetadata: {\n\t\tid: null,\n\t\tchartType: \"chartgrid\",\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n}",
                  "path": "src/js/charts/cb-chart-grid/chart-grid-config.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-config.js#L71-L102"
                },
                "name": "chartProps",
                "properties": [
                  {
                    "title": "property",
                    "description": "Default settings for date and primary scales",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "scale"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "input"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for a given series (column) of data",
                    "type": {
                      "type": "NameExpression",
                      "name": "array"
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Additional padding. This is a dynamic\nvalue and is mostly changed within the component itself",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "extraPadding"
                  },
                  {
                    "title": "property",
                    "description": "Grid settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_grid"
                  },
                  {
                    "title": "property",
                    "description": "Number of rows in the grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "_grid.rows"
                  },
                  {
                    "title": "property",
                    "description": "Number of columns in the grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "_grid.cols"
                  },
                  {
                    "title": "property",
                    "description": "Grid type `(bars|lines|dots|columns)`",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "_grid.type"
                  },
                  {
                    "title": "property",
                    "description": "Mobile-specific override settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "mobile"
                  }
                ],
                "scope": "static",
                "memberof": "chart_grid_defaultProps",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "chart_grid_config",
                  "chart_grid_defaultProps",
                  "chartProps"
                ]
              },
              {
                "description": "",
                "tags": [
                  {
                    "title": "name",
                    "description": null,
                    "name": "metadata"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "chartType"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "size"
                  },
                  {
                    "title": "static",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "chart_grid_defaultProps"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 110,
                      "column": 1
                    },
                    "end": {
                      "line": 117,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-config.js",
                  "code": "{\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {object} input\n\t * @property {array} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _grid - Grid settings\n\t * @property {number} _grid.rows - Number of rows in the grid\n\t * @property {number} _grid.cols - Number of columns in the grid\n\t * @property {string} _grid.type - Grid type `(bars|lines|dots|columns)`\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tchartProps: {\n\t\tinput: {},\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\tcolorIndex: 0,\n\t\t\t\tbarHeight: \"0.85em\"\n\t\t\t}\n\t\t],\n\t\t_grid: {\n\t\t\trows: 1,\n\t\t\ttype: null\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tmetadata: {\n\t\tid: null,\n\t\tchartType: \"chartgrid\",\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n}",
                  "path": "src/js/charts/cb-chart-grid/chart-grid-config.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-config.js#L110-L117"
                },
                "name": "metadata",
                "properties": [
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "chartType"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "size"
                  }
                ],
                "scope": "static",
                "memberof": "chart_grid_defaultProps",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "chart_grid_config",
                  "chart_grid_defaultProps",
                  "metadata"
                ]
              }
            ]
          },
          "path": [
            "chart_grid_config",
            "chart_grid_defaultProps"
          ]
        },
        {
          "description": "display",
          "tags": [
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "chart_grid_config"
            },
            {
              "title": "property",
              "description": "Distance btwn top of title and top of legend or chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterTitle"
            },
            {
              "title": "property",
              "description": "Distance btwn top of legend and top of chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterLegend"
            },
            {
              "title": "property",
              "description": "Distance btwn text of axis and its background blocker",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "blockerRectOffset"
            },
            {
              "title": "property",
              "description": "Space btwn two bars in a bar grid",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "paddingBerBar"
            },
            {
              "title": "property",
              "description": "Height of an individual bar in a bar grid",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "barHeight"
            },
            {
              "title": "property",
              "description": "Vert distance btwn two chart grids that are stacked",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterXYBottom"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn two chart grids that are next to each other",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterXYRight"
            },
            {
              "title": "property",
              "description": "Extra padding given if a chart grid XY has columns",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "columnExtraPadding"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": "Copy of `xy_config.display`, used in XY chart grids",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "xy"
            },
            {
              "title": "property",
              "description": "Distances btwn outer chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "margin"
            },
            {
              "title": "property",
              "description": "Distances btwn inner chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "padding"
            },
            {
              "title": "name",
              "name": "display"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 26,
                "column": 0
              },
              "end": {
                "line": 49,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-chart-grid/chart-grid-config.js",
            "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of a Chart grid\n * @name chart_grid_config\n */\n\n/**\n* display\n* @static\n* @memberof chart_grid_config\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} paddingBerBar - Space btwn two bars in a bar grid\n* @property {Nem|number} barHeight - Height of an individual bar in a bar grid\n* @property {Nem|number} afterXYBottom - Vert distance btwn two chart grids that are stacked\n* @property {Nem|number} afterXYRight - Horiz distance btwn two chart grids that are next to each other\n* @property {Nem|number} columnExtraPadding - Extra padding given if a chart grid XY has columns\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} xy - Copy of `xy_config.display`, used in XY chart grids\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tafterTitle: \"1.25em\", // distance between top of title and top of legend or chart\n\tafterLegend: \"0.5em\", // distance between top of legend and top of chart\n\tblockerRectOffset: 6, // distance between text and background blocker rect\n\tpaddingPerBar: \"0.7em\", // extra space around bars\n\tbarHeight: \"0.9em\", // height of each bars\n\tafterXYBottom: \"2em\",\n\tafterXYRight: \"0.8em\",\n\tcolumnExtraPadding: \"0.5em\",\n\tbottomPaddingWithoutFooter: \"0.5em\",\n\txy: require(\"../cb-xy/xy-config\").display,\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: \"0.5em\",\n\t\tright: 0,\n\t\tbottom: \"1.5em\",\n\t\tleft: 0\n\t}\n};\n/**\n* @name chart_grid_defaultProps\n* @static\n* @memberof chart_grid_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {object} input\n\t * @property {array} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _grid - Grid settings\n\t * @property {number} _grid.rows - Number of rows in the grid\n\t * @property {number} _grid.cols - Number of columns in the grid\n\t * @property {string} _grid.type - Grid type `(bars|lines|dots|columns)`\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tchartProps: {\n\t\tinput: {},\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\tcolorIndex: 0,\n\t\t\t\tbarHeight: \"0.85em\"\n\t\t\t}\n\t\t],\n\t\t_grid: {\n\t\t\trows: 1,\n\t\t\ttype: null\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof chart_grid_defaultProps\n\t */\n\tmetadata: {\n\t\tid: null,\n\t\tchartType: \"chartgrid\",\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar chart_grid_config = new ChartConfig({\n\tdisplayName: \"Chart grid\",\n\tparser: require(\"./parse-chart-grid\"),\n\tcalculateDimensions: require(\"./chart-grid-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = chart_grid_config;",
            "path": "src/js/charts/cb-chart-grid/chart-grid-config.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-chart-grid/chart-grid-config.js#L26-L49"
          },
          "scope": "static",
          "memberof": "chart_grid_config",
          "properties": [
            {
              "title": "property",
              "description": "Distance btwn top of title and top of legend or chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterTitle"
            },
            {
              "title": "property",
              "description": "Distance btwn top of legend and top of chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterLegend"
            },
            {
              "title": "property",
              "description": "Distance btwn text of axis and its background blocker",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "blockerRectOffset"
            },
            {
              "title": "property",
              "description": "Space btwn two bars in a bar grid",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "paddingBerBar"
            },
            {
              "title": "property",
              "description": "Height of an individual bar in a bar grid",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "barHeight"
            },
            {
              "title": "property",
              "description": "Vert distance btwn two chart grids that are stacked",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterXYBottom"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn two chart grids that are next to each other",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterXYRight"
            },
            {
              "title": "property",
              "description": "Extra padding given if a chart grid XY has columns",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "columnExtraPadding"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": "Copy of `xy_config.display`, used in XY chart grids",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "xy"
            },
            {
              "title": "property",
              "description": "Distances btwn outer chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "margin"
            },
            {
              "title": "property",
              "description": "Distances btwn inner chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "padding"
            }
          ],
          "name": "display",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "chart_grid_config",
            "display"
          ]
        }
      ]
    },
    "path": [
      "chart_grid_config"
    ]
  },
  {
    "description": "### Chartbuilder parent component",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "Chartbuilder"
      },
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "property",
        "description": "Save to localStorage after every change",
        "type": {
          "type": "NameExpression",
          "name": "boolean"
        },
        "name": "autosave"
      },
      {
        "title": "property",
        "description": "Show mobile preview underneath default chart",
        "type": {
          "type": "NameExpression",
          "name": "boolean"
        },
        "name": "showMobilePreview"
      },
      {
        "title": "property",
        "description": "Callback when state is changed",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "onStateChange"
      },
      {
        "title": "property",
        "description": "Optional additional React components",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "additionalComponents"
      },
      {
        "title": "example",
        "description": "var React = require(\"react\");\nvar Chartbuilder = require(\"./components/Chartbuilder.jsx\");\nvar container = document.querySelector(\".chartbuilder-container\");\n\nReact.render(\n  <Chartbuilder\n    autosave={true}\n    showMobilePreview={true}\n  />,\ncontainer );"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 76,
          "column": 0
        },
        "end": {
          "line": 240,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/Chartbuilder.jsx",
      "code": "var React = require(\"react\");\nrequire(\"react/addons\");\nvar update = React.addons.update;\nvar PropTypes = React.PropTypes;\n\n/* Flux stores */\nvar ChartPropertiesStore = require(\"../stores/ChartPropertiesStore\");\nvar ChartMetadataStore = require(\"../stores/ChartMetadataStore\");\nvar SessionStore = require(\"../stores/SessionStore\");\n\n/*\n * Global React components that are used irrespective of chart type\n * More info within each component's definition.\n*/\nvar Canvas = require(\"./Canvas.jsx\");\nvar ChartExport = require(\"./ChartExport.jsx\");\nvar ChartMetadata = require(\"./ChartMetadata.jsx\");\nvar ChartTypeSelector = require(\"./ChartTypeSelector.jsx\");\nvar RendererWrapper = require(\"./RendererWrapper.jsx\");\nvar LocalStorageTimer = require(\"./LocalStorageTimer.jsx\");\n\nvar svgWrapperClassName = {\n\tdesktop: \"renderer-svg-desktop\",\n\tmobile: \"renderer-svg-mobile\"\n};\n\n// Associates a given chart type with its Editor and Renderer components.\nvar chartEditors = require(\"../charts/editors\");\nvar numColors = require(\"../config/chart-style\").numColors;\n\n/* API to localStorage that allows saving and retrieving charts */\nvar ChartbuilderLocalStorageAPI = require(\"../util/ChartbuilderLocalStorageAPI\");\n\n/**\n * Function to query Flux stores for all data. Runs whenever the stores are\n * updated, usually by the Editor but occassionally by Renderers that allow\n * direct editing of the chart, eg draggable legend labels in `XYRenderer.jsx`\n * @name Chartbuilder#getStateFromStores\n * @returns {Object} Chartbuilder state\n*/\nfunction getStateFromStores() {\n\treturn {\n\t\tchartProps: ChartPropertiesStore.getAll(),\n\t\tmetadata: ChartMetadataStore.getAll(),\n\t\tsession: SessionStore.getAll()\n\t};\n}\n\n/**\n * ### Chartbuilder parent component\n * @name Chartbuilder\n * @class\n * @property {boolean} autosave - Save to localStorage after every change\n * @property {boolean} showMobilePreview - Show mobile preview underneath default chart\n * @property {function} onStateChange - Callback when state is changed\n * @property {Object} additionalComponents - Optional additional React components\n * @example\n * var React = require(\"react\");\n * var Chartbuilder = require(\"./components/Chartbuilder.jsx\");\n * var container = document.querySelector(\".chartbuilder-container\");\n *\n * React.render(\n *   <Chartbuilder\n *     autosave={true}\n *     showMobilePreview={true}\n *   />,\n * container );\n*/\nvar Chartbuilder = React.createClass({displayName: \"Chartbuilder\",\n\n\tpropTypes: {\n\t\tautosave: PropTypes.bool,\n\t\tshowMobilePreview: PropTypes.bool,\n\t\tonSave: PropTypes.func,\n\t\tonStateChange: PropTypes.func,\n\t\tadditionalComponents: PropTypes.shape({\n\t\t\tmetadata: PropTypes.array,\n\t\t\tmisc: PropTypes.object\n\t\t})\n\t},\n\n\tgetInitialState: function() {\n\t\treturn getStateFromStores();\n\t},\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tautosave: true,\n\t\t\tadditionalComponents: {\n\t\t\t\tmetadata: [],\n\t\t\t\tmisc: {}\n\t\t\t}\n\t\t};\n\t},\n\n\t/* Add listeners to update component state when stores update */\n\tcomponentDidMount: function() {\n\t\tChartPropertiesStore.addChangeListener(this._onChange);\n\t\tChartMetadataStore.addChangeListener(this._onChange);\n\t\tSessionStore.addChangeListener(this._onChange);\n\t},\n\n\t/* Remove listeners on component unmount */\n\tcomponentWillUnmount: function() {\n\t\tChartPropertiesStore.removeChangeListener(this._onChange);\n\t\tChartMetadataStore.removeChangeListener(this._onChange);\n\t\tSessionStore.removeChangeListener(this._onChange);\n\t},\n\n\t/*\n\t * Identify the chart type used and render its Editor. The corresponding\n\t * Renderer is rendered within `RendererWrapper`, in case a Chartbuilder chart\n\t * is being used as a module or without the editor.\n\t*/\n\trender: function() {\n\t\tvar chartType = this.state.metadata.chartType;\n\t\tvar Editor = chartEditors[chartType].Editor;\n\n\t\t// Check for mobile override settings and pass them in\n\t\tvar MobileComponent = chartEditors[chartType].MobileOverrides;\n\t\tvar mobileOverrides;\n\t\tif (MobileComponent && this.props.showMobilePreview) {\n\t\t\tmobileOverrides = (\n\t\t\t\tReact.createElement(MobileComponent, {\n\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tmobileOverrides = null;\n\t\t}\n\n\t\tvar editorSteps = Editor.defaultProps.numSteps;\n\t\tvar mobilePreview;\n\n\t\t// Mobile preview of the chart, if told to render\n\t\tif (this.props.showMobilePreview) {\n\t\t\tmobilePreview = (\n\t\t\t\tReact.createElement(\"div\", {className: \"mobile\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-wrap\"}, \n\t\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-frame\"}, \n\t\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\t\tenableResponsive: true, \n\t\t\t\t\t\t\t\tclassName: svgWrapperClassName.mobile}\n\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\tReact.createElement(\"div\", null)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-main\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-renderer\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"desktop\"}, \n\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\tenableResponsive: false, \n\t\t\t\t\t\t\twidth: 640, \n\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\tclassName: svgWrapperClassName.desktop}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tmobilePreview\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-editor\"}, \n\t\t\t\t\tReact.createElement(ChartTypeSelector, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(LocalStorageTimer, {\n\t\t\t\t\t\ttimerOn: this.state.session.timerOn}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(Editor, {\n\t\t\t\t\t\tchartProps: this.state.chartProps, \n\t\t\t\t\t\tnumColors: numColors}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartMetadata, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 2), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.metadata}\n\t\t\t\t\t), \n\t\t\t\t\tmobileOverrides, \n\t\t\t\t\tReact.createElement(ChartExport, {\n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tsvgWrapperClassName: svgWrapperClassName.desktop, \n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 3), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.misc}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-canvas\"}, \n\t\t\t\t\tReact.createElement(Canvas, null)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * Function that is fired any time a change is made to a chart. By default it\n\t * fetches the latest chart state from the stores and updates the Chartbuilder\n\t * component with that state. If `autosave` is set to `true`, it will also\n\t * update `localStorage` with the new state.\n\t * @name _onChange\n\t * @instance\n\t * @memberof Chartbuilder\n\t */\n\t_onChange: function() {\n\t\t// On change, update and save state.\n\t\tvar state = getStateFromStores();\n\t\tthis.setState(state);\n\n\t\tif (this.props.autosave && !this.state.session.timerOn) {\n\t\t\tChartbuilderLocalStorageAPI.saveChart(state);\n\t\t}\n\n\t\t// If Chartbuilder is embedded as a module,\n\t\t// accept onStateChange callback to update parent app\n\t\tif(this.props.onStateChange) {\n\t\t\tthis.props.onStateChange({\n\t\t\t\tchartProps: state.chartProps,\n\t\t\t\tmetadata: state.metadata\n\t\t\t});\n\t\t}\n\t}\n\n});\n\nmodule.exports = Chartbuilder;",
      "path": "src/js/components/Chartbuilder.jsx",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/Chartbuilder.jsx#L76-L240"
    },
    "name": "Chartbuilder",
    "properties": [
      {
        "title": "property",
        "description": "Save to localStorage after every change",
        "type": {
          "type": "NameExpression",
          "name": "boolean"
        },
        "name": "autosave"
      },
      {
        "title": "property",
        "description": "Show mobile preview underneath default chart",
        "type": {
          "type": "NameExpression",
          "name": "boolean"
        },
        "name": "showMobilePreview"
      },
      {
        "title": "property",
        "description": "Callback when state is changed",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "onStateChange"
      },
      {
        "title": "property",
        "description": "Optional additional React components",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "additionalComponents"
      }
    ],
    "examples": [
      "<span class=\"hljs-keyword\">var</span> React = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"react\"</span>);\n<span class=\"hljs-keyword\">var</span> Chartbuilder = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./components/Chartbuilder.jsx\"</span>);\n<span class=\"hljs-keyword\">var</span> container = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\".chartbuilder-container\"</span>);\n\nReact.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">Chartbuilder</span>\n    <span class=\"hljs-attribute\">autosave</span>=<span class=\"hljs-value\">{true}</span>\n    <span class=\"hljs-attribute\">showMobilePreview</span>=<span class=\"hljs-value\">{true}</span>\n  /&gt;</span>,\ncontainer );</span>"
    ],
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Function that is fired any time a change is made to a chart. By default it\nfetches the latest chart state from the stores and updates the Chartbuilder\ncomponent with that state. If `autosave` is set to `true`, it will also\nupdate `localStorage` with the new state.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "_onChange"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "Chartbuilder"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 221,
                "column": 1
              },
              "end": {
                "line": 238,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/Chartbuilder.jsx",
            "code": "{displayName: \"Chartbuilder\",\n\n\tpropTypes: {\n\t\tautosave: PropTypes.bool,\n\t\tshowMobilePreview: PropTypes.bool,\n\t\tonSave: PropTypes.func,\n\t\tonStateChange: PropTypes.func,\n\t\tadditionalComponents: PropTypes.shape({\n\t\t\tmetadata: PropTypes.array,\n\t\t\tmisc: PropTypes.object\n\t\t})\n\t},\n\n\tgetInitialState: function() {\n\t\treturn getStateFromStores();\n\t},\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tautosave: true,\n\t\t\tadditionalComponents: {\n\t\t\t\tmetadata: [],\n\t\t\t\tmisc: {}\n\t\t\t}\n\t\t};\n\t},\n\n\t/* Add listeners to update component state when stores update */\n\tcomponentDidMount: function() {\n\t\tChartPropertiesStore.addChangeListener(this._onChange);\n\t\tChartMetadataStore.addChangeListener(this._onChange);\n\t\tSessionStore.addChangeListener(this._onChange);\n\t},\n\n\t/* Remove listeners on component unmount */\n\tcomponentWillUnmount: function() {\n\t\tChartPropertiesStore.removeChangeListener(this._onChange);\n\t\tChartMetadataStore.removeChangeListener(this._onChange);\n\t\tSessionStore.removeChangeListener(this._onChange);\n\t},\n\n\t/*\n\t * Identify the chart type used and render its Editor. The corresponding\n\t * Renderer is rendered within `RendererWrapper`, in case a Chartbuilder chart\n\t * is being used as a module or without the editor.\n\t*/\n\trender: function() {\n\t\tvar chartType = this.state.metadata.chartType;\n\t\tvar Editor = chartEditors[chartType].Editor;\n\n\t\t// Check for mobile override settings and pass them in\n\t\tvar MobileComponent = chartEditors[chartType].MobileOverrides;\n\t\tvar mobileOverrides;\n\t\tif (MobileComponent && this.props.showMobilePreview) {\n\t\t\tmobileOverrides = (\n\t\t\t\tReact.createElement(MobileComponent, {\n\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tmobileOverrides = null;\n\t\t}\n\n\t\tvar editorSteps = Editor.defaultProps.numSteps;\n\t\tvar mobilePreview;\n\n\t\t// Mobile preview of the chart, if told to render\n\t\tif (this.props.showMobilePreview) {\n\t\t\tmobilePreview = (\n\t\t\t\tReact.createElement(\"div\", {className: \"mobile\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-wrap\"}, \n\t\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-frame\"}, \n\t\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\t\tenableResponsive: true, \n\t\t\t\t\t\t\t\tclassName: svgWrapperClassName.mobile}\n\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\tReact.createElement(\"div\", null)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-main\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-renderer\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"desktop\"}, \n\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\tenableResponsive: false, \n\t\t\t\t\t\t\twidth: 640, \n\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\tclassName: svgWrapperClassName.desktop}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tmobilePreview\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-editor\"}, \n\t\t\t\t\tReact.createElement(ChartTypeSelector, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(LocalStorageTimer, {\n\t\t\t\t\t\ttimerOn: this.state.session.timerOn}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(Editor, {\n\t\t\t\t\t\tchartProps: this.state.chartProps, \n\t\t\t\t\t\tnumColors: numColors}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartMetadata, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 2), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.metadata}\n\t\t\t\t\t), \n\t\t\t\t\tmobileOverrides, \n\t\t\t\t\tReact.createElement(ChartExport, {\n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tsvgWrapperClassName: svgWrapperClassName.desktop, \n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 3), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.misc}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-canvas\"}, \n\t\t\t\t\tReact.createElement(Canvas, null)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * Function that is fired any time a change is made to a chart. By default it\n\t * fetches the latest chart state from the stores and updates the Chartbuilder\n\t * component with that state. If `autosave` is set to `true`, it will also\n\t * update `localStorage` with the new state.\n\t * @name _onChange\n\t * @instance\n\t * @memberof Chartbuilder\n\t */\n\t_onChange: function() {\n\t\t// On change, update and save state.\n\t\tvar state = getStateFromStores();\n\t\tthis.setState(state);\n\n\t\tif (this.props.autosave && !this.state.session.timerOn) {\n\t\t\tChartbuilderLocalStorageAPI.saveChart(state);\n\t\t}\n\n\t\t// If Chartbuilder is embedded as a module,\n\t\t// accept onStateChange callback to update parent app\n\t\tif(this.props.onStateChange) {\n\t\t\tthis.props.onStateChange({\n\t\t\t\tchartProps: state.chartProps,\n\t\t\t\tmetadata: state.metadata\n\t\t\t});\n\t\t}\n\t}\n\n}",
            "path": "src/js/components/Chartbuilder.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/Chartbuilder.jsx#L221-L238"
          },
          "name": "_onChange",
          "scope": "instance",
          "memberof": "Chartbuilder",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "Chartbuilder",
            "_onChange"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "Chartbuilder"
    ]
  },
  {
    "description": "Function to query Flux stores for all data. Runs whenever the stores are\nupdated, usually by the Editor but occassionally by Renderers that allow\ndirect editing of the chart, eg draggable legend labels in `XYRenderer.jsx`",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "Chartbuilder#getStateFromStores"
      },
      {
        "title": "returns",
        "description": "Chartbuilder state",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        }
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 48,
          "column": 0
        },
        "end": {
          "line": 54,
          "column": 1
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/Chartbuilder.jsx",
      "code": "var React = require(\"react\");\nrequire(\"react/addons\");\nvar update = React.addons.update;\nvar PropTypes = React.PropTypes;\n\n/* Flux stores */\nvar ChartPropertiesStore = require(\"../stores/ChartPropertiesStore\");\nvar ChartMetadataStore = require(\"../stores/ChartMetadataStore\");\nvar SessionStore = require(\"../stores/SessionStore\");\n\n/*\n * Global React components that are used irrespective of chart type\n * More info within each component's definition.\n*/\nvar Canvas = require(\"./Canvas.jsx\");\nvar ChartExport = require(\"./ChartExport.jsx\");\nvar ChartMetadata = require(\"./ChartMetadata.jsx\");\nvar ChartTypeSelector = require(\"./ChartTypeSelector.jsx\");\nvar RendererWrapper = require(\"./RendererWrapper.jsx\");\nvar LocalStorageTimer = require(\"./LocalStorageTimer.jsx\");\n\nvar svgWrapperClassName = {\n\tdesktop: \"renderer-svg-desktop\",\n\tmobile: \"renderer-svg-mobile\"\n};\n\n// Associates a given chart type with its Editor and Renderer components.\nvar chartEditors = require(\"../charts/editors\");\nvar numColors = require(\"../config/chart-style\").numColors;\n\n/* API to localStorage that allows saving and retrieving charts */\nvar ChartbuilderLocalStorageAPI = require(\"../util/ChartbuilderLocalStorageAPI\");\n\n/**\n * Function to query Flux stores for all data. Runs whenever the stores are\n * updated, usually by the Editor but occassionally by Renderers that allow\n * direct editing of the chart, eg draggable legend labels in `XYRenderer.jsx`\n * @name Chartbuilder#getStateFromStores\n * @returns {Object} Chartbuilder state\n*/\nfunction getStateFromStores() {\n\treturn {\n\t\tchartProps: ChartPropertiesStore.getAll(),\n\t\tmetadata: ChartMetadataStore.getAll(),\n\t\tsession: SessionStore.getAll()\n\t};\n}\n\n/**\n * ### Chartbuilder parent component\n * @name Chartbuilder\n * @class\n * @property {boolean} autosave - Save to localStorage after every change\n * @property {boolean} showMobilePreview - Show mobile preview underneath default chart\n * @property {function} onStateChange - Callback when state is changed\n * @property {Object} additionalComponents - Optional additional React components\n * @example\n * var React = require(\"react\");\n * var Chartbuilder = require(\"./components/Chartbuilder.jsx\");\n * var container = document.querySelector(\".chartbuilder-container\");\n *\n * React.render(\n *   <Chartbuilder\n *     autosave={true}\n *     showMobilePreview={true}\n *   />,\n * container );\n*/\nvar Chartbuilder = React.createClass({displayName: \"Chartbuilder\",\n\n\tpropTypes: {\n\t\tautosave: PropTypes.bool,\n\t\tshowMobilePreview: PropTypes.bool,\n\t\tonSave: PropTypes.func,\n\t\tonStateChange: PropTypes.func,\n\t\tadditionalComponents: PropTypes.shape({\n\t\t\tmetadata: PropTypes.array,\n\t\t\tmisc: PropTypes.object\n\t\t})\n\t},\n\n\tgetInitialState: function() {\n\t\treturn getStateFromStores();\n\t},\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tautosave: true,\n\t\t\tadditionalComponents: {\n\t\t\t\tmetadata: [],\n\t\t\t\tmisc: {}\n\t\t\t}\n\t\t};\n\t},\n\n\t/* Add listeners to update component state when stores update */\n\tcomponentDidMount: function() {\n\t\tChartPropertiesStore.addChangeListener(this._onChange);\n\t\tChartMetadataStore.addChangeListener(this._onChange);\n\t\tSessionStore.addChangeListener(this._onChange);\n\t},\n\n\t/* Remove listeners on component unmount */\n\tcomponentWillUnmount: function() {\n\t\tChartPropertiesStore.removeChangeListener(this._onChange);\n\t\tChartMetadataStore.removeChangeListener(this._onChange);\n\t\tSessionStore.removeChangeListener(this._onChange);\n\t},\n\n\t/*\n\t * Identify the chart type used and render its Editor. The corresponding\n\t * Renderer is rendered within `RendererWrapper`, in case a Chartbuilder chart\n\t * is being used as a module or without the editor.\n\t*/\n\trender: function() {\n\t\tvar chartType = this.state.metadata.chartType;\n\t\tvar Editor = chartEditors[chartType].Editor;\n\n\t\t// Check for mobile override settings and pass them in\n\t\tvar MobileComponent = chartEditors[chartType].MobileOverrides;\n\t\tvar mobileOverrides;\n\t\tif (MobileComponent && this.props.showMobilePreview) {\n\t\t\tmobileOverrides = (\n\t\t\t\tReact.createElement(MobileComponent, {\n\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tmobileOverrides = null;\n\t\t}\n\n\t\tvar editorSteps = Editor.defaultProps.numSteps;\n\t\tvar mobilePreview;\n\n\t\t// Mobile preview of the chart, if told to render\n\t\tif (this.props.showMobilePreview) {\n\t\t\tmobilePreview = (\n\t\t\t\tReact.createElement(\"div\", {className: \"mobile\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-wrap\"}, \n\t\t\t\t\t\tReact.createElement(\"div\", {className: \"phone-frame\"}, \n\t\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\t\tenableResponsive: true, \n\t\t\t\t\t\t\t\tclassName: svgWrapperClassName.mobile}\n\t\t\t\t\t\t\t), \n\t\t\t\t\t\t\tReact.createElement(\"div\", null)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-main\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-renderer\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"desktop\"}, \n\t\t\t\t\t\tReact.createElement(RendererWrapper, {\n\t\t\t\t\t\t\teditable: true, /* will component be editable or only rendered */\n\t\t\t\t\t\t\tmodel: this.state, \n\t\t\t\t\t\t\tenableResponsive: false, \n\t\t\t\t\t\t\twidth: 640, \n\t\t\t\t\t\t\tshowMetadata: true, \n\t\t\t\t\t\t\tclassName: svgWrapperClassName.desktop}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tmobilePreview\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-editor\"}, \n\t\t\t\t\tReact.createElement(ChartTypeSelector, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tchartProps: this.state.chartProps}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(LocalStorageTimer, {\n\t\t\t\t\t\ttimerOn: this.state.session.timerOn}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(Editor, {\n\t\t\t\t\t\tchartProps: this.state.chartProps, \n\t\t\t\t\t\tnumColors: numColors}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartMetadata, {\n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 2), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.metadata}\n\t\t\t\t\t), \n\t\t\t\t\tmobileOverrides, \n\t\t\t\t\tReact.createElement(ChartExport, {\n\t\t\t\t\t\tdata: this.state.chartProps.data, \n\t\t\t\t\t\tsvgWrapperClassName: svgWrapperClassName.desktop, \n\t\t\t\t\t\tmetadata: this.state.metadata, \n\t\t\t\t\t\tstepNumber: String(editorSteps + 3), \n\t\t\t\t\t\tadditionalComponents: this.props.additionalComponents.misc}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"chartbuilder-canvas\"}, \n\t\t\t\t\tReact.createElement(Canvas, null)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * Function that is fired any time a change is made to a chart. By default it\n\t * fetches the latest chart state from the stores and updates the Chartbuilder\n\t * component with that state. If `autosave` is set to `true`, it will also\n\t * update `localStorage` with the new state.\n\t * @name _onChange\n\t * @instance\n\t * @memberof Chartbuilder\n\t */\n\t_onChange: function() {\n\t\t// On change, update and save state.\n\t\tvar state = getStateFromStores();\n\t\tthis.setState(state);\n\n\t\tif (this.props.autosave && !this.state.session.timerOn) {\n\t\t\tChartbuilderLocalStorageAPI.saveChart(state);\n\t\t}\n\n\t\t// If Chartbuilder is embedded as a module,\n\t\t// accept onStateChange callback to update parent app\n\t\tif(this.props.onStateChange) {\n\t\t\tthis.props.onStateChange({\n\t\t\t\tchartProps: state.chartProps,\n\t\t\t\tmetadata: state.metadata\n\t\t\t});\n\t\t}\n\t}\n\n});\n\nmodule.exports = Chartbuilder;",
      "path": "src/js/components/Chartbuilder.jsx",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/Chartbuilder.jsx#L48-L54"
    },
    "name": "Chartbuilder#getStateFromStores",
    "returns": [
      {
        "title": "returns",
        "description": "Chartbuilder state",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        }
      }
    ],
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "Chartbuilder#getStateFromStores"
    ]
  },
  {
    "description": "Flux dispatcher handles incoming payloads and sends them to flux stores.\nUsually data come from the UI, but can also come from localStorage or a\nserver",
    "tags": [
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "name",
        "description": null,
        "name": "ChartbuilderDispatcher"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 11,
          "column": 0
        },
        "end": {
          "line": 43,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/dispatcher/dispatcher.js",
      "code": "var Dispatcher = require(\"flux\").Dispatcher;\nvar assign = require(\"lodash/object/assign\");\n\n/**\n * Flux dispatcher handles incoming payloads and sends them to flux stores.\n * Usually data come from the UI, but can also come from localStorage or a\n * server\n * @class\n * @name ChartbuilderDispatcher\n*/\nvar ChartbuilderDispatcher = assign(new Dispatcher(), {\n\n\t/**\n\t * Incoming server action. Normally a localStorage object\n\t * See `./actions/ChartServerActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleServerAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"server-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t},\n\n\t/**\n\t * Incoming view action. Normally comes from a React component.\n\t * See `./actions/ChartPropertiesActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleViewAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"view-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t}\n\n});\n\nmodule.exports = ChartbuilderDispatcher;",
      "path": "src/js/dispatcher/dispatcher.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/dispatcher/dispatcher.js#L11-L43"
    },
    "name": "ChartbuilderDispatcher",
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Incoming server action. Normally a localStorage object\nSee `./actions/ChartServerActions.js`",
          "tags": [
            {
              "title": "param",
              "description": "{ eventName: \"string\", <data>: <value>}",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "action"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartbuilderDispatcher"
            },
            {
              "title": "name",
              "name": "handleServerAction"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 20,
                "column": 1
              },
              "end": {
                "line": 26,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/dispatcher/dispatcher.js",
            "code": "{\n\n\t/**\n\t * Incoming server action. Normally a localStorage object\n\t * See `./actions/ChartServerActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleServerAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"server-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t},\n\n\t/**\n\t * Incoming view action. Normally comes from a React component.\n\t * See `./actions/ChartPropertiesActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleViewAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"view-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t}\n\n}",
            "path": "src/js/dispatcher/dispatcher.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/dispatcher/dispatcher.js#L20-L26"
          },
          "params": [
            {
              "title": "param",
              "description": "{ eventName: \"string\", <data>: <value>}",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "action"
            }
          ],
          "scope": "instance",
          "memberof": "ChartbuilderDispatcher",
          "name": "handleServerAction",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartbuilderDispatcher",
            "handleServerAction"
          ]
        },
        {
          "description": "Incoming view action. Normally comes from a React component.\nSee `./actions/ChartPropertiesActions.js`",
          "tags": [
            {
              "title": "param",
              "description": "{ eventName: \"string\", <data>: <value>}",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "action"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartbuilderDispatcher"
            },
            {
              "title": "name",
              "name": "handleViewAction"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 35,
                "column": 1
              },
              "end": {
                "line": 41,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/dispatcher/dispatcher.js",
            "code": "{\n\n\t/**\n\t * Incoming server action. Normally a localStorage object\n\t * See `./actions/ChartServerActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleServerAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"server-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t},\n\n\t/**\n\t * Incoming view action. Normally comes from a React component.\n\t * See `./actions/ChartPropertiesActions.js`\n\t * @param {Object} action { eventName: \"string\", <data>: <value>}\n\t * @instance\n\t * @memberof ChartbuilderDispatcher\n\t*/\n\thandleViewAction: function(action) {\n\t\tvar payload = {\n\t\t\tsource: \"view-action\",\n\t\t\taction: action\n\t\t};\n\t\tChartbuilderDispatcher.dispatch(payload);\n\t}\n\n}",
            "path": "src/js/dispatcher/dispatcher.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/dispatcher/dispatcher.js#L35-L41"
          },
          "params": [
            {
              "title": "param",
              "description": "{ eventName: \"string\", <data>: <value>}",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "action"
            }
          ],
          "scope": "instance",
          "memberof": "ChartbuilderDispatcher",
          "name": "handleViewAction",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartbuilderDispatcher",
            "handleViewAction"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ChartbuilderDispatcher"
    ]
  },
  {
    "description": "### Chart config\nSet up a configuration object for a given chart type",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "ChartConfig"
      },
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings"
      },
      {
        "title": "property",
        "description": "How this type's name should be displayed in the interface",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "settings.displayName"
      },
      {
        "title": "property",
        "description": "Func to parse input for this chart type",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "settings.parser"
      },
      {
        "title": "property",
        "description": "Func to calculate dimensions of this chart type",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "settings.calculateDimensions"
      },
      {
        "title": "property",
        "description": "Static display config for this chart type, such as positioning and spacing",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings.display"
      },
      {
        "title": "property",
        "description": "Defaults for dynamic properties that will be used to draw the chart",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings.defaultProps"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 14,
          "column": 0
        },
        "end": {
          "line": 50,
          "column": 1
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/ChartConfig.js",
      "code": "function ChartConfig(settings) {\n\tthis.displayName = settings.displayName;\n\n\t/**\n\t * Func that parses input and settings to return newly parsed `chartProps`\n\t * @param {object} config - The parsed configuration for this chart type\n\t * @param {object} _chartProps - Previous `chartProps`\n\t * @param {function} callback - Function to pass new `chartProps` to upon parse completion\n\t * @param {object} parseOpts - Additional parse options\n\t *\n\t * @return {Object} chartProps - Updated `chartProps`\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.parser = settings.parser;\n\n\t/**\n\t * Func that returns an object of `{width: N, height: N}` that will determine\n\t * dimensions of a chart\n\t * @param {number} width - Width of container or area that will contain the chart\n\t * @param {object} model - The `chartProps` and `metadata` of the current chart\n\t * @param {object} chartConfig - Parsed chart configuration\n\t * @param {boolean} enableResponsive - Should we make dimensions relative to\n\t * container or use preset sizes\n\t * @param {number} extraHeight - Additional height we need to account for, eg\n\t * from wrapped text at the footer\n\t *\n\t * @return {Object} dimensions - Dimensions returned by calculation\n\t * @return {number} dimensions.width\n\t * @return {number} dimension.height\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.calculateDimensions = settings.calculateDimensions;\n\tthis.display = settings.display;\n\tthis.defaultProps = settings.defaultProps;\n}\n\nmodule.exports = ChartConfig;",
      "path": "src/js/charts/ChartConfig.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/ChartConfig.js#L14-L50"
    },
    "name": "ChartConfig",
    "properties": [
      {
        "title": "property",
        "description": null,
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings"
      },
      {
        "title": "property",
        "description": "How this type's name should be displayed in the interface",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "settings.displayName"
      },
      {
        "title": "property",
        "description": "Func to parse input for this chart type",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "settings.parser"
      },
      {
        "title": "property",
        "description": "Func to calculate dimensions of this chart type",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "settings.calculateDimensions"
      },
      {
        "title": "property",
        "description": "Static display config for this chart type, such as positioning and spacing",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings.display"
      },
      {
        "title": "property",
        "description": "Defaults for dynamic properties that will be used to draw the chart",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "settings.defaultProps"
      }
    ],
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "Func that returns an object of `{width: N, height: N}` that will determine\ndimensions of a chart",
          "tags": [
            {
              "title": "param",
              "description": "Width of container or area that will contain the chart",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "width"
            },
            {
              "title": "param",
              "description": "The `chartProps` and `metadata` of the current chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model"
            },
            {
              "title": "param",
              "description": "Parsed chart configuration",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartConfig"
            },
            {
              "title": "param",
              "description": "Should we make dimensions relative to\ncontainer or use preset sizes",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "enableResponsive"
            },
            {
              "title": "param",
              "description": "Additional height we need to account for, eg\nfrom wrapped text at the footer",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "extraHeight"
            },
            {
              "title": "returns",
              "description": "dimensions - Dimensions returned by calculation",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            },
            {
              "title": "returns",
              "description": "dimensions.width",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            },
            {
              "title": "returns",
              "description": "dimension.height",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            },
            {
              "title": "memberof",
              "description": "ChartConfig"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "name",
              "name": "calculateDimensions"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 47,
                "column": 1
              },
              "end": {
                "line": 47,
                "column": 57
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/ChartConfig.js",
            "code": "{\n\tthis.displayName = settings.displayName;\n\n\t/**\n\t * Func that parses input and settings to return newly parsed `chartProps`\n\t * @param {object} config - The parsed configuration for this chart type\n\t * @param {object} _chartProps - Previous `chartProps`\n\t * @param {function} callback - Function to pass new `chartProps` to upon parse completion\n\t * @param {object} parseOpts - Additional parse options\n\t *\n\t * @return {Object} chartProps - Updated `chartProps`\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.parser = settings.parser;\n\n\t/**\n\t * Func that returns an object of `{width: N, height: N}` that will determine\n\t * dimensions of a chart\n\t * @param {number} width - Width of container or area that will contain the chart\n\t * @param {object} model - The `chartProps` and `metadata` of the current chart\n\t * @param {object} chartConfig - Parsed chart configuration\n\t * @param {boolean} enableResponsive - Should we make dimensions relative to\n\t * container or use preset sizes\n\t * @param {number} extraHeight - Additional height we need to account for, eg\n\t * from wrapped text at the footer\n\t *\n\t * @return {Object} dimensions - Dimensions returned by calculation\n\t * @return {number} dimensions.width\n\t * @return {number} dimension.height\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.calculateDimensions = settings.calculateDimensions;\n\tthis.display = settings.display;\n\tthis.defaultProps = settings.defaultProps;\n}",
            "path": "src/js/charts/ChartConfig.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/ChartConfig.js#L47-L47"
          },
          "params": [
            {
              "title": "param",
              "description": "Width of container or area that will contain the chart",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "width"
            },
            {
              "title": "param",
              "description": "The `chartProps` and `metadata` of the current chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model"
            },
            {
              "title": "param",
              "description": "Parsed chart configuration",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartConfig"
            },
            {
              "title": "param",
              "description": "Should we make dimensions relative to\ncontainer or use preset sizes",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "enableResponsive"
            },
            {
              "title": "param",
              "description": "Additional height we need to account for, eg\nfrom wrapped text at the footer",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "extraHeight"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "dimensions - Dimensions returned by calculation",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            },
            {
              "title": "returns",
              "description": "dimensions.width",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            },
            {
              "title": "returns",
              "description": "dimension.height",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            }
          ],
          "memberof": "ChartConfig",
          "scope": "instance",
          "name": "calculateDimensions",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartConfig",
            "calculateDimensions"
          ]
        },
        {
          "description": "Func that parses input and settings to return newly parsed `chartProps`",
          "tags": [
            {
              "title": "param",
              "description": "The parsed configuration for this chart type",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "config"
            },
            {
              "title": "param",
              "description": "Previous `chartProps`",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "_chartProps"
            },
            {
              "title": "param",
              "description": "Function to pass new `chartProps` to upon parse completion",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "param",
              "description": "Additional parse options",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "parseOpts"
            },
            {
              "title": "returns",
              "description": "chartProps - Updated `chartProps`",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            },
            {
              "title": "memberof",
              "description": "ChartConfig"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "name",
              "name": "parser"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 28,
                "column": 1
              },
              "end": {
                "line": 28,
                "column": 31
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/ChartConfig.js",
            "code": "{\n\tthis.displayName = settings.displayName;\n\n\t/**\n\t * Func that parses input and settings to return newly parsed `chartProps`\n\t * @param {object} config - The parsed configuration for this chart type\n\t * @param {object} _chartProps - Previous `chartProps`\n\t * @param {function} callback - Function to pass new `chartProps` to upon parse completion\n\t * @param {object} parseOpts - Additional parse options\n\t *\n\t * @return {Object} chartProps - Updated `chartProps`\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.parser = settings.parser;\n\n\t/**\n\t * Func that returns an object of `{width: N, height: N}` that will determine\n\t * dimensions of a chart\n\t * @param {number} width - Width of container or area that will contain the chart\n\t * @param {object} model - The `chartProps` and `metadata` of the current chart\n\t * @param {object} chartConfig - Parsed chart configuration\n\t * @param {boolean} enableResponsive - Should we make dimensions relative to\n\t * container or use preset sizes\n\t * @param {number} extraHeight - Additional height we need to account for, eg\n\t * from wrapped text at the footer\n\t *\n\t * @return {Object} dimensions - Dimensions returned by calculation\n\t * @return {number} dimensions.width\n\t * @return {number} dimension.height\n\t * @memberof ChartConfig\n\t * @instance\n\t */\n\tthis.calculateDimensions = settings.calculateDimensions;\n\tthis.display = settings.display;\n\tthis.defaultProps = settings.defaultProps;\n}",
            "path": "src/js/charts/ChartConfig.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/ChartConfig.js#L28-L28"
          },
          "params": [
            {
              "title": "param",
              "description": "The parsed configuration for this chart type",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "config"
            },
            {
              "title": "param",
              "description": "Previous `chartProps`",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "_chartProps"
            },
            {
              "title": "param",
              "description": "Function to pass new `chartProps` to upon parse completion",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "param",
              "description": "Additional parse options",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "parseOpts"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "chartProps - Updated `chartProps`",
              "type": {
                "type": "NameExpression",
                "name": "Object"
              }
            }
          ],
          "memberof": "ChartConfig",
          "scope": "instance",
          "name": "parser",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartConfig",
            "parser"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ChartConfig"
    ]
  },
  {
    "description": "### Chart grid xScale settings parent component",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "ChartGrid_xScaleSettings"
      },
      {
        "title": "class",
        "description": null,
        "type": null,
        "name": null
      },
      {
        "title": "property",
        "description": "`chartProps.scale` object of the current chart.\nSee this component's PropTypes",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "scale"
      },
      {
        "title": "property",
        "description": "Pass the updated scale back to the parent",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "onUpdate"
      },
      {
        "title": "property",
        "description": "CSS class to apply to this component",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "className"
      },
      {
        "title": "property",
        "description": "Number to display in Editor interface",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "stepNumber"
      },
      {
        "title": "example",
        "description": "<ChartGrid_xScaleSettings\n scale={chartProps.scale}\n onUpdate={this._handlePropAndReparse.bind(null, \"scale\")}\n className=\"scale-options\"\n key=\"xScale\"\n stepNumber=\"4\"\n/>"
      },
      {
        "title": "kind",
        "kind": "class"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 30,
          "column": 0
        },
        "end": {
          "line": 151,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
      "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\nvar clone = require(\"lodash/lang/clone\");\n\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar LabelledTangle = chartbuilderUI.LabelledTangle;\nvar TextInput = chartbuilderUI.TextInput;\nvar ScaleReset = require(\"../shared/ScaleReset.jsx\");\n\n/**\n * ### Chart grid xScale settings parent component\n * @name ChartGrid_xScaleSettings\n * @class\n * @property {object} scale - `chartProps.scale` object of the current chart.\n * See this component's PropTypes\n * @property {function} onUpdate - Pass the updated scale back to the parent\n * @property {string} className - CSS class to apply to this component\n * @property {string} stepNumber - Number to display in Editor interface\n * @example\n * <ChartGrid_xScaleSettings\n *  scale={chartProps.scale}\n *  onUpdate={this._handlePropAndReparse.bind(null, \"scale\")}\n *  className=\"scale-options\"\n *  key=\"xScale\"\n *  stepNumber=\"4\"\n * />\n*/\nvar ChartGrid_xScaleSettings = React.createClass({displayName: \"ChartGrid_xScaleSettings\",\n\n\tpropTypes: {\n\t\tscale: PropTypes.shape({\n\t\t\tprimaryScale: PropTypes.shape({\n\t\t\t\tdomain: PropTypes.arrayOf(React.PropTypes.number),\n\t\t\t\tprecision: PropTypes.number,\n\t\t\t\tticks: PropTypes.number,\n\t\t\t\tprefix: PropTypes.string.isRequired,\n\t\t\t\tsuffix: PropTypes.string.isRequired\n\t\t\t}),\n\t\t}).isRequired\n\t},\n\n\t/**\n\t * _handleScaleUpdate\n\t * Apply new values to the `scale` object and pass it to the parent's callback\n\t *\n\t * @param {string} k - New scale property's key\n\t * @param {*} v - New scale proptery's value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleScaleUpdate: function(k, v) {\n\t\tvar primaryScale = clone(this.props.scale.primaryScale);\n\t\tprimaryScale[k] = v;\n\t\tvar scale = update(this.props.scale, {\n\t\t\t$merge: { primaryScale: primaryScale }\n\t\t});\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\t/**\n\t * _handleDomainUpdate\n\t * Update the domain with a new custom maximum or mimimum. Like\n\t * `_handleScaleUpdate` this passes an updated scale object to the parent\n\t *\n\t * @param {string} k - Key of the domain object. Must be `\"max\"` or `\"min\"`\n\t * @param {number} v - New domain value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleDomainUpdate: function(k, v) {\n\t\tvar scale = clone(this.props.scale, true);\n\t\tscale.primaryScale.custom = true;\n\t\tif (k == \"min\") {\n\t\t\tscale.primaryScale.domain[0] = v;\n\t\t} else if (k == \"max\") {\n\t\t\tscale.primaryScale.domain[1] = v;\n\t\t}\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\trender: function() {\n\t\tvar currScale = this.props.scale.primaryScale;\n\t\tvar domain = currScale.domain;\n\n\t\tvar tangleInputs = [\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Minimum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tvalue: domain[0], \n\t\t\t\tkey: \"customMin\"}\n\t\t\t),\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Maximum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tvalue: domain[1], \n\t\t\t\tkey: \"customMax\"}\n\t\t\t)\n\t\t];\n\n\t\tvar title_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\n\t\tif(this.props.stepNumber == \"\") {\n\t\t\ttitle_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: this.props.className}, \n\t\t\t\ttitle_block, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"prefix\"), \n\t\t\t\t\tvalue: currScale.prefix, \n\t\t\t\t\tplaceholder: \"Prefix\"}\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tid: \"suffix\", \n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"suffix\"), \n\t\t\t\t\tplaceholder: \"Suffix\", \n\t\t\t\t\tvalue: currScale.suffix}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"scale-tangle-inputs\"}, \n\t\t\t\t\ttangleInputs\n\t\t\t\t), \n\t\t\t\tReact.createElement(ScaleReset, {\n\t\t\t\t\tscale: this.props.scale, \n\t\t\t\t\tonUpdate: this.props.onUpdate, \n\t\t\t\t\tscaleId: \"primaryScale\", \n\t\t\t\t\tclassName: \"scale-reset\"}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = ChartGrid_xScaleSettings;",
      "path": "src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx#L30-L151"
    },
    "name": "ChartGrid_xScaleSettings",
    "properties": [
      {
        "title": "property",
        "description": "`chartProps.scale` object of the current chart.\nSee this component's PropTypes",
        "type": {
          "type": "NameExpression",
          "name": "object"
        },
        "name": "scale"
      },
      {
        "title": "property",
        "description": "Pass the updated scale back to the parent",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "onUpdate"
      },
      {
        "title": "property",
        "description": "CSS class to apply to this component",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "className"
      },
      {
        "title": "property",
        "description": "Number to display in Editor interface",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "stepNumber"
      }
    ],
    "examples": [
      "&lt;ChartGrid_xScaleSettings\n scale={chartProps.scale}\n onUpdate={<span class=\"hljs-keyword\">this</span>._handlePropAndReparse.bind(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"scale\"</span>)}\n className=<span class=\"hljs-string\">\"scale-options\"</span>\n key=<span class=\"hljs-string\">\"xScale\"</span>\n stepNumber=<span class=\"hljs-string\">\"4\"</span>\n/&gt;"
    ],
    "kind": "class",
    "members": {
      "instance": [
        {
          "description": "_handleDomainUpdate\nUpdate the domain with a new custom maximum or mimimum. Like\n`_handleScaleUpdate` this passes an updated scale object to the parent",
          "tags": [
            {
              "title": "param",
              "description": "Key of the domain object. Must be `\"max\"` or `\"min\"`",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "k"
            },
            {
              "title": "param",
              "description": "New domain value",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "v"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartGrid_xScaleSettings"
            },
            {
              "title": "name",
              "name": "_handleDomainUpdate"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 72,
                "column": 1
              },
              "end": {
                "line": 81,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
            "code": "{displayName: \"ChartGrid_xScaleSettings\",\n\n\tpropTypes: {\n\t\tscale: PropTypes.shape({\n\t\t\tprimaryScale: PropTypes.shape({\n\t\t\t\tdomain: PropTypes.arrayOf(React.PropTypes.number),\n\t\t\t\tprecision: PropTypes.number,\n\t\t\t\tticks: PropTypes.number,\n\t\t\t\tprefix: PropTypes.string.isRequired,\n\t\t\t\tsuffix: PropTypes.string.isRequired\n\t\t\t}),\n\t\t}).isRequired\n\t},\n\n\t/**\n\t * _handleScaleUpdate\n\t * Apply new values to the `scale` object and pass it to the parent's callback\n\t *\n\t * @param {string} k - New scale property's key\n\t * @param {*} v - New scale proptery's value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleScaleUpdate: function(k, v) {\n\t\tvar primaryScale = clone(this.props.scale.primaryScale);\n\t\tprimaryScale[k] = v;\n\t\tvar scale = update(this.props.scale, {\n\t\t\t$merge: { primaryScale: primaryScale }\n\t\t});\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\t/**\n\t * _handleDomainUpdate\n\t * Update the domain with a new custom maximum or mimimum. Like\n\t * `_handleScaleUpdate` this passes an updated scale object to the parent\n\t *\n\t * @param {string} k - Key of the domain object. Must be `\"max\"` or `\"min\"`\n\t * @param {number} v - New domain value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleDomainUpdate: function(k, v) {\n\t\tvar scale = clone(this.props.scale, true);\n\t\tscale.primaryScale.custom = true;\n\t\tif (k == \"min\") {\n\t\t\tscale.primaryScale.domain[0] = v;\n\t\t} else if (k == \"max\") {\n\t\t\tscale.primaryScale.domain[1] = v;\n\t\t}\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\trender: function() {\n\t\tvar currScale = this.props.scale.primaryScale;\n\t\tvar domain = currScale.domain;\n\n\t\tvar tangleInputs = [\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Minimum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tvalue: domain[0], \n\t\t\t\tkey: \"customMin\"}\n\t\t\t),\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Maximum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tvalue: domain[1], \n\t\t\t\tkey: \"customMax\"}\n\t\t\t)\n\t\t];\n\n\t\tvar title_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\n\t\tif(this.props.stepNumber == \"\") {\n\t\t\ttitle_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: this.props.className}, \n\t\t\t\ttitle_block, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"prefix\"), \n\t\t\t\t\tvalue: currScale.prefix, \n\t\t\t\t\tplaceholder: \"Prefix\"}\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tid: \"suffix\", \n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"suffix\"), \n\t\t\t\t\tplaceholder: \"Suffix\", \n\t\t\t\t\tvalue: currScale.suffix}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"scale-tangle-inputs\"}, \n\t\t\t\t\ttangleInputs\n\t\t\t\t), \n\t\t\t\tReact.createElement(ScaleReset, {\n\t\t\t\t\tscale: this.props.scale, \n\t\t\t\t\tonUpdate: this.props.onUpdate, \n\t\t\t\t\tscaleId: \"primaryScale\", \n\t\t\t\t\tclassName: \"scale-reset\"}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n}",
            "path": "src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx#L72-L81"
          },
          "params": [
            {
              "title": "param",
              "description": "Key of the domain object. Must be `\"max\"` or `\"min\"`",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "k"
            },
            {
              "title": "param",
              "description": "New domain value",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "v"
            }
          ],
          "scope": "instance",
          "memberof": "ChartGrid_xScaleSettings",
          "name": "_handleDomainUpdate",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartGrid_xScaleSettings",
            "_handleDomainUpdate"
          ]
        },
        {
          "description": "_handleScaleUpdate\nApply new values to the `scale` object and pass it to the parent's callback",
          "tags": [
            {
              "title": "param",
              "description": "New scale property's key",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "k"
            },
            {
              "title": "param",
              "description": "New scale proptery's value",
              "type": {
                "type": "AllLiteral"
              },
              "name": "v"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartGrid_xScaleSettings"
            },
            {
              "title": "name",
              "name": "_handleScaleUpdate"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 53,
                "column": 1
              },
              "end": {
                "line": 60,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
            "code": "{displayName: \"ChartGrid_xScaleSettings\",\n\n\tpropTypes: {\n\t\tscale: PropTypes.shape({\n\t\t\tprimaryScale: PropTypes.shape({\n\t\t\t\tdomain: PropTypes.arrayOf(React.PropTypes.number),\n\t\t\t\tprecision: PropTypes.number,\n\t\t\t\tticks: PropTypes.number,\n\t\t\t\tprefix: PropTypes.string.isRequired,\n\t\t\t\tsuffix: PropTypes.string.isRequired\n\t\t\t}),\n\t\t}).isRequired\n\t},\n\n\t/**\n\t * _handleScaleUpdate\n\t * Apply new values to the `scale` object and pass it to the parent's callback\n\t *\n\t * @param {string} k - New scale property's key\n\t * @param {*} v - New scale proptery's value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleScaleUpdate: function(k, v) {\n\t\tvar primaryScale = clone(this.props.scale.primaryScale);\n\t\tprimaryScale[k] = v;\n\t\tvar scale = update(this.props.scale, {\n\t\t\t$merge: { primaryScale: primaryScale }\n\t\t});\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\t/**\n\t * _handleDomainUpdate\n\t * Update the domain with a new custom maximum or mimimum. Like\n\t * `_handleScaleUpdate` this passes an updated scale object to the parent\n\t *\n\t * @param {string} k - Key of the domain object. Must be `\"max\"` or `\"min\"`\n\t * @param {number} v - New domain value\n\t * @instance\n\t * @memberof ChartGrid_xScaleSettings\n\t */\n\t_handleDomainUpdate: function(k, v) {\n\t\tvar scale = clone(this.props.scale, true);\n\t\tscale.primaryScale.custom = true;\n\t\tif (k == \"min\") {\n\t\t\tscale.primaryScale.domain[0] = v;\n\t\t} else if (k == \"max\") {\n\t\t\tscale.primaryScale.domain[1] = v;\n\t\t}\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\trender: function() {\n\t\tvar currScale = this.props.scale.primaryScale;\n\t\tvar domain = currScale.domain;\n\n\t\tvar tangleInputs = [\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Minimum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\tvalue: domain[0], \n\t\t\t\tkey: \"customMin\"}\n\t\t\t),\n\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\tlabel: \"Maximum\", \n\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\tvalue: domain[1], \n\t\t\t\tkey: \"customMax\"}\n\t\t\t)\n\t\t];\n\n\t\tvar title_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\n\t\tif(this.props.stepNumber == \"\") {\n\t\t\ttitle_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\t\"Set the units, max, and min of the \", this.props.axis, \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: this.props.className}, \n\t\t\t\ttitle_block, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"prefix\"), \n\t\t\t\t\tvalue: currScale.prefix, \n\t\t\t\t\tplaceholder: \"Prefix\"}\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tid: \"suffix\", \n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"suffix\"), \n\t\t\t\t\tplaceholder: \"Suffix\", \n\t\t\t\t\tvalue: currScale.suffix}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"scale-tangle-inputs\"}, \n\t\t\t\t\ttangleInputs\n\t\t\t\t), \n\t\t\t\tReact.createElement(ScaleReset, {\n\t\t\t\t\tscale: this.props.scale, \n\t\t\t\t\tonUpdate: this.props.onUpdate, \n\t\t\t\t\tscaleId: \"primaryScale\", \n\t\t\t\t\tclassName: \"scale-reset\"}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n}",
            "path": "src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGrid_xScaleSettings.jsx#L53-L60"
          },
          "params": [
            {
              "title": "param",
              "description": "New scale property's key",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "k"
            },
            {
              "title": "param",
              "description": "New scale proptery's value",
              "type": {
                "type": "AllLiteral"
              },
              "name": "v"
            }
          ],
          "scope": "instance",
          "memberof": "ChartGrid_xScaleSettings",
          "name": "_handleScaleUpdate",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartGrid_xScaleSettings",
            "_handleScaleUpdate"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ChartGrid_xScaleSettings"
    ]
  },
  {
    "description": "### ChartMetadataStore.js\nFlux store for chart metadata such as title, source, size, etc.",
    "tags": [
      {
        "title": "name",
        "name": "ChartMetadataStore"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 25,
          "column": 0
        },
        "end": {
          "line": 70,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartMetadataStore.js",
      "code": "var assign = require(\"lodash/object/assign\");\nvar clone = require(\"lodash/lang/clone\");\nvar EventEmitter = require(\"events\").EventEmitter;\n\n/* Flux dispatcher */\nvar Dispatcher = require(\"../dispatcher/dispatcher\");\n\n/* Require the `ChartProptiesStore so that we can wait for it to update */\nvar ChartPropertiesStore = require(\"./ChartPropertiesStore\");\n\n/* Singleton that houses metadata */\nvar _metadata = {};\nvar titleDirty = false;\nvar CHANGE_EVENT = \"change\";\n\n/**\n * ### ChartMetadataStore.js\n * Flux store for chart metadata such as title, source, size, etc.\n*/\nvar ChartMetadataStore = assign({}, EventEmitter.prototype, {\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tget: function(k) {\n\t\treturn _metadata[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all metadata\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tgetAll: function() {\n\t\treturn clone(_metadata);\n\t},\n\n\t/**\n\t * clear\n\t * Set metadata to empty\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tclear: function() {\n\t\t_metadata = {};\n\t}\n\n});\n\n/* Respond to actions coming from the dispatcher */\nfunction registeredCallback(payload) {\n\tvar action = payload.action;\n\tvar data;\n\n\tswitch(action.eventName) {\n\t\t/*\n\t\t* New chart model is received. Respond by first waiting for\n\t\t* `ChartProptiesStore`\n\t\t*/\n\t\tcase \"receive-model\":\n\t\t\tDispatcher.waitFor([ChartPropertiesStore.dispatchToken]);\n\t\t\t_metadata = action.model.metadata;\n\t\t\tdata = ChartPropertiesStore.get(\"data\");\n\t\t\t_metadata.title = defaultTitle(data);\n\t\t\tChartMetadataStore.emitChange();\n\t\t\tbreak;\n\n\t\t/* Metadata alone is being updated */\n\t\tcase \"update-metadata\":\n\t\t\t_metadata[action.key] = action.value;\n\t\t\t// if title is edited, set dirty to true and dont generate default anymore\n\t\t\t// TODO: we don't need to do this every time\n\t\t\tif (action.key == \"title\") {\n\t\t\t\ttitleDirty = true;\n\t\t\t}\n\t\t\tChartMetadataStore.emitChange();\n\t\t\tbreak;\n\n\t\tcase \"update-and-reparse\":\n\t\t\tif (!titleDirty) {\n\t\t\t\tdata = ChartPropertiesStore.get(\"data\");\n\t\t\t\t_metadata.title = defaultTitle(data);\n\t\t\t\tChartMetadataStore.emitChange();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// do nothing\n\t}\n\n\treturn true;\n\n}\n\n//Dispatcher.register(registeredCallback);\n/* Respond to actions coming from the dispatcher */\nChartMetadataStore.dispatchToken = Dispatcher.register(registeredCallback);\n\nfunction defaultTitle(data) {\n\tif (data.length === 1 && _metadata.title === \"\") {\n\t\treturn data[0].name;\n\t} else {\n\t\treturn _metadata.title;\n\t}\n}\n\nmodule.exports = ChartMetadataStore;",
      "path": "src/js/stores/ChartMetadataStore.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartMetadataStore.js#L25-L70"
    },
    "name": "ChartMetadataStore",
    "kind": "function",
    "members": {
      "instance": [
        {
          "description": "clear\nSet metadata to empty",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartMetadataStore"
            },
            {
              "title": "name",
              "name": "clear"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 66,
                "column": 1
              },
              "end": {
                "line": 68,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartMetadataStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tget: function(k) {\n\t\treturn _metadata[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all metadata\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tgetAll: function() {\n\t\treturn clone(_metadata);\n\t},\n\n\t/**\n\t * clear\n\t * Set metadata to empty\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tclear: function() {\n\t\t_metadata = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartMetadataStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartMetadataStore.js#L66-L68"
          },
          "scope": "instance",
          "memberof": "ChartMetadataStore",
          "name": "clear",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartMetadataStore",
            "clear"
          ]
        },
        {
          "description": "get",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "k"
            },
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartMetadataStore"
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 46,
                "column": 1
              },
              "end": {
                "line": 48,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartMetadataStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tget: function(k) {\n\t\treturn _metadata[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all metadata\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tgetAll: function() {\n\t\treturn clone(_metadata);\n\t},\n\n\t/**\n\t * clear\n\t * Set metadata to empty\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tclear: function() {\n\t\t_metadata = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartMetadataStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartMetadataStore.js#L46-L48"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "k"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            }
          ],
          "scope": "instance",
          "memberof": "ChartMetadataStore",
          "name": "get",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartMetadataStore",
            "get"
          ]
        },
        {
          "description": "getAll",
          "tags": [
            {
              "title": "returns",
              "description": "Return all metadata",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartMetadataStore"
            },
            {
              "title": "name",
              "name": "getAll"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 56,
                "column": 1
              },
              "end": {
                "line": 58,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartMetadataStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tget: function(k) {\n\t\treturn _metadata[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all metadata\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tgetAll: function() {\n\t\treturn clone(_metadata);\n\t},\n\n\t/**\n\t * clear\n\t * Set metadata to empty\n\t * @instance\n\t * @memberof ChartMetadataStore\n\t */\n\tclear: function() {\n\t\t_metadata = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartMetadataStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartMetadataStore.js#L56-L58"
          },
          "returns": [
            {
              "title": "returns",
              "description": "Return all metadata",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "scope": "instance",
          "memberof": "ChartMetadataStore",
          "name": "getAll",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartMetadataStore",
            "getAll"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ChartMetadataStore"
    ]
  },
  {
    "description": "### ChartProptiesStore.js\nFlux store for chart properties such as data, settings, scale",
    "tags": [
      {
        "title": "name",
        "name": "ChartPropertiesStore"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 74,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartPropertiesStore.js",
      "code": "var assign = require(\"lodash/object/assign\");\nvar EventEmitter = require(\"events\").EventEmitter;\n\n/* Flux dispatcher */\nvar Dispatcher = require(\"../dispatcher/dispatcher\");\n\n/*\n * Each chart type has an associated parser, defined in its chartConfig\n * settings. The `ChartProptiesStore` is resposible for parsing the input before\n * sending parsed data back to the app, so we require the configs here.\n*/\nvar chartConfig = require(\"../charts/chart-config\");\n\n/* Singleton that houses chart props */\nvar _chartProps = {};\nvar CHANGE_EVENT = \"change\";\nvar chartType;\nvar newLineRegex = /\\r\\n|\\r|\\n/;\n\n/**\n * ### ChartProptiesStore.js\n * Flux store for chart properties such as data, settings, scale\n*/\nvar ChartPropertiesStore = assign({}, EventEmitter.prototype, {\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tget: function(k) {\n\t\treturn _chartProps[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all chartProps\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tgetAll: function() {\n\t\treturn _chartProps;\n\t},\n\n\t/**\n\t * clear\n\t * Set chartProps to empty\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tclear: function() {\n\t\t_chartProps = {};\n\t}\n\n});\n\nfunction registeredCallback(payload) {\n\tvar action = payload.action;\n\tvar parser;\n\tvar config;\n\n\tswitch(action.eventName) {\n\t\t/*\n\t\t* Receive a new model, which includes metadata. Respond by parsing input and\n\t\t* setting current `chartType`.\n\t\t*/\n\t\tcase \"receive-model\":\n\t\t\tchartType = action.model.metadata.chartType;\n\t\t\tconfig = chartConfig[chartType];\n\t\t\tparser = chartConfig[chartType].parser;\n\t\t\t_chartProps = parser(config, action.model.chartProps);\n\t\t\tbreak;\n\n\t\t/*\n\t\t* Update all `chartProps`, assuming incoming payload is the entire object\n\t\t*/\n\t\tcase \"update-all-chart-props\":\n\t\t\tparser = chartConfig[chartType].parser;\n\t\t\tconfig = chartConfig[chartType];\n\t\t\tparser(config, action.chartProps, function(newProps) {\n\t\t\t\t_chartProps = newProps;\n\t\t\t\tChartPropertiesStore.emitChange();\n\t\t\t});\n\t\t\tbreak;\n\n\t\t/*\n\t\t* Update a single key in the chartProps. As it is deeply nested the payload\n\t\t* is likely still an object\n\t\t*/\n\t\tcase \"update-chart-prop\":\n\t\t\t_chartProps[action.key] = action.newProp;\n\t\t\tChartPropertiesStore.emitChange();\n\t\t\tbreak;\n\n\t\t/*\n\t\t* Update a single key in the chartProps, and also reparse the input and\n\t\t* send back to the UI\n\t\t*/\n\t\tcase \"update-and-reparse\":\n\t\t\tparser = chartConfig[chartType].parser;\n\t\t\tconfig = chartConfig[chartType];\n\t\t\t_chartProps[action.key] = action.newProp;\n\t\t\tparser(config, _chartProps, function(newProps) {\n\t\t\t\t_chartProps = newProps;\n\t\t\t\tChartPropertiesStore.emitChange();\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase \"update-data-input\":\n\t\t\tparser = chartConfig[chartType].parser;\n\t\t\tconfig = chartConfig[chartType];\n\n\t\t\tcheckColumnChange(action.newProp.raw, function(columnsChanged) {\n\t\t\t\t_chartProps[action.key] = action.newProp;\n\t\t\t\tvar parseOpts = { columnsChanged: columnsChanged };\n\t\t\t\tparser(config, _chartProps, function(newProps) {\n\t\t\t\t\t_chartProps = newProps;\n\t\t\t\t\tChartPropertiesStore.emitChange();\n\t\t\t\t}, parseOpts);\n\t\t\t});\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// do nothing\n\t}\n\treturn true;\n}\n\nfunction checkColumnChange(newInput, callback) {\n\tvar newCols = newInput.split(newLineRegex)[0];\n\tvar oldCols = _chartProps.input.raw.split(newLineRegex)[0];\n\tcallback((newCols !== oldCols));\n}\n\n/* Respond to actions coming from the dispatcher */\nChartPropertiesStore.dispatchToken = Dispatcher.register(registeredCallback);\n\nmodule.exports = ChartPropertiesStore;",
      "path": "src/js/stores/ChartPropertiesStore.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartPropertiesStore.js#L29-L74"
    },
    "name": "ChartPropertiesStore",
    "kind": "function",
    "members": {
      "instance": [
        {
          "description": "clear\nSet chartProps to empty",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartPropertiesStore"
            },
            {
              "title": "name",
              "name": "clear"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 70,
                "column": 1
              },
              "end": {
                "line": 72,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartPropertiesStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tget: function(k) {\n\t\treturn _chartProps[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all chartProps\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tgetAll: function() {\n\t\treturn _chartProps;\n\t},\n\n\t/**\n\t * clear\n\t * Set chartProps to empty\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tclear: function() {\n\t\t_chartProps = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartPropertiesStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartPropertiesStore.js#L70-L72"
          },
          "scope": "instance",
          "memberof": "ChartPropertiesStore",
          "name": "clear",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartPropertiesStore",
            "clear"
          ]
        },
        {
          "description": "get",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "k"
            },
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartPropertiesStore"
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 50,
                "column": 1
              },
              "end": {
                "line": 52,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartPropertiesStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tget: function(k) {\n\t\treturn _chartProps[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all chartProps\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tgetAll: function() {\n\t\treturn _chartProps;\n\t},\n\n\t/**\n\t * clear\n\t * Set chartProps to empty\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tclear: function() {\n\t\t_chartProps = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartPropertiesStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartPropertiesStore.js#L50-L52"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "k"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            }
          ],
          "scope": "instance",
          "memberof": "ChartPropertiesStore",
          "name": "get",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartPropertiesStore",
            "get"
          ]
        },
        {
          "description": "getAll",
          "tags": [
            {
              "title": "returns",
              "description": "Return all chartProps",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "ChartPropertiesStore"
            },
            {
              "title": "name",
              "name": "getAll"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 60,
                "column": 1
              },
              "end": {
                "line": 62,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/ChartPropertiesStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @param k\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tget: function(k) {\n\t\treturn _chartProps[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all chartProps\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tgetAll: function() {\n\t\treturn _chartProps;\n\t},\n\n\t/**\n\t * clear\n\t * Set chartProps to empty\n\t * @instance\n\t * @memberof ChartPropertiesStore\n\t */\n\tclear: function() {\n\t\t_chartProps = {};\n\t}\n\n}",
            "path": "src/js/stores/ChartPropertiesStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/ChartPropertiesStore.js#L60-L62"
          },
          "returns": [
            {
              "title": "returns",
              "description": "Return all chartProps",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "scope": "instance",
          "memberof": "ChartPropertiesStore",
          "name": "getAll",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartPropertiesStore",
            "getAll"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "ChartPropertiesStore"
    ]
  },
  {
    "description": "### ChartServerActions\nSend data from some external API, usually localStorage in our case",
    "tags": [
      {
        "title": "name",
        "name": "ChartServerActions"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 7,
          "column": 0
        },
        "end": {
          "line": 22,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartServerActions.js",
      "code": "var Dispatcher = require(\"../dispatcher/dispatcher\");\n\n/**\n * ### ChartServerActions\n * Send data from some external API, usually localStorage in our case\n*/\nvar ChartServerActions = {\n\n\t/**\n\t* Update the whole chart model\n\t* @param {Object} model\n\t* @param {object} model.chartProps\n\t* @param {object} model.metadata\n\t*/\n\treceiveModel: function(chartModel) {\n\t\tDispatcher.handleServerAction({\n\t\t\teventName: \"receive-model\",\n\t\t\tmodel: chartModel\n\t\t});\n\t}\n\n};\n\nmodule.exports = ChartServerActions;",
      "path": "src/js/actions/ChartServerActions.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartServerActions.js#L7-L22"
    },
    "name": "ChartServerActions",
    "kind": "function",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Update the whole chart model",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "model"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model.chartProps"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model.metadata"
            },
            {
              "title": "name",
              "name": "receiveModel"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartServerActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 15,
                "column": 1
              },
              "end": {
                "line": 20,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartServerActions.js",
            "code": "{\n\n\t/**\n\t* Update the whole chart model\n\t* @param {Object} model\n\t* @param {object} model.chartProps\n\t* @param {object} model.metadata\n\t*/\n\treceiveModel: function(chartModel) {\n\t\tDispatcher.handleServerAction({\n\t\t\teventName: \"receive-model\",\n\t\t\tmodel: chartModel\n\t\t});\n\t}\n\n}",
            "path": "src/js/actions/ChartServerActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartServerActions.js#L15-L20"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "Object"
              },
              "name": "model"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model.chartProps"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "model.metadata"
            }
          ],
          "name": "receiveModel",
          "kind": "function",
          "memberof": "ChartServerActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartServerActions",
            "receiveModel"
          ]
        }
      ]
    },
    "path": [
      "ChartServerActions"
    ]
  },
  {
    "description": "### ChartViewActions\nSend data from React views to Flux dispatcher, and on to the stores",
    "tags": [
      {
        "title": "name",
        "name": "ChartViewActions"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 8,
          "column": 0
        },
        "end": {
          "line": 91,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
      "code": "var Dispatcher = require(\"../dispatcher/dispatcher\");\n\n/**\n * ### ChartViewActions\n * Send data from React views to Flux dispatcher, and on to the stores\n*/\nvar ChartViewActions = {\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n};\n\nmodule.exports = ChartViewActions;",
      "path": "src/js/actions/ChartViewActions.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L8-L91"
    },
    "name": "ChartViewActions",
    "kind": "function",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Update all chart props",
          "tags": [
            {
              "title": "param",
              "description": "`chartProps`",
              "type": null,
              "name": "Object"
            },
            {
              "title": "name",
              "name": "updateAllChartProps"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartViewActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 14,
                "column": 1
              },
              "end": {
                "line": 19,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
            "code": "{\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n}",
            "path": "src/js/actions/ChartViewActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L14-L19"
          },
          "params": [
            {
              "title": "param",
              "description": "`chartProps`",
              "type": null,
              "name": "Object"
            }
          ],
          "name": "updateAllChartProps",
          "kind": "function",
          "memberof": "ChartViewActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartViewActions",
            "updateAllChartProps"
          ]
        },
        {
          "description": "Update a single chart prop and reparse the input",
          "tags": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newProp"
            },
            {
              "title": "name",
              "name": "updateAndReparse"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartViewActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 39,
                "column": 1
              },
              "end": {
                "line": 45,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
            "code": "{\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n}",
            "path": "src/js/actions/ChartViewActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L39-L45"
          },
          "params": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newProp"
            }
          ],
          "name": "updateAndReparse",
          "kind": "function",
          "memberof": "ChartViewActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartViewActions",
            "updateAndReparse"
          ]
        },
        {
          "description": "Update a single chart prop",
          "tags": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newProp"
            },
            {
              "title": "name",
              "name": "updateChartProp"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartViewActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 26,
                "column": 1
              },
              "end": {
                "line": 32,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
            "code": "{\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n}",
            "path": "src/js/actions/ChartViewActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L26-L32"
          },
          "params": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newProp"
            }
          ],
          "name": "updateChartProp",
          "kind": "function",
          "memberof": "ChartViewActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartViewActions",
            "updateChartProp"
          ]
        },
        {
          "description": "Update a data input and reparse it",
          "tags": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newInput"
            },
            {
              "title": "name",
              "name": "updateInput"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartViewActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 52,
                "column": 1
              },
              "end": {
                "line": 58,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
            "code": "{\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n}",
            "path": "src/js/actions/ChartViewActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L52-L58"
          },
          "params": [
            {
              "title": "param",
              "description": "The key used to identify this property",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newInput"
            }
          ],
          "name": "updateInput",
          "kind": "function",
          "memberof": "ChartViewActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartViewActions",
            "updateInput"
          ]
        },
        {
          "description": "Update metadata",
          "tags": [
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newMetadata"
            },
            {
              "title": "name",
              "name": "updateMetadata"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "ChartViewActions"
            },
            {
              "title": "static"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 64,
                "column": 1
              },
              "end": {
                "line": 70,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/actions/ChartViewActions.js",
            "code": "{\n\n\t/**\n\t* Update all chart props\n\t* @param {Object} - `chartProps`\n\t*/\n\tupdateAllChartProps: function(newChartProps) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-all-chart-props\",\n\t\t\tchartProps: newChartProps\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateChartProp: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-chart-prop\",\n\t\t\tkey: key,\n\t\t\tnewProp: newProp\n\t\t});\n\t},\n\n\t/**\n\t* Update a single chart prop and reparse the input\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newProp - The property's value\n\t*/\n\tupdateAndReparse: function(key, newProp) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-and-reparse\",\n\t\t\tnewProp: newProp,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update a data input and reparse it\n\t* @param {string} key - The key used to identify this property\n\t* @param {object} newInput - The property's value\n\t*/\n\tupdateInput: function(key, newInput) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-data-input\",\n\t\t\tnewProp: newInput,\n\t\t\tkey: key\n\t\t});\n\t},\n\n\t/**\n\t* Update metadata\n\t* @param {object} newMetadata - The property's value\n\t*/\n\tupdateMetadata: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-metadata\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t});\n\t},\n\n\tupdateSession: function(k, v) {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"update-session\",\n\t\t\tkey: k,\n\t\t\tvalue: v\n\t\t})\n\t},\n\n\tstartTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"start-timer\"\n\t\t});\n\t},\n\n\tstopTimer: function() {\n\t\tDispatcher.handleViewAction({\n\t\t\teventName: \"stop-timer\"\n\t\t});\n\t},\n}",
            "path": "src/js/actions/ChartViewActions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/actions/ChartViewActions.js#L64-L70"
          },
          "params": [
            {
              "title": "param",
              "description": "The property's value",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "newMetadata"
            }
          ],
          "name": "updateMetadata",
          "kind": "function",
          "memberof": "ChartViewActions",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "ChartViewActions",
            "updateMetadata"
          ]
        }
      ]
    },
    "path": [
      "ChartViewActions"
    ]
  },
  {
    "description": "Global config not specific to a chart type",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "config"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 17,
          "column": 0
        },
        "end": {
          "line": 23,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/config/chart-style.js",
      "code": "var chart_style = {\n\tovertick_top: \"0.8em\",\n\tovertick_bottom: 10,\n\tnumColors: 11,\n\txOverTick: \"1em\", // horizontal the distance between the yAxes and xAxis\n\tcreditMargin: \"0.6em\"\n};\n\nmodule.exports = chart_style;",
      "path": "src/js/config/chart-style.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/config/chart-style.js#L17-L23"
    },
    "name": "config",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Configuration of breakpoints for Chartbuilder renderers.",
          "tags": [
            {
              "title": "property",
              "description": "Applied to the renderer at this break point",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "class_name"
            },
            {
              "title": "property",
              "description": "Minimum value (most likely width) at which to\napply this breakpoint",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "min_size"
            },
            {
              "title": "property",
              "description": "Font size at this breakpoint. This is used to\ncalculate relative positioning",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "em_size"
            },
            {
              "title": "memberof",
              "description": "config"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "name",
              "name": "breakpoints"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 11,
                "column": 0
              },
              "end": {
                "line": 27,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/config/chart-breakpoints.js",
            "code": "var breakpoints = [\n\t{\n\t\t\"class_name\": \"large\",\n\t\t\"min_size\": 900,\n\t\t\"em_size\": 20\n\t},\n\t{\n\t\t\"class_name\": \"medium\",\n\t\t\"min_size\": 480,\n\t\t\"em_size\": 20\n\t},\n\t{\n\t\t\"class_name\":\"small\",\n\t\t\"min_size\": 0,\n\t\t\"em_size\": 12\n\t}\n];\n\nbreakpoints.sort(function(a, b) {\n\treturn b.min_size - a.min_size;\n});\n\nmodule.exports = breakpoints;",
            "path": "src/js/config/chart-breakpoints.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/config/chart-breakpoints.js#L11-L27"
          },
          "properties": [
            {
              "title": "property",
              "description": "Applied to the renderer at this break point",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "class_name"
            },
            {
              "title": "property",
              "description": "Minimum value (most likely width) at which to\napply this breakpoint",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "min_size"
            },
            {
              "title": "property",
              "description": "Font size at this breakpoint. This is used to\ncalculate relative positioning",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "em_size"
            }
          ],
          "memberof": "config",
          "scope": "static",
          "name": "breakpoints",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "config",
            "breakpoints"
          ]
        },
        {
          "description": "Default dimensions for non-responsive chart sizes.",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "chart_sizes"
            },
            {
              "title": "memberof",
              "description": "config"
            },
            {
              "title": "static",
              "description": null
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 7,
                "column": 0
              },
              "end": {
                "line": 20,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/config/chart-sizes.js",
            "code": "var chart_sizes = {\n\tmedium: {\n\t\twidth: 640,\n\t\theight: 390\n\t},\n\tspotLong: {\n\t\twidth: 320,\n\t\theight: 390\n\t},\n\tspotSmall: {\n\t\twidth: 320,\n\t\theight: 250\n\t}\n};\n\nmodule.exports = chart_sizes;",
            "path": "src/js/config/chart-sizes.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/config/chart-sizes.js#L7-L20"
          },
          "name": "chart_sizes",
          "memberof": "config",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "config",
            "chart_sizes"
          ]
        },
        {
          "description": "Global style config that is not specific to any one chart type",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "chart_style"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "overtick_top"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "overtick_bottom"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numColors"
            },
            {
              "title": "property",
              "description": "Font size at this breakpoint. This is used to",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "xOvertick"
            },
            {
              "title": "property",
              "description": "Distance btwn credit and the logo/text beside it",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "creditMargin"
            },
            {
              "title": "memberof",
              "description": "config"
            },
            {
              "title": "static",
              "description": null
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 17,
                "column": 0
              },
              "end": {
                "line": 23,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/config/chart-style.js",
            "code": "var chart_style = {\n\tovertick_top: \"0.8em\",\n\tovertick_bottom: 10,\n\tnumColors: 11,\n\txOverTick: \"1em\", // horizontal the distance between the yAxes and xAxis\n\tcreditMargin: \"0.6em\"\n};\n\nmodule.exports = chart_style;",
            "path": "src/js/config/chart-style.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/config/chart-style.js#L17-L23"
          },
          "name": "chart_style",
          "properties": [
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "overtick_top"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "overtick_bottom"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numColors"
            },
            {
              "title": "property",
              "description": "Font size at this breakpoint. This is used to",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "xOvertick"
            },
            {
              "title": "property",
              "description": "Distance btwn credit and the logo/text beside it",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "creditMargin"
            }
          ],
          "memberof": "config",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "config",
            "chart_style"
          ]
        },
        {
          "description": "Tabular data that is loaded in when Chartbuilder loads initially",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "default_input"
            },
            {
              "title": "memberof",
              "description": "config"
            },
            {
              "title": "static",
              "description": null
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 7,
                "column": 0
              },
              "end": {
                "line": 154,
                "column": 13
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/config/default-input.js",
            "code": "var default_input = [\n\t\"date\tJuice\tTravel\",\n\t\"2000-01-01\t106.3\t49.843099\",\n\t\"2000-02-01\t106.0\t49.931931\",\n\t\"2000-03-01\t105.4\t61.478163\",\n\t\"2000-04-01\t101.8\t58.981617\",\n\t\"2000-05-01\t95.9\t61.223861\",\n\t\"2000-06-01\t94.1\t65.601574\",\n\t\"2000-07-01\t102.0\t67.89832\",\n\t\"2000-08-01\t98.5\t67.028338\",\n\t\"2000-09-01\t105.1\t56.441629\",\n\t\"2000-10-01\t99.0\t58.83421\",\n\t\"2000-11-01\t97.7\t56.283261\",\n\t\"2000-12-01\t88.2\t55.38028\",\n\t\"2001-01-01\t89.1\t53.129922\",\n\t\"2001-02-01\t87.8\t49.992995\",\n\t\"2001-03-01\t89.1\t62.323049\",\n\t\"2001-04-01\t97.5\t59.801567\",\n\t\"2001-05-01\t97.7\t60.246478\",\n\t\"2001-06-01\t97.7\t64.987598\",\n\t\"2001-07-01\t104.8\t68.57341\",\n\t\"2001-08-01\t103.8\t69.003617\",\n\t\"2001-09-01\t99.4\t39.106905\",\n\t\"2001-10-01\t105.3\t44.271037\",\n\t\"2001-11-01\t103.8\t45.245063\",\n\t\"2001-12-01\t104.2\t48.167518\",\n\t\"2002-01-01\t98.9\t46.587854\",\n\t\"2002-02-01\t91.6\t45.157584\",\n\t\"2002-03-01\t91.4\t57.423396\",\n\t\"2002-04-01\t90.2\t53.013179\",\n\t\"2002-05-01\t103.7\t55.66357\",\n\t\"2002-06-01\t99.1\t60.22415\",\n\t\"2002-07-01\t96.1\t63.8285\",\n\t\"2002-08-01\t102.0\t63.657944\",\n\t\"2002-09-01\t102.9\t49.270915\",\n\t\"2002-10-01\t101.9\t54.019748\",\n\t\"2002-11-01\t98.9\t50.106815\",\n\t\"2002-12-01\t97.3\t56.656595\",\n\t\"2003-01-01\t90.8\t51.197174\",\n\t\"2003-02-01\t89.6\t47.040806\",\n\t\"2003-03-01\t82.8\t56.76658\",\n\t\"2003-04-01\t88.6\t51.857453\",\n\t\"2003-05-01\t93.9\t54.335598\",\n\t\"2003-06-01\t98.9\t60.2729\",\n\t\"2003-07-01\t94.5\t65.962215\",\n\t\"2003-08-01\t93.6\t64.989766\",\n\t\"2003-09-01\t95.0\t52.12148\",\n\t\"2003-10-01\t94.9\t56.724551\",\n\t\"2003-11-01\t92.8\t54.128776\",\n\t\"2003-12-01\t93.0\t58.739845\",\n\t\"2004-01-01\t90.6\t53.979787\",\n\t\"2004-02-01\t92.0\t53.179693\",\n\t\"2004-03-01\t91.8\t64.035864\",\n\t\"2004-04-01\t95.7\t62.340117\",\n\t\"2004-05-01\t97.6\t62.530704\",\n\t\"2004-06-01\t105.9\t68.866397\",\n\t\"2004-07-01\t102.6\t73.335889\",\n\t\"2004-08-01\t102.6\t70.961522\",\n\t\"2004-09-01\t102.0\t57.881041\",\n\t\"2004-10-01\t110.1\t63.021143\",\n\t\"2004-11-01\t116.2\t59.453942\",\n\t\"2004-12-01\t108.3\t62.68031\",\n\t\"2005-01-01\t102.3\t59.629608\",\n\t\"2005-02-01\t98.5\t55.795165\",\n\t\"2005-03-01\t91.8\t70.595861\",\n\t\"2005-04-01\t92.9\t65.145551\",\n\t\"2005-05-01\t95.4\t68.268899\",\n\t\"2005-06-01\t96.3\t72.952959\",\n\t\"2005-07-01\t95.6\t77.432998\",\n\t\"2005-08-01\t94.5\t73.778918\",\n\t\"2005-09-01\t94.1\t62.046798\",\n\t\"2005-10-01\t94.9\t63.640895\",\n\t\"2005-11-01\t95.1\t61.518984\",\n\t\"2005-12-01\t95.1\t64.28934\",\n\t\"2006-01-01\t93.5\t61.035027\",\n\t\"2006-02-01\t93.2\t56.729212\",\n\t\"2006-03-01\t94.8\t70.799794\",\n\t\"2006-04-01\t99.6\t68.120559\",\n\t\"2006-05-01\t97.3\t69.352606\",\n\t\"2006-06-01\t100.9\t74.099238\",\n\t\"2006-07-01\t109.0\t77.798621\",\n\t\"2006-08-01\t111.2\t74.227051\",\n\t\"2006-09-01\t115.9\t62.345744\",\n\t\"2006-10-01\t110.6\t66.082164\",\n\t\"2006-11-01\t105.9\t63.548732\",\n\t\"2006-12-01\t110.9\t65.980782\",\n\t\"2007-01-01\t110.3\t63.016014\",\n\t\"2007-02-01\t114.0\t57.793832\",\n\t\"2007-03-01\t115.0\t72.700241\",\n\t\"2007-04-01\t128.3\t69.836157\",\n\t\"2007-05-01\t123.4\t71.933108\",\n\t\"2007-06-01\t127.3\t76.926452\",\n\t\"2007-07-01\t127.0\t80.98834\",\n\t\"2007-08-01\t130.5\t79.439827\",\n\t\"2007-09-01\t132.5\t65.913314\",\n\t\"2007-10-01\t131.8\t69.445349\",\n\t\"2007-11-01\t130.7\t66.250428\",\n\t\"2007-12-01\t126.1\t67.782533\",\n\t\"2008-01-01\t130.2\t64.667105\",\n\t\"2008-02-01\t130.9\t61.504425\",\n\t\"2008-03-01\t130.9\t74.575531\",\n\t\"2008-04-01\t134.4\t68.906882\",\n\t\"2008-05-01\t135.5\t72.72575\",\n\t\"2008-06-01\t140.1\t76.162104\",\n\t\"2008-07-01\t137.6\t79.707545\",\n\t\"2008-08-01\t143.3\t77.300568\",\n\t\"2008-09-01\t135.5\t61.198749\",\n\t\"2008-10-01\t124.5\t65.018204\",\n\t\"2008-11-01\t120.7\t58.512623\",\n\t\"2008-12-01\t124.9\t63.503416\",\n\t\"2009-01-01\t120.9\t58.373786\",\n\t\"2009-02-01\t119.3\t53.50658\",\n\t\"2009-03-01\t118.9\t66.027342\",\n\t\"2009-04-01\t116.7\t65.166301\",\n\t\"2009-05-01\t114.5\t65.868255\",\n\t\"2009-06-01\t115.2\t71.350228\",\n\t\"2009-07-01\t114.8\t77.136799\",\n\t\"2009-08-01\t119.4\t74.614772\",\n\t\"2009-09-01\t123.7\t61.435354\",\n\t\"2009-10-01\t124.3\t64.27474\",\n\t\"2009-11-01\t120.6\t59.011015\",\n\t\"2009-12-01\t122.3\t63.231672\",\n\t\"2010-01-01\t128.2\t59.651062\",\n\t\"2010-02-01\t127.3\t53.240066\",\n\t\"2010-03-01\t125.4\t68.30709\",\n\t\"2010-04-01\t133.9\t64.953251\",\n\t\"2010-05-01\t131.9\t68.850905\",\n\t\"2010-06-01\t132.2\t74.474551\",\n\t\"2010-07-01\t128.9\t79.304441\",\n\t\"2010-08-01\t126.5\t76.741308\",\n\t\"2010-09-01\t124.0\t65.341293\",\n\t\"2010-10-01\t128.5\t69.071626\",\n\t\"2010-11-01\t132.1\t63.334293\",\n\t\"2010-12-01\t131.5\t65.797943\",\n\t\"2011-01-01\t133.9\t61.630362\",\n\t\"2011-02-01\t131.4\t55.391206\",\n\t\"2011-03-01\t131.8\t70.158268\",\n\t\"2011-04-01\t131.8\t67.683559\",\n\t\"2011-05-01\t129.9\t71.711448\",\n\t\"2011-06-01\t127.9\t76.05791\",\n\t\"2011-07-01\t127.3\t81.423231\",\n\t\"2011-08-01\t131.7\t77.247896\",\n\t\"2011-09-01\t122.9\t66.345318\",\n\t\"2011-10-01\t123.9\t68.177919\",\n\t\"2011-11-01\t127.3\t63.492941\",\n\t\"2011-12-01\t135.7\t66.595644\",\n\t\"2012-01-01\t130.5\t61.940192\"\n].join(\"\\n\");\n\nmodule.exports = default_input;",
            "path": "src/js/config/default-input.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/config/default-input.js#L7-L154"
          },
          "name": "default_input",
          "memberof": "config",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "config",
            "default_input"
          ]
        }
      ]
    },
    "path": [
      "config"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "editors"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 6,
          "column": 0
        },
        "end": {
          "line": 16,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/editors.js",
      "code": "module.exports = {\n\txy: {\n\t\tEditor: require(\"../components/chart-xy/XYEditor.jsx\"),\n\t\tMobileOverrides: require(\"../components/chart-xy/XYMobile.jsx\")\n\t},\n\n\tchartgrid: {\n\t\tEditor: require(\"../components/chart-grid/ChartGridEditor.jsx\"),\n\t\tMobileOverrides: require(\"../components/chart-grid/ChartGridMobile.jsx\")\n\t}\n};",
      "path": "src/js/charts/editors.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/editors.js#L6-L16"
    },
    "name": "editors",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [
        {
          "description": "### Functions common to chart editors",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ChartEditorMixin"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 12,
                "column": 0
              },
              "end": {
                "line": 46,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartEditorMixin.js",
            "code": "var React = require(\"react\");\nvar update = React.addons.update;\n\n// Flux actions\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\n/**\n * ### Functions common to chart editors\n * @instance\n * @memberof editors\n */\nvar ChartEditorMixin = {\n\n\t/**\n\t * _handlePropUpdate\n\t * Initiate a flux action that updates a prop, that doesn't require reparsing\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropUpdate: function(k, v) {\n\t\tChartViewActions.updateChartProp(k, v);\n\t},\n\n\t/**\n\t * _handlePropAndReparse\n\t * Initiate a flux action that updates a prop and then triggers a reparse\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropAndReparse: function(k, v) {\n\t\tChartViewActions.updateAndReparse(k, v);\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the editor component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t},\n\n};\n\nmodule.exports = ChartEditorMixin;",
            "path": "src/js/components/mixins/ChartEditorMixin.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartEditorMixin.js#L12-L46"
          },
          "scope": "instance",
          "memberof": "editors",
          "name": "ChartEditorMixin",
          "kind": "function",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "_handlePropAndReparse\nInitiate a flux action that updates a prop and then triggers a reparse",
                "tags": [
                  {
                    "title": "param",
                    "description": "`chartProp` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`chartProp` value",
                    "type": null,
                    "name": "v"
                  },
                  {
                    "title": "name",
                    "name": "_handlePropAndReparse"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "ChartEditorMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 30,
                      "column": 1
                    },
                    "end": {
                      "line": 32,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartEditorMixin.js",
                  "code": "{\n\n\t/**\n\t * _handlePropUpdate\n\t * Initiate a flux action that updates a prop, that doesn't require reparsing\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropUpdate: function(k, v) {\n\t\tChartViewActions.updateChartProp(k, v);\n\t},\n\n\t/**\n\t * _handlePropAndReparse\n\t * Initiate a flux action that updates a prop and then triggers a reparse\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropAndReparse: function(k, v) {\n\t\tChartViewActions.updateAndReparse(k, v);\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the editor component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t},\n\n}",
                  "path": "src/js/components/mixins/ChartEditorMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartEditorMixin.js#L30-L32"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "`chartProp` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`chartProp` value",
                    "type": null,
                    "name": "v"
                  }
                ],
                "name": "_handlePropAndReparse",
                "kind": "function",
                "memberof": "ChartEditorMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartEditorMixin",
                  "_handlePropAndReparse"
                ]
              },
              {
                "description": "_handlePropUpdate\nInitiate a flux action that updates a prop, that doesn't require reparsing",
                "tags": [
                  {
                    "title": "param",
                    "description": "`chartProp` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`chartProp` value",
                    "type": null,
                    "name": "v"
                  },
                  {
                    "title": "name",
                    "name": "_handlePropUpdate"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "ChartEditorMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 20,
                      "column": 1
                    },
                    "end": {
                      "line": 22,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartEditorMixin.js",
                  "code": "{\n\n\t/**\n\t * _handlePropUpdate\n\t * Initiate a flux action that updates a prop, that doesn't require reparsing\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropUpdate: function(k, v) {\n\t\tChartViewActions.updateChartProp(k, v);\n\t},\n\n\t/**\n\t * _handlePropAndReparse\n\t * Initiate a flux action that updates a prop and then triggers a reparse\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropAndReparse: function(k, v) {\n\t\tChartViewActions.updateAndReparse(k, v);\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the editor component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t},\n\n}",
                  "path": "src/js/components/mixins/ChartEditorMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartEditorMixin.js#L20-L22"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "`chartProp` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`chartProp` value",
                    "type": null,
                    "name": "v"
                  }
                ],
                "name": "_handlePropUpdate",
                "kind": "function",
                "memberof": "ChartEditorMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartEditorMixin",
                  "_handlePropUpdate"
                ]
              },
              {
                "description": "_handleStateUpdate\nUpdate a key in the editor component's state",
                "tags": [
                  {
                    "title": "param",
                    "description": "`this.state` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`this.state` value",
                    "type": null,
                    "name": "v"
                  },
                  {
                    "title": "name",
                    "name": "_handleStateUpdate"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "ChartEditorMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 40,
                      "column": 1
                    },
                    "end": {
                      "line": 44,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartEditorMixin.js",
                  "code": "{\n\n\t/**\n\t * _handlePropUpdate\n\t * Initiate a flux action that updates a prop, that doesn't require reparsing\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropUpdate: function(k, v) {\n\t\tChartViewActions.updateChartProp(k, v);\n\t},\n\n\t/**\n\t * _handlePropAndReparse\n\t * Initiate a flux action that updates a prop and then triggers a reparse\n\t * @param k - `chartProp` key\n\t * @param v - `chartProp` value\n\t */\n\t_handlePropAndReparse: function(k, v) {\n\t\tChartViewActions.updateAndReparse(k, v);\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the editor component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t},\n\n}",
                  "path": "src/js/components/mixins/ChartEditorMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartEditorMixin.js#L40-L44"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "`this.state` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`this.state` value",
                    "type": null,
                    "name": "v"
                  }
                ],
                "name": "_handleStateUpdate",
                "kind": "function",
                "memberof": "ChartEditorMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartEditorMixin",
                  "_handleStateUpdate"
                ]
              }
            ]
          },
          "path": [
            "editors",
            "ChartEditorMixin"
          ]
        },
        {
          "description": "### Buttons that allow the user to export a chart to an image or Svg.",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ChartExport"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 23,
                "column": 0
              },
              "end": {
                "line": 308,
                "column": 0
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/ChartExport.jsx",
            "code": "var React = require('react');\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\nvar PropTypes = React.PropTypes;\nvar d3 = require(\"d3\");\n\nvar Button = require(\"chartbuilder-ui\").Button;\nvar saveSvgAsPng = require(\"save-svg-as-png\");\n\nfunction outerHTML(el) {\n\tvar outer = document.createElement(\"div\");\n\touter.appendChild(el);\n\treturn outer.innerHTML;\n}\n\n/**\n * ### Buttons that allow the user to export a chart to an image or Svg.\n * @instance\n * @memberof editors\n */\nvar ChartExport = React.createClass({displayName: \"ChartExport\",\n\n\tpropTypes: {\n\t\tstepNumber: PropTypes.string,\n\t\tsvgWrapperClassName: PropTypes.string.isRequired,\n\t\tsendBase64String: PropTypes.func\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tenableSvgExport: true\n\t\t};\n\t},\n\n\tcreateSVGFile: function(chart) {\n\t\t// Returns a valid svg string representing the chart that can be opened in graphics software\n\n\t\t// retrieve the current size\n\t\tvar size = chart.getBoundingClientRect();\n\t\tvar scale_factor = 2;\n\n\t\tchart = this._addIDsForIllustrator(chart);\n\n\t\t// get a useable SVG string using SVG Crowbar\n\t\tvar svg_content = this.createSVGContent(chart);\n\n\t\t// set the width of the svg in pixels for output\n\t\tvar svg_string = svg_content.source[0]\n\t\t\t.split('width=\"100%\"').join('width=\"'+size.width*scale_factor+'\"')\n\t\t\t.split('height=\"100%\"').join('height=\"'+size.height*scale_factor+'\"');\n\n\t\treturn \"data:text/svg,\" + svg_string;\n\t},\n\n\tembedCSS: function(type) {\n\t\tif (type == \"add\") {\n\t\t\td3.selectAll(\".\" + this.props.svgWrapperClassName)\n\t\t\t\t.append(\"style\")\n\t\t\t\t.attr(\"type\",\"text/css\")\n\t\t\t\t.html(\"\\n<![CDATA[\"+this.styleStringify(document.styleSheets)+\"]]>\\n\");\n\t\t}\n\t\telse {\n\t\t\td3.selectAll(\".\" + this.props.svgWrapperClassName + \" style\").remove();\n\t\t}\n\t},\n\n\tcomponentDidMount: function() {\n\t\tvar enableSvgExport;\n\t\tvar chartNode = null;\n\n\t\t// SVG output won't work on most non-Chrome browsers, so we try it first. If\n\t\t// `createSVGFile()` doesnt work we will disable svg download but still allow png.\n\t\t// TODO: figure out what exactly is breaking FF\n\t\tvar chart = document\n\t\t\t.getElementsByClassName(this.props.svgWrapperClassName)[0]\n\t\t\t.getElementsByClassName(\"renderer-svg\")[0];\n\n\t\ttry {\n\t\t\tvar svgHref = this.createSVGFile(chart);\n\t\t\tenableSvgExport = true;\n\t\t\tchartNode = chart;\n\t\t} catch (e) {\n\t\t\tenableSvgExport = false;\n\t\t}\n\n\t\tthis.setState({\n\t\t\tchartNode: chart,\n\t\t\tenableSvgExport: enableSvgExport\n\t\t});\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar chart = document\n\t\t\t.getElementsByClassName(this.props.svgWrapperClassName)[0]\n\t\t\t.getElementsByClassName(\"renderer-svg\")[0];\n\n\t\tthis.setState({ chartNode: chart });\n\t},\n\n\tstyleStringify: function(styleSheets) {\n\t\tvar sheet, style_strings = [], rules, rule;\n\n\t\tfor (var i = styleSheets.length - 1; i >= 0; i--) {\n\t\t\tsheet = styleSheets[i];\n\t\t\tif (sheet) {\n\t\t\t\tif (sheet.rules !== undefined) {\n\t\t\t\t\trules = sheet.rules;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trules = sheet.cssRules;\n\t\t\t\t}\n\n\t\t\t\tfor (var j = rules.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (rules[j].style) {\n\t\t\t\t\t\trule = this._cleanRulesForIllustrator(rules[j]);\n\t\t\t\t\t\tstyle_strings.unshift(rule.cssText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn style_strings.join(\"\\n\");\n\t},\n\n\t_cleanRulesForIllustrator: function(rule) {\n\t\t// Adobe Illustrator freaks out with certain style declarations this strips those out\n\t\tvar styleDec = rule.style;\n\t\tvar pd;\n\t\tfor (var i = styleDec.length - 1; i >= 0; i--) {\n\t\t\torig_prop = styleDec[i];\n\t\t\torig_dec = styleDec[orig_prop];\n\n\t\t\tpd = {\n\t\t\t\tprop: orig_prop,\n\t\t\t\tdec: orig_dec\n\t\t\t};\n\n\t\t\tpd = this._cleanRuleOfExtraFonts(pd);\n\n\t\t\trule.style[pd.prop] = pd.dec;\n\n\t\t\trule.cssText = rule.cssText.split(orig_prop + \":\" + orig_dec + \";\")\n\t\t\t\t\t\t\t\t\t\t.join(pd.prop + \":\" + pd.dec + \";\");\n\t\t}\n\n\t\treturn rule;\n\t},\n\n\t_addIDsForIllustrator: function(node) {\n\t\tvar chart = d3.select(node);\n\t\tvar classAttr = \"\";\n\n\t\tchart\n\t\t\t.attr(\"id\",\"chartbuilder-export\")\n\t\t\t.selectAll(\"g\")\n\t\t\t.attr(\"id\",function(d,i){\n\t\t\t\ttry {\n\t\t\t\t\tclassAttr = this.getAttribute(\"class\").split(\" \");\n\t\t\t\t\treturn classAttr.join(\"::\") + (classAttr == \"tick\" ? \"::\" + this.textContent : \"\");\n\t\t\t\t}\n\t\t\t\tcatch(e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn chart[0][0];\n\t},\n\n\t_cleanRuleOfExtraFonts: function(pd) {\n\t\t// Adobe Illustrator freaks out with fallback fonts, remove fallback fonts\n\t\tif(pd.prop == \"font-family\") {\n\t\t\tpd.dec = pd.dec.split(\",\")[0];\n\t\t}\n\n\t\treturn {\"prop\":pd.prop,\"dec\":pd.dec};\n\t},\n\n\tcreateSVGContent: function(svg) {\n\t\t/*\n\t\t\tCopyright (c) 2013 The New York Times\n\n\t\t\tPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\t\t\tThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\t\t\tSOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\t*/\n\n\t\t//via https://github.com/NYTimes/svg-crowbar\n\n\t\tvar prefix = {\n\t\t\txmlns: \"http://www.w3.org/2000/xmlns/\",\n\t\t\txlink: \"http://www.w3.org/1999/xlink\",\n\t\t\tsvg: \"http://www.w3.org/2000/svg\"\n\t\t};\n\n\t\tvar doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">';\n\n\t\tsvg.setAttribute(\"version\", \"1.1\");\n\n\t\tvar defsEl = document.createElement(\"defs\");\n\t\tsvg.insertBefore(defsEl, svg.firstChild); //TODO   .insert(\"defs\", \":first-child\")\n\n\t\tvar styleEl = document.createElement(\"style\");\n\t\tdefsEl.appendChild(styleEl);\n\t\tstyleEl.setAttribute(\"type\", \"text/css\");\n\n\t\t// removing attributes so they aren't doubled up\n\t\tsvg.removeAttribute(\"xmlns\");\n\t\tsvg.removeAttribute(\"xlink\");\n\n\t\t// These are needed for the svg\n\t\tif (!svg.hasAttributeNS(prefix.xmlns, \"xmlns\")) {\n\t\t\tsvg.setAttributeNS(prefix.xmlns, \"xmlns\", prefix.svg);\n\t\t}\n\n\t\tif (!svg.hasAttributeNS(prefix.xmlns, \"xmlns:xlink\")) {\n\t\t\tsvg.setAttributeNS(prefix.xmlns, \"xmlns:xlink\", prefix.xlink);\n\t\t}\n\n\t\t//TODO atually get the styles\n\t\tvar styles = \"\";\n\n\t\tvar source = (new XMLSerializer()).serializeToString(svg).replace('</style>', '<![CDATA[' + this.styleStringify(document.styleSheets) + ']]></style>');\n\n\t\treturn {svg: svg, source: [doctype + source]};\n\t},\n\n\t_makeFilename: function(extension) {\n\t\tvar filename = this.props.data.reduce(function(a, b, i) {\n\t\t\tif (a.length === 0) {\n\t\t\t\treturn b.name;\n\t\t\t} else {\n\t\t\t\treturn [a, b.name].join(\"_\");\n\t\t\t}\n\t\t}, this.props.metadata.title);\n\t\treturn [\n\t\t\t(filename + \"_chartbuilder\").replace(/\\s/g, \"_\"),\n\t\t\textension\n\t\t].join(\".\");\n\t},\n\n\tcreateSVGOutput: function(callback) {\n\t\t// updates the download links with the data-uris and download file names\n\t\tvar filename = this._makeFilename(\"svg\");\n\t\t//clone the svg so that the image creation and svg creation don't conflict\n\t\treturn {\n\t\t\tdownload: filename,\n\t\t\thref: this.createSVGFile(this.state.chartNode)\n\t\t};\n\t},\n\n\tdownloadPNG: function() {\n\t\tfilename = this._makeFilename(\"png\");\n\t\tsaveSvgAsPng.saveSvgAsPng(this.state.chartNode, filename, { scale: 2.0 });\n\t},\n\n\tdownloadSVG: function() {\n\t\tvar output = this.createSVGOutput();\n\t\tvar a = document.createElement('a');\n\t\ta.download = output.download;\n\t\ta.href = output.href;\n\t\tdocument.body.appendChild(a);\n\t\ta.addEventListener(\"click\", function(e) {\n\t\t\ta.parentNode.removeChild(a);\n\t\t});\n\t\ta.click();\n\t},\n\n\tsetAdvancedOptionState: function() {\n\t\tthis.setState({\n\t\t\tshowAdvancedOptions: !this.state.showAdvancedOptions\n\t\t});\n\t},\n\n\trender: function() {\n\t\tvar self = this;\n\n\t\tvar chartExportButtons = [\n\t\t\tReact.createElement(Button, {\n\t\t\t\tclassName: \"export-button\", \n\t\t\t\tonClick: this.downloadPNG, \n\t\t\t\ttext: \"Download Image\"}\n\t\t\t)\n\t\t];\n\t\tif (this.state.enableSvgExport) {\n\t\t\tchartExportButtons.push(\n\t\t\t\tReact.createElement(Button, {\n\t\t\t\t\tclassName: \"export-button\", \n\t\t\t\t\tonClick: this.downloadSVG, \n\t\t\t\t\ttext: \"Download SVG\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\tReact.createElement(\"h2\", null, React.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), React.createElement(\"span\", null, \"Export your chart\")), \n\t\t\t\t\tReact.createElement(\"div\", {className: \"export-button-wrapper\"}, \n\t\t\t\t\t\tchartExportButtons\n\t\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n})\n\nmodule.exports = ChartExport;",
            "path": "src/js/components/ChartExport.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/ChartExport.jsx#L23-L308"
          },
          "scope": "instance",
          "memberof": "editors",
          "name": "ChartExport",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "ChartExport"
          ]
        },
        {
          "description": "### Editor interface for a Chart grid",
          "tags": [
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numSteps"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ChartGridEditor"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 38,
                "column": 0
              },
              "end": {
                "line": 171,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridEditor.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar each = require(\"lodash/collection/each\");\nvar range = require(\"lodash/utility/range\");\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\nvar ChartGrid_xScaleSettings = require(\"./ChartGrid_xScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar TextInput = chartbuilderUI.TextInput;\nvar help = require(\"../../util/helper.js\");\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/**\n * ### Editor interface for a Chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar ChartGridEditor = React.createClass({displayName: \"ChartGridEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.shape({\n\t\t\t\tprimaryScale: PropTypes.object.isRequired\n\t\t\t}).isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ ChartEditorMixin ],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 3\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\t/* Toggle whether chart settings should apply to all data series */\n\t\t\tuniversalSettings: false\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar chartSettings;\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tchartSettings = map(chartProps.chartSettings, function(seriesSetting, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(ChartGrid_chartSettings, {\n\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\tindex: i, \n\t\t\t\t\tname: chartProps.data[i].name, \n\t\t\t\t\tkey: i}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\t/*\n\t\t * Settings to control the numerical scale. It will be different for bar\n\t\t * than for XY\n\t\t* */\n\t\tvar scaleSettings = [];\n\t\tif (chartProps._grid.type == \"bar\") {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(ChartGrid_xScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tstepNumber: \"4\"}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tid: \"primaryScale\", \n\t\t\t\t\tname: \"Primary\", \n\t\t\t\t\tstepNumber: \"4\", \n\t\t\t\t\tkey: \"primaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartgrid-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\t\tchartSettings, \n\t\t\t\t\tReact.createElement(ChartGrid_universalToggle, {\n\t\t\t\t\t\ttext: \"Single color\", \n\t\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\t\tonClick: this._handleStateUpdate}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartGrid_gridSettings, {\n\t\t\t\t\t\tgrid: chartProps._grid, \n\t\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"_grid\"), \n\t\t\t\t\t\tnumSeries: chartProps.data.length}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Button to toggle universal setting that applies series settings to all series\n * @property {string} text - Text of universal toggle button\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {function} onClick - Callback on toggle button click\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_universalToggle = React.createClass({displayName: \"ChartGrid_universalToggle\",\n\n\tpropTypes: {\n\t\ttext: PropTypes.string,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tonClick: PropTypes.func.isRequired\n\t},\n\n\t_handleUniversal: function(k, v) {\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\tif (v === true) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tsetting.colorIndex = chartSettings[0].colorIndex;\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO: set settings back to distinct defaults when toggling back\n\t\t}\n\t\tthis.props.onClick(k, v);\n\t\tthis.props.onUpdate(chartSettings);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\tclassName: this.props.universalSettings ? 'universal-toggle' : 'universal-toggle disabled', \n\t\t\t\tactive: this.props.universalSettings, \n\t\t\t\tonClick: this._handleUniversal.bind(null, \"universalSettings\", !this.props.universalSettings)}\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Series-specific settings drawn for each column in data\n * @property {string} name - Series (column) name\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_chartSettings = React.createClass({displayName: \"ChartGrid_chartSettings\",\n\n\tpropTypes: {\n\t\tname: PropTypes.string.isRequired,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tnumColors: PropTypes.number.isRequired\n\t},\n\n\t_getNewSettings: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* Apply a setting to every series if universal is checked */\n\t\tif (this.props.universalSettings) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tchartSettings[i][k] = v;\n\t\t\t})\n\t\t} else {\n\t\t\t/* Otherwise we need the index (ix) of the settings object\n\t\t\t* to know which to update */\n\t\t\tchartSettings[ix][k] = v;\n\t\t}\n\t\treturn chartSettings;\n\t},\n\n\t_handleColorUpdate: function(ix, k, v) {\n\t\tthis.props.onUpdate(this._getNewSettings(ix, k, v));\n\t},\n\n\t_handleSettingsReparse: function(ix, k, v) {\n\t\tthis.props.onUpdateReparse(this._getNewSettings(ix, k, v));\n\t},\n\n\trender: function() {\n\t\tvar seriesSetting = this.props.chartSettings[this.props.index];\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\tonChange: this._handleColorUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\tcolorIndex: seriesSetting.colorIndex}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: seriesSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsReparse.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + seriesSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Settings that control the grid layout and type\n * @property {object} grid - Set grid type and number of rows and columns\n * @property {number} numSeries - Number of columns, used to decide how many\n * rows/columns are possible\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_gridSettings = React.createClass({displayName: \"ChartGrid_gridSettings\",\n\n\tpropTypes: {\n\t\tgrid: PropTypes.shape({\n\t\t\tcols: PropTypes.number.isRequired,\n\t\t\trows: PropTypes.number.isRequired,\n\t\t\ttype: PropTypes.string.isRequired\n\t\t}).isRequired,\n\t\tnumSeries: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\trowColOptions: [\n\t\t\t\t{ value: 1 },\n\t\t\t\t{ value: 2 },\n\t\t\t\t{ value: 3 },\n\t\t\t\t{ value: 4 }\n\t\t\t]\n\t\t};\n\t},\n\n\t_config: {\n\t\tgridTypes: [\n\t\t\t{ title: \"Bars\", content: \"Bars\", value: \"bar\" },\n\t\t\t{ title: \"Lines\", content: \"Lines\", value: \"line\" },\n\t\t\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" },\n\t\t\t{ title: \"Columns\", content: \"Columns\", value: \"column\" }\n\t\t],\n\t},\n\n\t/* Create a button for every possible number of rows/cols */\n\t_buildSeriesValues: function(numSeries) {\n\t\treturn map(range(0, numSeries), function(series, i) {\n\t\t\treturn { value: i + 1 };\n\t\t});\n\t},\n\n\tcomponentWillMount: function() {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(this.props.numSeries)\n\t\t});\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(nextProps.numSeries)\n\t\t});\n\t},\n\n\t_handleGridUpdate: function(k, v) {\n\t\tvar gridSetting = {};\n\t\tgridSetting[k] = v;\n\t\tvar grid = update(this.props.grid, { $merge: gridSetting });\n\t\tthis.props.onUpdate(grid);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"grid-options\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Chart type\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"type\"), \n\t\t\t\t\t\tbuttons: this._config.gridTypes, \n\t\t\t\t\t\tvalue: this.props.grid.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Rows\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"rows\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.rows}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Columns\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tid: \"cols\", \n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"cols\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.cols}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartGridEditor;",
            "path": "src/js/components/chart-grid/ChartGridEditor.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridEditor.jsx#L38-L171"
          },
          "properties": [
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numSteps"
            }
          ],
          "scope": "instance",
          "memberof": "editors",
          "name": "ChartGridEditor",
          "kind": "function",
          "members": {
            "instance": [
              {
                "description": "Series-specific settings drawn for each column in data",
                "tags": [
                  {
                    "title": "property",
                    "description": "Series (column) name",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "name"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Whether `universalSettings` is currently enabled",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "universalSettings"
                  },
                  {
                    "title": "property",
                    "description": "Total number of possible colors",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numColors"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridEditor"
                  },
                  {
                    "title": "name",
                    "name": "ChartGrid_chartSettings"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 225,
                      "column": 0
                    },
                    "end": {
                      "line": 280,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridEditor.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar each = require(\"lodash/collection/each\");\nvar range = require(\"lodash/utility/range\");\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\nvar ChartGrid_xScaleSettings = require(\"./ChartGrid_xScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar TextInput = chartbuilderUI.TextInput;\nvar help = require(\"../../util/helper.js\");\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/**\n * ### Editor interface for a Chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar ChartGridEditor = React.createClass({displayName: \"ChartGridEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.shape({\n\t\t\t\tprimaryScale: PropTypes.object.isRequired\n\t\t\t}).isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ ChartEditorMixin ],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 3\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\t/* Toggle whether chart settings should apply to all data series */\n\t\t\tuniversalSettings: false\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar chartSettings;\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tchartSettings = map(chartProps.chartSettings, function(seriesSetting, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(ChartGrid_chartSettings, {\n\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\tindex: i, \n\t\t\t\t\tname: chartProps.data[i].name, \n\t\t\t\t\tkey: i}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\t/*\n\t\t * Settings to control the numerical scale. It will be different for bar\n\t\t * than for XY\n\t\t* */\n\t\tvar scaleSettings = [];\n\t\tif (chartProps._grid.type == \"bar\") {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(ChartGrid_xScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tstepNumber: \"4\"}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tid: \"primaryScale\", \n\t\t\t\t\tname: \"Primary\", \n\t\t\t\t\tstepNumber: \"4\", \n\t\t\t\t\tkey: \"primaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartgrid-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\t\tchartSettings, \n\t\t\t\t\tReact.createElement(ChartGrid_universalToggle, {\n\t\t\t\t\t\ttext: \"Single color\", \n\t\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\t\tonClick: this._handleStateUpdate}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartGrid_gridSettings, {\n\t\t\t\t\t\tgrid: chartProps._grid, \n\t\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"_grid\"), \n\t\t\t\t\t\tnumSeries: chartProps.data.length}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Button to toggle universal setting that applies series settings to all series\n * @property {string} text - Text of universal toggle button\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {function} onClick - Callback on toggle button click\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_universalToggle = React.createClass({displayName: \"ChartGrid_universalToggle\",\n\n\tpropTypes: {\n\t\ttext: PropTypes.string,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tonClick: PropTypes.func.isRequired\n\t},\n\n\t_handleUniversal: function(k, v) {\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\tif (v === true) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tsetting.colorIndex = chartSettings[0].colorIndex;\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO: set settings back to distinct defaults when toggling back\n\t\t}\n\t\tthis.props.onClick(k, v);\n\t\tthis.props.onUpdate(chartSettings);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\tclassName: this.props.universalSettings ? 'universal-toggle' : 'universal-toggle disabled', \n\t\t\t\tactive: this.props.universalSettings, \n\t\t\t\tonClick: this._handleUniversal.bind(null, \"universalSettings\", !this.props.universalSettings)}\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Series-specific settings drawn for each column in data\n * @property {string} name - Series (column) name\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_chartSettings = React.createClass({displayName: \"ChartGrid_chartSettings\",\n\n\tpropTypes: {\n\t\tname: PropTypes.string.isRequired,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tnumColors: PropTypes.number.isRequired\n\t},\n\n\t_getNewSettings: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* Apply a setting to every series if universal is checked */\n\t\tif (this.props.universalSettings) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tchartSettings[i][k] = v;\n\t\t\t})\n\t\t} else {\n\t\t\t/* Otherwise we need the index (ix) of the settings object\n\t\t\t* to know which to update */\n\t\t\tchartSettings[ix][k] = v;\n\t\t}\n\t\treturn chartSettings;\n\t},\n\n\t_handleColorUpdate: function(ix, k, v) {\n\t\tthis.props.onUpdate(this._getNewSettings(ix, k, v));\n\t},\n\n\t_handleSettingsReparse: function(ix, k, v) {\n\t\tthis.props.onUpdateReparse(this._getNewSettings(ix, k, v));\n\t},\n\n\trender: function() {\n\t\tvar seriesSetting = this.props.chartSettings[this.props.index];\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\tonChange: this._handleColorUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\tcolorIndex: seriesSetting.colorIndex}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: seriesSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsReparse.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + seriesSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Settings that control the grid layout and type\n * @property {object} grid - Set grid type and number of rows and columns\n * @property {number} numSeries - Number of columns, used to decide how many\n * rows/columns are possible\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_gridSettings = React.createClass({displayName: \"ChartGrid_gridSettings\",\n\n\tpropTypes: {\n\t\tgrid: PropTypes.shape({\n\t\t\tcols: PropTypes.number.isRequired,\n\t\t\trows: PropTypes.number.isRequired,\n\t\t\ttype: PropTypes.string.isRequired\n\t\t}).isRequired,\n\t\tnumSeries: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\trowColOptions: [\n\t\t\t\t{ value: 1 },\n\t\t\t\t{ value: 2 },\n\t\t\t\t{ value: 3 },\n\t\t\t\t{ value: 4 }\n\t\t\t]\n\t\t};\n\t},\n\n\t_config: {\n\t\tgridTypes: [\n\t\t\t{ title: \"Bars\", content: \"Bars\", value: \"bar\" },\n\t\t\t{ title: \"Lines\", content: \"Lines\", value: \"line\" },\n\t\t\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" },\n\t\t\t{ title: \"Columns\", content: \"Columns\", value: \"column\" }\n\t\t],\n\t},\n\n\t/* Create a button for every possible number of rows/cols */\n\t_buildSeriesValues: function(numSeries) {\n\t\treturn map(range(0, numSeries), function(series, i) {\n\t\t\treturn { value: i + 1 };\n\t\t});\n\t},\n\n\tcomponentWillMount: function() {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(this.props.numSeries)\n\t\t});\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(nextProps.numSeries)\n\t\t});\n\t},\n\n\t_handleGridUpdate: function(k, v) {\n\t\tvar gridSetting = {};\n\t\tgridSetting[k] = v;\n\t\tvar grid = update(this.props.grid, { $merge: gridSetting });\n\t\tthis.props.onUpdate(grid);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"grid-options\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Chart type\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"type\"), \n\t\t\t\t\t\tbuttons: this._config.gridTypes, \n\t\t\t\t\t\tvalue: this.props.grid.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Rows\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"rows\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.rows}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Columns\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tid: \"cols\", \n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"cols\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.cols}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartGridEditor;",
                  "path": "src/js/components/chart-grid/ChartGridEditor.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridEditor.jsx#L225-L280"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Series (column) name",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "name"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Whether `universalSettings` is currently enabled",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "universalSettings"
                  },
                  {
                    "title": "property",
                    "description": "Total number of possible colors",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numColors"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridEditor",
                "name": "ChartGrid_chartSettings",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartGridEditor",
                  "ChartGrid_chartSettings"
                ]
              },
              {
                "description": "Settings that control the grid layout and type",
                "tags": [
                  {
                    "title": "property",
                    "description": "Set grid type and number of rows and columns",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "grid"
                  },
                  {
                    "title": "property",
                    "description": "Number of columns, used to decide how many\nrows/columns are possible",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numSeries"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridEditor"
                  },
                  {
                    "title": "name",
                    "name": "ChartGrid_gridSettings"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 290,
                      "column": 0
                    },
                    "end": {
                      "line": 379,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridEditor.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar each = require(\"lodash/collection/each\");\nvar range = require(\"lodash/utility/range\");\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\nvar ChartGrid_xScaleSettings = require(\"./ChartGrid_xScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar TextInput = chartbuilderUI.TextInput;\nvar help = require(\"../../util/helper.js\");\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/**\n * ### Editor interface for a Chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar ChartGridEditor = React.createClass({displayName: \"ChartGridEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.shape({\n\t\t\t\tprimaryScale: PropTypes.object.isRequired\n\t\t\t}).isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ ChartEditorMixin ],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 3\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\t/* Toggle whether chart settings should apply to all data series */\n\t\t\tuniversalSettings: false\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar chartSettings;\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tchartSettings = map(chartProps.chartSettings, function(seriesSetting, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(ChartGrid_chartSettings, {\n\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\tindex: i, \n\t\t\t\t\tname: chartProps.data[i].name, \n\t\t\t\t\tkey: i}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\t/*\n\t\t * Settings to control the numerical scale. It will be different for bar\n\t\t * than for XY\n\t\t* */\n\t\tvar scaleSettings = [];\n\t\tif (chartProps._grid.type == \"bar\") {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(ChartGrid_xScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tstepNumber: \"4\"}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tid: \"primaryScale\", \n\t\t\t\t\tname: \"Primary\", \n\t\t\t\t\tstepNumber: \"4\", \n\t\t\t\t\tkey: \"primaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartgrid-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\t\tchartSettings, \n\t\t\t\t\tReact.createElement(ChartGrid_universalToggle, {\n\t\t\t\t\t\ttext: \"Single color\", \n\t\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\t\tonClick: this._handleStateUpdate}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartGrid_gridSettings, {\n\t\t\t\t\t\tgrid: chartProps._grid, \n\t\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"_grid\"), \n\t\t\t\t\t\tnumSeries: chartProps.data.length}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Button to toggle universal setting that applies series settings to all series\n * @property {string} text - Text of universal toggle button\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {function} onClick - Callback on toggle button click\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_universalToggle = React.createClass({displayName: \"ChartGrid_universalToggle\",\n\n\tpropTypes: {\n\t\ttext: PropTypes.string,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tonClick: PropTypes.func.isRequired\n\t},\n\n\t_handleUniversal: function(k, v) {\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\tif (v === true) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tsetting.colorIndex = chartSettings[0].colorIndex;\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO: set settings back to distinct defaults when toggling back\n\t\t}\n\t\tthis.props.onClick(k, v);\n\t\tthis.props.onUpdate(chartSettings);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\tclassName: this.props.universalSettings ? 'universal-toggle' : 'universal-toggle disabled', \n\t\t\t\tactive: this.props.universalSettings, \n\t\t\t\tonClick: this._handleUniversal.bind(null, \"universalSettings\", !this.props.universalSettings)}\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Series-specific settings drawn for each column in data\n * @property {string} name - Series (column) name\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_chartSettings = React.createClass({displayName: \"ChartGrid_chartSettings\",\n\n\tpropTypes: {\n\t\tname: PropTypes.string.isRequired,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tnumColors: PropTypes.number.isRequired\n\t},\n\n\t_getNewSettings: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* Apply a setting to every series if universal is checked */\n\t\tif (this.props.universalSettings) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tchartSettings[i][k] = v;\n\t\t\t})\n\t\t} else {\n\t\t\t/* Otherwise we need the index (ix) of the settings object\n\t\t\t* to know which to update */\n\t\t\tchartSettings[ix][k] = v;\n\t\t}\n\t\treturn chartSettings;\n\t},\n\n\t_handleColorUpdate: function(ix, k, v) {\n\t\tthis.props.onUpdate(this._getNewSettings(ix, k, v));\n\t},\n\n\t_handleSettingsReparse: function(ix, k, v) {\n\t\tthis.props.onUpdateReparse(this._getNewSettings(ix, k, v));\n\t},\n\n\trender: function() {\n\t\tvar seriesSetting = this.props.chartSettings[this.props.index];\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\tonChange: this._handleColorUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\tcolorIndex: seriesSetting.colorIndex}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: seriesSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsReparse.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + seriesSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Settings that control the grid layout and type\n * @property {object} grid - Set grid type and number of rows and columns\n * @property {number} numSeries - Number of columns, used to decide how many\n * rows/columns are possible\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_gridSettings = React.createClass({displayName: \"ChartGrid_gridSettings\",\n\n\tpropTypes: {\n\t\tgrid: PropTypes.shape({\n\t\t\tcols: PropTypes.number.isRequired,\n\t\t\trows: PropTypes.number.isRequired,\n\t\t\ttype: PropTypes.string.isRequired\n\t\t}).isRequired,\n\t\tnumSeries: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\trowColOptions: [\n\t\t\t\t{ value: 1 },\n\t\t\t\t{ value: 2 },\n\t\t\t\t{ value: 3 },\n\t\t\t\t{ value: 4 }\n\t\t\t]\n\t\t};\n\t},\n\n\t_config: {\n\t\tgridTypes: [\n\t\t\t{ title: \"Bars\", content: \"Bars\", value: \"bar\" },\n\t\t\t{ title: \"Lines\", content: \"Lines\", value: \"line\" },\n\t\t\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" },\n\t\t\t{ title: \"Columns\", content: \"Columns\", value: \"column\" }\n\t\t],\n\t},\n\n\t/* Create a button for every possible number of rows/cols */\n\t_buildSeriesValues: function(numSeries) {\n\t\treturn map(range(0, numSeries), function(series, i) {\n\t\t\treturn { value: i + 1 };\n\t\t});\n\t},\n\n\tcomponentWillMount: function() {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(this.props.numSeries)\n\t\t});\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(nextProps.numSeries)\n\t\t});\n\t},\n\n\t_handleGridUpdate: function(k, v) {\n\t\tvar gridSetting = {};\n\t\tgridSetting[k] = v;\n\t\tvar grid = update(this.props.grid, { $merge: gridSetting });\n\t\tthis.props.onUpdate(grid);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"grid-options\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Chart type\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"type\"), \n\t\t\t\t\t\tbuttons: this._config.gridTypes, \n\t\t\t\t\t\tvalue: this.props.grid.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Rows\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"rows\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.rows}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Columns\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tid: \"cols\", \n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"cols\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.cols}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartGridEditor;",
                  "path": "src/js/components/chart-grid/ChartGridEditor.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridEditor.jsx#L290-L379"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Set grid type and number of rows and columns",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "grid"
                  },
                  {
                    "title": "property",
                    "description": "Number of columns, used to decide how many\nrows/columns are possible",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numSeries"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridEditor",
                "name": "ChartGrid_gridSettings",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartGridEditor",
                  "ChartGrid_gridSettings"
                ]
              },
              {
                "description": "Button to toggle universal setting that applies series settings to all series",
                "tags": [
                  {
                    "title": "property",
                    "description": "Text of universal toggle button",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "text"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Whether `universalSettings` is currently enabled",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "universalSettings"
                  },
                  {
                    "title": "property",
                    "description": "Callback on toggle button click",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onClick"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridEditor"
                  },
                  {
                    "title": "name",
                    "name": "ChartGrid_universalToggle"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 182,
                      "column": 0
                    },
                    "end": {
                      "line": 214,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridEditor.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar each = require(\"lodash/collection/each\");\nvar range = require(\"lodash/utility/range\");\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\nvar ChartGrid_xScaleSettings = require(\"./ChartGrid_xScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar TextInput = chartbuilderUI.TextInput;\nvar help = require(\"../../util/helper.js\");\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/**\n * ### Editor interface for a Chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar ChartGridEditor = React.createClass({displayName: \"ChartGridEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.shape({\n\t\t\t\tprimaryScale: PropTypes.object.isRequired\n\t\t\t}).isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ ChartEditorMixin ],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 3\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\t/* Toggle whether chart settings should apply to all data series */\n\t\t\tuniversalSettings: false\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar chartSettings;\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tchartSettings = map(chartProps.chartSettings, function(seriesSetting, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(ChartGrid_chartSettings, {\n\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\tindex: i, \n\t\t\t\t\tname: chartProps.data[i].name, \n\t\t\t\t\tkey: i}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\t/*\n\t\t * Settings to control the numerical scale. It will be different for bar\n\t\t * than for XY\n\t\t* */\n\t\tvar scaleSettings = [];\n\t\tif (chartProps._grid.type == \"bar\") {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(ChartGrid_xScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tstepNumber: \"4\"}\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tid: \"primaryScale\", \n\t\t\t\t\tname: \"Primary\", \n\t\t\t\t\tstepNumber: \"4\", \n\t\t\t\t\tkey: \"primaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"chartgrid-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\t\tchartSettings, \n\t\t\t\t\tReact.createElement(ChartGrid_universalToggle, {\n\t\t\t\t\t\ttext: \"Single color\", \n\t\t\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\t\t\tuniversalSettings: this.state.universalSettings, \n\t\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\t\t\tonClick: this._handleStateUpdate}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ChartGrid_gridSettings, {\n\t\t\t\t\t\tgrid: chartProps._grid, \n\t\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"_grid\"), \n\t\t\t\t\t\tnumSeries: chartProps.data.length}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Button to toggle universal setting that applies series settings to all series\n * @property {string} text - Text of universal toggle button\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {function} onClick - Callback on toggle button click\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_universalToggle = React.createClass({displayName: \"ChartGrid_universalToggle\",\n\n\tpropTypes: {\n\t\ttext: PropTypes.string,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tonClick: PropTypes.func.isRequired\n\t},\n\n\t_handleUniversal: function(k, v) {\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\tif (v === true) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tsetting.colorIndex = chartSettings[0].colorIndex;\n\t\t\t})\n\t\t} else {\n\t\t\t// TODO: set settings back to distinct defaults when toggling back\n\t\t}\n\t\tthis.props.onClick(k, v);\n\t\tthis.props.onUpdate(chartSettings);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\tclassName: this.props.universalSettings ? 'universal-toggle' : 'universal-toggle disabled', \n\t\t\t\tactive: this.props.universalSettings, \n\t\t\t\tonClick: this._handleUniversal.bind(null, \"universalSettings\", !this.props.universalSettings)}\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Series-specific settings drawn for each column in data\n * @property {string} name - Series (column) name\n * @property {object[]} chartSettings - Current settings for data series\n * @property {boolean} universalSettings - Whether `universalSettings` is currently enabled\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_chartSettings = React.createClass({displayName: \"ChartGrid_chartSettings\",\n\n\tpropTypes: {\n\t\tname: PropTypes.string.isRequired,\n\t\tchartSettings: PropTypes.array.isRequired,\n\t\tuniversalSettings: PropTypes.bool.isRequired,\n\t\tnumColors: PropTypes.number.isRequired\n\t},\n\n\t_getNewSettings: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* Apply a setting to every series if universal is checked */\n\t\tif (this.props.universalSettings) {\n\t\t\teach(chartSettings, function(setting, i) {\n\t\t\t\tchartSettings[i][k] = v;\n\t\t\t})\n\t\t} else {\n\t\t\t/* Otherwise we need the index (ix) of the settings object\n\t\t\t* to know which to update */\n\t\t\tchartSettings[ix][k] = v;\n\t\t}\n\t\treturn chartSettings;\n\t},\n\n\t_handleColorUpdate: function(ix, k, v) {\n\t\tthis.props.onUpdate(this._getNewSettings(ix, k, v));\n\t},\n\n\t_handleSettingsReparse: function(ix, k, v) {\n\t\tthis.props.onUpdateReparse(this._getNewSettings(ix, k, v));\n\t},\n\n\trender: function() {\n\t\tvar seriesSetting = this.props.chartSettings[this.props.index];\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\tonChange: this._handleColorUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\tcolorIndex: seriesSetting.colorIndex}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: seriesSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsReparse.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + seriesSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * Settings that control the grid layout and type\n * @property {object} grid - Set grid type and number of rows and columns\n * @property {number} numSeries - Number of columns, used to decide how many\n * rows/columns are possible\n * @instance\n * @memberof ChartGridEditor\n */\nvar ChartGrid_gridSettings = React.createClass({displayName: \"ChartGrid_gridSettings\",\n\n\tpropTypes: {\n\t\tgrid: PropTypes.shape({\n\t\t\tcols: PropTypes.number.isRequired,\n\t\t\trows: PropTypes.number.isRequired,\n\t\t\ttype: PropTypes.string.isRequired\n\t\t}).isRequired,\n\t\tnumSeries: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\trowColOptions: [\n\t\t\t\t{ value: 1 },\n\t\t\t\t{ value: 2 },\n\t\t\t\t{ value: 3 },\n\t\t\t\t{ value: 4 }\n\t\t\t]\n\t\t};\n\t},\n\n\t_config: {\n\t\tgridTypes: [\n\t\t\t{ title: \"Bars\", content: \"Bars\", value: \"bar\" },\n\t\t\t{ title: \"Lines\", content: \"Lines\", value: \"line\" },\n\t\t\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" },\n\t\t\t{ title: \"Columns\", content: \"Columns\", value: \"column\" }\n\t\t],\n\t},\n\n\t/* Create a button for every possible number of rows/cols */\n\t_buildSeriesValues: function(numSeries) {\n\t\treturn map(range(0, numSeries), function(series, i) {\n\t\t\treturn { value: i + 1 };\n\t\t});\n\t},\n\n\tcomponentWillMount: function() {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(this.props.numSeries)\n\t\t});\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tthis.setState({\n\t\t\trowColOptions: this._buildSeriesValues(nextProps.numSeries)\n\t\t});\n\t},\n\n\t_handleGridUpdate: function(k, v) {\n\t\tvar gridSetting = {};\n\t\tgridSetting[k] = v;\n\t\tvar grid = update(this.props.grid, { $merge: gridSetting });\n\t\tthis.props.onUpdate(grid);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"grid-options\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Chart type\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"type\"), \n\t\t\t\t\t\tbuttons: this._config.gridTypes, \n\t\t\t\t\t\tvalue: this.props.grid.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Rows\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"rows\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.rows}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-option\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label\"}, \"Columns\"), \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tid: \"cols\", \n\t\t\t\t\t\tonClick: this._handleGridUpdate.bind(null, \"cols\"), \n\t\t\t\t\t\tbuttons: this.state.rowColOptions, \n\t\t\t\t\t\tvalue: this.props.grid.cols}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartGridEditor;",
                  "path": "src/js/components/chart-grid/ChartGridEditor.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridEditor.jsx#L182-L214"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Text of universal toggle button",
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "text"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Whether `universalSettings` is currently enabled",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "universalSettings"
                  },
                  {
                    "title": "property",
                    "description": "Callback on toggle button click",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onClick"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridEditor",
                "name": "ChartGrid_universalToggle",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "ChartGridEditor",
                  "ChartGrid_universalToggle"
                ]
              }
            ],
            "static": []
          },
          "path": [
            "editors",
            "ChartGridEditor"
          ]
        },
        {
          "description": "Edit a chart's metadata",
          "tags": [
            {
              "title": "property",
              "description": "Current metadata",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "metadata"
            },
            {
              "title": "property",
              "description": "Step in the editing process",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "stepNumber"
            },
            {
              "title": "property",
              "description": "Additional React components.\nAnything passed here will be given a callback that updates the `metadata`\nfield. This is useful for adding custom input fields not provided.",
              "type": {
                "type": "ArrayType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "components"
                  }
                ]
              },
              "name": "additionalComponents"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ChartMetadata"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 58,
                "column": 0
              },
              "end": {
                "line": 119,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/ChartMetadata.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar PureRenderMixin = React.addons.PureRenderMixin;\nvar clone = require(\"lodash/lang/clone\");\n\n// Flux stores\nvar ChartMetadataStore = require(\"../stores/ChartMetadataStore\");\nvar ChartViewActions = require(\"../actions/ChartViewActions\");\n\n// Chartbuilder UI components\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar TextInput = chartbuilderUI.TextInput;\n\n// Give chart sizes friendly names\nvar chart_sizes = [\n\t{\n\t\ttitle: \"Auto\",\n\t\tcontent: \"Auto\",\n\t\tvalue: \"auto\"\n\t},\n\t{\n\t\ttitle: \"Medium\",\n\t\tcontent: \"Medium\",\n\t\tvalue: \"medium\"\n\t},\n\t{\n\t\ttitle: \"Long spot chart\",\n\t\tcontent: \"Long spot chart\",\n\t\tvalue: \"spotLong\"\n\t},\n\t{\n\t\ttitle: \"Small spot chart\",\n\t\tcontent: \"Small spot chart\",\n\t\tvalue: \"spotSmall\"\n\t}\n];\n\nvar text_input_values = [\n\t{ name: \"title\", content: \"Title\" },\n\t{ name: \"credit\", content: \"Credit\" },\n\t{ name: \"source\", content: \"Source\" }\n];\n\n/**\n * Edit a chart's metadata\n * @property {object} metadata - Current metadata\n * @property {string} stepNumber - Step in the editing process\n * @property {[components]} additionalComponents - Additional React components.\n * Anything passed here will be given a callback that updates the `metadata`\n * field. This is useful for adding custom input fields not provided.\n * @instance\n * @memberof editors\n */\nvar ChartMetadata = React.createClass({displayName: \"ChartMetadata\",\n\n\tpropTypes: {\n\t\tmetadata: PropTypes.shape({\n\t\t\tchartType: PropTypes.string.isRequired,\n\t\t\tsize: PropTypes.string.isRequired,\n\t\t\tsource: PropTypes.string,\n\t\t\tcredit: PropTypes.string,\n\t\t\ttitle: PropTypes.string\n\t\t}),\n\t\tstepNumber: PropTypes.string,\n\t\tadditionalComponents: PropTypes.array\n\t},\n\n\t// Get text input types from state\n\tgetInitialState: function() {\n\t\treturn {\n\t\t};\n\t},\n\n\t// Update metadata store with new settings\n\t_handleMetadataUpdate: function(k, v) {\n\t\tChartViewActions.updateMetadata(k, v);\n\t},\n\n\trender: function() {\n\t\tvar metadata = this.props.metadata;\n\n\t\tif (this.props.additionalComponents.length > 0) {\n\t\t\tthis.props.additionalComponents.forEach(function(c, i) {\n\t\t\t\tc.props.onUpdate = this._handleMetadataUpdate;\n\t\t\t\tc.props.value = metadata[c.key] || \"\";\n\t\t\t}, this);\n\t\t}\n\t\t// Create text input field for each metadata textInput\n\t\tvar textInputs = text_input_values.map(function(textInput) {\n\t\t\treturn React.createElement(ChartMetadataText, {\n\t\t\t\tkey: textInput.name, \n\t\t\t\tname: textInput.name, \n\t\t\t\tvalue: metadata[textInput.name], \n\t\t\t\tplaceholder: textInput.content, \n\t\t\t\tonChange: this._handleMetadataUpdate}\n\t\t\t)\n\t\t}, this);\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\t\tReact.createElement(\"span\", null, \"Set title, source, credit and size\")\n\t\t\t\t), \n\t\t\t\ttextInputs, \n\t\t\t\tthis.props.additionalComponents, \n\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\tbuttons: chart_sizes, \n\t\t\t\t\tonClick: this._handleMetadataUpdate.bind(null, \"size\"), \n\t\t\t\t\tvalue: metadata.size}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\n// Small wrapper arount TextInput component specific to metadata\nvar ChartMetadataText = React.createClass({displayName: \"ChartMetadataText\",\n\n\tmixins: [ PureRenderMixin ],\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"div\", null, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tvalue: this.props.value, \n\t\t\t\t\tclassName: \"meta-option\", \n\t\t\t\t\tonChange: this.props.onChange.bind(null, this.props.name), \n\t\t\t\t\tplaceholder: this.props.placeholder}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = ChartMetadata;",
            "path": "src/js/components/ChartMetadata.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/ChartMetadata.jsx#L58-L119"
          },
          "properties": [
            {
              "title": "property",
              "description": "Current metadata",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "metadata"
            },
            {
              "title": "property",
              "description": "Step in the editing process",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "stepNumber"
            },
            {
              "title": "property",
              "description": "Additional React components.\nAnything passed here will be given a callback that updates the `metadata`\nfield. This is useful for adding custom input fields not provided.",
              "type": {
                "type": "ArrayType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "components"
                  }
                ]
              },
              "name": "additionalComponents"
            }
          ],
          "scope": "instance",
          "memberof": "editors",
          "name": "ChartMetadata",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "ChartMetadata"
          ]
        },
        {
          "description": "Select a new chart type, copying shared settings over to the new type.",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ChartTypeSelctor"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 25,
                "column": 0
              },
              "end": {
                "line": 94,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/ChartTypeSelector.jsx",
            "code": "var React = require(\"react\");\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar keys = require(\"lodash/object/keys\");\nvar helper = require(\"../util/helper\");\n\n// Flux actions\nvar ChartServerActions = require(\"../actions/ChartServerActions\");\n\n// Chartbuilder UI components\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\n\nvar chartConfig = require(\"../charts/chart-config\");\n\n/**\n * Select a new chart type, copying shared settings over to the new type.\n * @instance\n * @memberof editors\n */\nvar ChartTypeSelctor = React.createClass({displayName: \"ChartTypeSelctor\",\n\n\t/* Generate values for each chart type that can be used to create buttons */\n\tgetInitialState: function() {\n\t\tvar chartTypeButtons = map(keys(chartConfig), function(chartTypeKey) {\n\t\t\treturn {\n\t\t\t\ttitle: chartConfig[chartTypeKey].displayName,\n\t\t\t\tcontent: chartConfig[chartTypeKey].displayName,\n\t\t\t\tvalue: chartTypeKey\n\t\t\t};\n\t\t});\n\t\treturn { chartConfig: chartTypeButtons };\n\t},\n\n\t/*\n\t * Change the chart type\n\t * @param {string} chartType - the new chart type\n\t*/\n\t_handleChartTypeChange: function(chartType) {\n\t\t/* Dont rerender if the chart type is the same */\n\t\tif (chartType === this.props.metadata.chartType) {\n\t\t\treturn;\n\t\t}\n\t\tvar metadata = clone(this.props.metadata);\n\t\t/* Set the new chart type in metadata */\n\t\tmetadata.chartType = chartType;\n\n\t\tvar prevProps = this.props.chartProps;\n\t\tvar newDefaultProps = chartConfig[chartType].defaultProps.chartProps;\n\t\tvar prevSettings = prevProps.chartSettings;\n\t\tvar newDefaultSettings = newDefaultProps.chartSettings[0];\n\t\tvar prevKeys = keys(prevSettings[0]);\n\n\t\t/* Apply any settings that carry over, otherwise ignore them */\n\t\tvar newProps = helper.mergeOrApply(newDefaultProps, prevProps);\n\n\t\t/*\n\t\t * For each data series, check whether a `chartSetting` has already been\n\t\t * defined by another chart type. If so, apply it. If not, use the new\n\t\t * type's default\n\t\t*/\n\t\tnewProps.chartSettings = map(prevProps.data, function(d, i) {\n\t\t\treturn helper.mergeOrApply(newDefaultSettings, prevSettings[i]);\n\t\t});\n\n\t\t/* Dispatch the new model to the flux stores */\n\t\tChartServerActions.receiveModel({\n\t\t\tchartProps: newProps,\n\t\t\tmetadata: metadata\n\t\t});\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"1\"), \n\t\t\t\tReact.createElement(\"span\", null, \"Select chart type\")\n\t\t\t), \n\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\tbuttons: this.state.chartConfig, \n\t\t\t\tonClick: this._handleChartTypeChange, \n\t\t\t\tclassName: \"chart-type-select\", \n\t\t\t\tvalue: this.props.metadata.chartType}\n\t\t\t)\n\t\t )\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartTypeSelctor;",
            "path": "src/js/components/ChartTypeSelector.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/ChartTypeSelector.jsx#L25-L94"
          },
          "scope": "instance",
          "memberof": "editors",
          "name": "ChartTypeSelctor",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "ChartTypeSelctor"
          ]
        },
        {
          "description": "### Text area component and error messaging for data input",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "DataInput"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 55,
                "column": 0
              },
              "end": {
                "line": 111,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/shared/DataInput.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\n// Flux actions\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar TextArea = chartbuilderUI.TextArea;\nvar Alert = chartbuilderUI.Alert;\n\nvar inputAlerts = {\n\t\"EMPTY\": {\n\t\talertText: \"Enter some data above.\",\n\t\tboldText: \"Hello!\",\n\t\talertType: \"default\"\n\t},\n\t\"UNEVEN_SERIES\": {\n\t\talertText: \"At least one of your rows does not have the same number of columns as the rest.\",\n\t\tboldText: \"Error:\",\n\t\talertType: \"error\"\n\t},\n\t\"column_zero\": {\n\t\talertText: \"You have a column chart that doesn't have a zero axis. Double check that this is ok.\",\n\t\tboldText: \"Warning:\",\n\t\talertType: \"warning\"\n\t},\n\t\"TOO_MANY_SERIES\": {\n\t\talertText: \"You have more than 12 columns, which is more than Chartbuilder supports.\",\n\t\tboldText: \"Error:\",\n\t\talertType: \"error\"\n\t},\n\t\"NAN_VALUES\": {\n\t\talertText: \"At least one of your data points cannot be converted to a number\",\n\t\tboldText: \"Error:\",\n\t\talertType: \"error\"\n\t},\n\t\"NOT_DATES\": {\n\t\talertText: \"A least one of your dates cannot be understood by Chartbuilder\",\n\t\tboldText: \"Error:\",\n\t\talertType: \"error\"\n\t},\n\t\"VALID\": {\n\t\talertText: \"Your data are looking healthy\",\n\t\tboldText: \"\",\n\t\talertType: \"success\"\n\t}\n};\n\n/**\n * ### Text area component and error messaging for data input\n * @instance\n * @memberof editors\n */\nvar DataInput = React.createClass({displayName: \"DataInput\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.object\n\t\t}).isRequired,\n\t\tclassName: PropTypes.string\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\talertType: \"default\",\n\t\t\talertText: \"Waiting for data...\",\n\t\t\tboldText: \"\"\n\t\t};\n\t},\n\n\t_handleReparseUpdate: function(k, v) {\n\t\t// reset the raw input value\n\t\tvar input = update(this.props.chartProps.input, { $merge: { raw: v }});\n\t\tChartViewActions.updateInput(k, input);\n\t},\n\n\tcomponentDidMount: function() {\n\t\tthis.setState(inputAlerts[this.props.chartProps.input.status]);\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tthis.setState(inputAlerts[nextProps.chartProps.input.status]);\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: this.props.className}, \n\t\t\t\tReact.createElement(TextArea, {\n\t\t\t\t\tvalue: chartProps.input.raw, \n\t\t\t\t\tonChange: this._handleReparseUpdate.bind(null, \"input\"), \n\t\t\t\t\tclassName: \"data-input\", \n\t\t\t\t\tdefaultValue: chartProps.input.raw}\n\t\t\t\t), \n\t\t\t\tReact.createElement(Alert, {\n\t\t\t\t\talertType: this.state.alertType, \n\t\t\t\t\talertText: this.state.alertText, \n\t\t\t\t\tboldText: this.state.boldText}\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = DataInput;",
            "path": "src/js/components/shared/DataInput.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/shared/DataInput.jsx#L55-L111"
          },
          "scope": "instance",
          "memberof": "editors",
          "name": "DataInput",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "DataInput"
          ]
        },
        {
          "description": "### Date scale settings for a chart editor",
          "tags": [
            {
              "title": "property",
              "description": "Scale settings, which include date scale settings",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "scale"
            },
            {
              "title": "property",
              "description": "Callback to send selected date options back to parent",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "onUpdate"
            },
            {
              "title": "property",
              "description": "Step in the editing process",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "stepNumber"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "DateScaleSettings"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 24,
                "column": 0
              },
              "end": {
                "line": 127,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/shared/DateScaleSettings.jsx",
            "code": "var React = require(\"react\");\nvar clone = require(\"lodash/lang/clone\");\n\nvar shallowEqual = require(\"react/lib/shallowEqual\");\nvar PureRenderMixin = React.addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Dropdown = chartbuilderUI.Dropdown;\n\nvar dateParsers = require(\"../../util/process-dates\").dateParsers;\n\nvar now = new Date();\n\n/**\n * ### Date scale settings for a chart editor\n * @property {object} scale - Scale settings, which include date scale settings\n * @property {function} onUpdate - Callback to send selected date options back to parent\n * @property {string} stepNumber - Step in the editing process\n * @instance\n * @memberof editors\n */\nvar DateScaleSettings = React.createClass({displayName: \"DateScaleSettings\",\n\n\tpropTypes: {\n\t\tscale: PropTypes.object.isRequired,\n\t\tonUpdate: PropTypes.func,\n\t\tstepNumber: PropTypes.string\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar newStep = (this.props.stepNumber !== nextProps.stepNumber);\n\t\tif (newStep) {\n\t\t\treturn true;\n\t\t}\n\t\tvar newScale = !shallowEqual(this.props.scale.dateSettings, nextProps.scale.dateSettings);\n\t\tif (newScale) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_config: {\n\t\t// Use ids to look up appropriate date interval and number of steps\n\t\t// from `util/process-dates.js` on update\n\t\tdateFrequencyOptions: [\n\t\t\t{ value: \"auto\", content: \"auto\" },\n\t\t\t{ value: \"1h\", content: \"1 hour\" },\n\t\t\t{ value: \"2h\", content: \"2 hours\" },\n\t\t\t{ value: \"3h\", content: \"3 hours\" },\n\t\t\t{ value: \"4h\", content: \"4 hours\" },\n\t\t\t{ value: \"6h\", content: \"6 hours\" },\n\t\t\t{ value: \"1d\", content: \"1 day\" },\n\t\t\t{ value: \"1w\", content: \"1 week\" },\n\t\t\t{ value: \"1m\", content: \"1 month\" },\n\t\t\t{ value: \"3m\", content: \"3 months\" },\n\t\t\t{ value: \"6m\", content: \"6 months\" },\n\t\t\t{ value: \"1y\", content: \"1 year\" },\n\t\t\t{ value: \"2y\", content: \"2 years\" },\n\t\t\t{ value: \"5y\", content: \"5 years\" },\n\t\t\t{ value: \"10y\", content: \"10 years\" },\n\t\t\t{ value: \"20y\", content: \"20 years\" },\n\t\t\t{ value: \"50y\", content: \"50 years\" },\n\t\t\t{ value: \"100y\", content: \"100 years\" }\n\t\t],\n\n\t\t// Use ids to look up appropriate date formatter from `util/process-dates.js`\n\t\tdateFormatOptions: [\n\t\t\t{ value: \"auto\", content: \"auto\" },\n\t\t\t{ value: \"lmdy\", content: dateParsers[\"lmdy\"](now) },\n\t\t\t{ value: \"mmdd\", content: dateParsers[\"mmdd\"](now) },\n\t\t\t{ value: \"Mdd\", content: dateParsers[\"Mdd\"](now) },\n\t\t\t{ value: \"ddM\", content: dateParsers[\"ddM\"](now) },\n\t\t\t{ value: \"M1d\", content: dateParsers[\"M1d\"](now) + \" (months only on the 1st)\" },\n\t\t\t{ value: \"mmyy\", content: dateParsers[\"mmyy\"](now) },\n\t\t\t{ value: \"yy\", content: dateParsers[\"yy\"](now) },\n\t\t\t{ value: \"yyyy\", content: dateParsers[\"yyyy\"](now) },\n\t\t\t{ value: \"QJan\", content: \"Q2 (Jan. FY)\" },\n\t\t\t{ value: \"QJul\", content: \"Q2 (July FY)\"  },\n\t\t\t{ value: \"MM\", content: dateParsers[\"MM\"](now) },\n\t\t\t{ value: \"M\", content: dateParsers[\"M\"](now) },\n\t\t\t{ value: \"hmm\", content: dateParsers[\"hmm\"](now) },\n\t\t\t{ value: \"h\", content: dateParsers[\"h\"](now) }\n\t\t]\n\t},\n\n\t_handleDateScaleUpdate: function(k, v) {\n\t\t// update `scale.dateSettings`\n\t\tvar dateSettings = clone(this.props.scale.dateSettings);\n\t\tdateSettings[k] = v;\n\t\tvar scale = update(this.props.scale, { $merge: {\n\t\t\tdateSettings: dateSettings\n\t\t}});\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\trender: function() {\n\t\tvar dateSettings = this.props.scale.dateSettings;\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"scale-options scale-options-date\"}, \n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\t\t\"Set the frequency and formatting of the bottom axis\"\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"labelled-dropdown\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label date-setting\"}, \"Date frequency\"), \n\t\t\t\t\tReact.createElement(Dropdown, {\n\t\t\t\t\t\tonChange: this._handleDateScaleUpdate.bind(null, \"dateFrequency\"), \n\t\t\t\t\t\toptions: this._config.dateFrequencyOptions, \n\t\t\t\t\t\tvalue: dateSettings.dateFrequency}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"labelled-dropdown\"}, \n\t\t\t\t\tReact.createElement(\"label\", {className: \"editor-label date-setting\"}, \"Date format\"), \n\t\t\t\t\tReact.createElement(Dropdown, {\n\t\t\t\t\t\tonChange: this._handleDateScaleUpdate.bind(null, \"dateFormat\"), \n\t\t\t\t\t\toptions: this._config.dateFormatOptions, \n\t\t\t\t\t\tvalue: dateSettings.dateFormat}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t}\n\n});\n\nmodule.exports = DateScaleSettings;",
            "path": "src/js/components/shared/DateScaleSettings.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/shared/DateScaleSettings.jsx#L24-L127"
          },
          "properties": [
            {
              "title": "property",
              "description": "Scale settings, which include date scale settings",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "scale"
            },
            {
              "title": "property",
              "description": "Callback to send selected date options back to parent",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "onUpdate"
            },
            {
              "title": "property",
              "description": "Step in the editing process",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "stepNumber"
            }
          ],
          "scope": "instance",
          "memberof": "editors",
          "name": "DateScaleSettings",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "DateScaleSettings"
          ]
        },
        {
          "description": "### Button to delete a scale, resetting it to default settings",
          "tags": [
            {
              "title": "property",
              "description": "Current chart's scale object",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "scale"
            },
            {
              "title": "property",
              "description": "Identifier for the scale we want to delete",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "scaleId"
            },
            {
              "title": "property",
              "description": "Callback to send reset scale back to parent",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "onUpdate"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "ScaleReset"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 17,
                "column": 0
              },
              "end": {
                "line": 62,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/shared/ScaleReset.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar cx = React.addons.classSet;\nvar clone = require(\"lodash/lang/clone\");\n\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\n\n/**\n * ### Button to delete a scale, resetting it to default settings\n * @property {object} scale - Current chart's scale object\n * @property {string} scaleId - Identifier for the scale we want to delete\n * @property {function} onUpdate - Callback to send reset scale back to parent\n * @instance\n * @memberof editors\n */\nvar ScaleReset = React.createClass({displayName: \"ScaleReset\",\n\n\tpropTypes: {\n\t\tscale: PropTypes.object.isRequired,\n\t\tscaleId: PropTypes.string.isRequired,\n\t\tonUpdate: PropTypes.func.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tcustomScale: false\n\t\t};\n\t},\n\n\t// Delete scale width given `id` and update the parent\n\t_handleScaleReset: function() {\n\t\tvar scale = clone(this.props.scale, true);\n\t\tdelete scale[this.props.scaleId];\n\t\tthis.setState({ customScale: false });\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\t// Only enable button if the scale has been customized\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar scale = nextProps.scale[nextProps.scaleId];\n\t\tif (scale.custom) {\n\t\t\tthis.setState({ customScale: true });\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar className = cx({\n\t\t\t\"label-reset\": true,\n\t\t\t\"active\": this.state.customScale\n\t\t});\n\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\tonClick: this._handleScaleReset, \n\t\t\t\tclassName: className, \n\t\t\t\ttext: \"Reset scale\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ScaleReset;",
            "path": "src/js/components/shared/ScaleReset.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/shared/ScaleReset.jsx#L17-L62"
          },
          "properties": [
            {
              "title": "property",
              "description": "Current chart's scale object",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "scale"
            },
            {
              "title": "property",
              "description": "Identifier for the scale we want to delete",
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "scaleId"
            },
            {
              "title": "property",
              "description": "Callback to send reset scale back to parent",
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "onUpdate"
            }
          ],
          "scope": "instance",
          "memberof": "editors",
          "name": "ScaleReset",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "ScaleReset"
          ]
        },
        {
          "description": "Y scale settings for XY charts. Used in both XY and chart grid, and most\nlikely for future charts as well",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "XY_yScaleSettings"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 18,
                "column": 0
              },
              "end": {
                "line": 160,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/shared/XY_yScaleSettings.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar clone = require(\"lodash/lang/clone\");\n\nvar ScaleReset = require(\"./ScaleReset.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar LabelledTangle = chartbuilderUI.LabelledTangle;\nvar TextInput = chartbuilderUI.TextInput;\n\n/**\n * Y scale settings for XY charts. Used in both XY and chart grid, and most\n * likely for future charts as well\n * @instance\n * @memberof editors\n */\nvar XY_yScaleSettings = React.createClass({displayName: \"XY_yScaleSettings\",\n\n\tpropTypes: {\n\t\tclassName: PropTypes.string,\n\t\tid: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n\t\tname: PropTypes.string,\n\t\tonReset: PropTypes.func,\n\t\tonUpdate: PropTypes.func.isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tstepNumber: PropTypes.string,\n\t\ttitleOverride: PropTypes.string\n\t},\n\n\t_handleScaleUpdate: function(k, v) {\n\t\tvar scale = clone(this.props.scale, true);\n\n\t\tif(k != \"precision\") {\n\t\t\tscale[this.props.id].precision = 0;\n\t\t}\n\n\t\tscale[this.props.id][k] = v;\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\t_handleDomainUpdate: function(k, v) {\n\t\tvar scale = clone(this.props.scale, true);\n\t\tscale[this.props.id].custom = true;\n\t\tif (k == \"min\") {\n\t\t\tscale[this.props.id].domain[0] = v;\n\t\t} else if (k == \"max\") {\n\t\t\tscale[this.props.id].domain[1] = v;\n\t\t}\n\t\tthis.props.onUpdate(scale);\n\t},\n\n\trender: function() {\n\t\tvar currScale = this.props.scale[this.props.id];\n\n\t\t/*\n\t\t * Figure out the amount by which to increment the tangle (drag) values: Eg\n\t\t * <= 10 = 0.5\n\t\t * < 100 = 1\n\t\t * < 1000 = 10\n\t\t * < 10000 = 100\n\t\t * And so on\n\t  */\n\t\tvar tangleStep;\n\t\tvar range = Math.abs(currScale.domain[1] - currScale.domain[0]);\n\t\tif (range <= 10) {\n\t\t\ttangleStep = 0.5;\n\t\t} else {\n\t\t\tvar numDigits = range.toString().length;\n\t\t\ttangleStep = Math.pow(10, (numDigits - 2));\n\t\t}\n\n\t\tvar tickSetting;\n\t\tif (this.props.id === \"primaryScale\") {\n\t\t\ttickSetting = (\n\t\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\t\tlabel: \"Ticks\", \n\t\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"ticks\"), \n\t\t\t\t\tonInput: this._handleScaleUpdate.bind(null, \"ticks\"), \n\t\t\t\t\tmin: 2, \n\t\t\t\t\tmax: 8, \n\t\t\t\t\tvalue: currScale.ticks}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tvar title_block = (\n\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, this.props.stepNumber), \n\t\t\t\tthis.props.titleOverride ? this.props.titleOverride : \"Configure the \" + this.props.name + \" axis\"\n\t\t\t)\n\t\t\t)\n\n\t\tif(this.props.stepNumber == \"\") {\n\t\t\ttitle_block = (\n\t\t\t\tReact.createElement(\"h2\", {className: \"scale-option-title\"}, \n\t\t\t\t\tthis.props.titleOverride ? this.props.titleOverride : \"Configure the \" + this.props.name + \" axis\"\n\t\t\t\t)\n\t\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: this.props.className}, \n\t\t\t\ttitle_block, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"prefix\"), \n\t\t\t\t\tvalue: currScale.prefix, \n\t\t\t\t\tplaceholder: \"Prefix\"}\n\t\t\t\t), \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\tid: \"suffix\", \n\t\t\t\t\tclassName: \"scale-option\", \n\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"suffix\"), \n\t\t\t\t\tvalue: currScale.suffix, \n\t\t\t\t\tplaceholder: \"Suffix\"}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"scale-tangle-inputs\"}, \n\t\t\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\t\t\tlabel: \"Minimum\", \n\t\t\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\t\t\tstep: tangleStep, \n\t\t\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"min\"), \n\t\t\t\t\t\tvalue: currScale.domain[0]}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\t\t\tlabel: \"Maximum\", \n\t\t\t\t\t\tstep: tangleStep, \n\t\t\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\t\t\tonChange: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\t\t\tonInput: this._handleDomainUpdate.bind(null, \"max\"), \n\t\t\t\t\t\tvalue: currScale.domain[1]}\n\t\t\t\t\t), \n\t\t\t\t\ttickSetting, \n\t\t\t\t\tReact.createElement(LabelledTangle, {\n\t\t\t\t\t\tlabel: \"Precision\", \n\t\t\t\t\t\tlabelClass: \"editor-label\", \n\t\t\t\t\t\ttangleClass: \"scale-option tangle-input\", \n\t\t\t\t\t\tonChange: this._handleScaleUpdate.bind(null, \"precision\"), \n\t\t\t\t\t\tonInput: this._handleScaleUpdate.bind(null, \"precision\"), \n\t\t\t\t\t\tmin: 0, \n\t\t\t\t\t\tmax: 5, \n\t\t\t\t\t\tvalue: currScale.precision}\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(ScaleReset, {\n\t\t\t\t\t\tscale: this.props.scale, \n\t\t\t\t\t\tscaleId: this.props.id, \n\t\t\t\t\t\tonUpdate: this.props.onReset, \n\t\t\t\t\t\tclassName: \"scale-reset\"}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = XY_yScaleSettings;",
            "path": "src/js/components/shared/XY_yScaleSettings.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/shared/XY_yScaleSettings.jsx#L18-L160"
          },
          "scope": "instance",
          "memberof": "editors",
          "name": "XY_yScaleSettings",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "editors",
            "XY_yScaleSettings"
          ]
        },
        {
          "description": "### Editor interface for a XY chart",
          "tags": [
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numSteps"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "editors"
            },
            {
              "title": "name",
              "name": "XYEditor"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 54,
                "column": 0
              },
              "end": {
                "line": 174,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYEditor.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar PureRenderMixin = React.addons.PureRenderMixin;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar keys = require(\"lodash/object/keys\");\nvar each = require(\"lodash/collection/each\");\n\nvar dateParsers = require(\"../../util/process-dates\").dateParsers;\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar Dropdown = chartbuilderUI.Dropdown;\nvar LabelledTangle = chartbuilderUI.LabelledTangle;\nvar TextInput = chartbuilderUI.TextInput;\nvar Toggle = chartbuilderUI.Toggle;\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/* Available XY chart type options */\nvar typeOptions = [\n\t{ title: \"Line\", content: \"Line\", value: \"line\" },\n\t{ title: \"Columns\", content: \"Columns\", value: \"column\" },\n\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" }\n];\n\n/* Available XY axis options */\nvar axisOptions = [\n\t{ title: \"Left axis\", content: \"Left axis\", value: \"left\" },\n\t{ title: \"Right axis\", content: \"Right axis\", value: \"right\" }\n];\n\n/**\n * ### Editor interface for a XY chart\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar XYEditor = React.createClass({displayName: \"XYEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.object,\n\t\t\t_annotations: PropTypes.object\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ChartEditorMixin],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 4\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar scaleSettings = [];\n\n\t\t/*\n\t\t * If all but one series is set to secondary axis, don't allow secondary\n\t\t * axis option\n\t\t*/\n\t\tvar allowSecondaryAxis = (chartProps._numSecondaryAxis < (chartProps.data.length - 1));\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tvar chartSettings = map(chartProps.chartSettings, function(chartSetting, i) {\n\t\t\treturn React.createElement(XY_chartSettings, {\n\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\tallowSecondaryAxis: allowSecondaryAxis, \n\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\tindex: i, \n\t\t\t\tkey: i}\n\t\t\t)\n\t\t}, this);\n\n\t\t/* Y scale settings */\n\t\tscaleSettings.push(\n\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\tscale: chartProps.scale, \n\t\t\t\tclassName: \"scale-options\", \n\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tid: \"primaryScale\", \n\t\t\t\tname: \"Primary\", \n\t\t\t\tstepNumber: \"4\", \n\t\t\t\tkey: \"primaryScale\"}\n\t\t\t)\n\t\t);\n\n\t\t/* render a second y scale component if altAxis is specified */\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tid: \"secondaryScale\", \n\t\t\t\t\tname: \"Secondary\", \n\t\t\t\t\tstepNumber: \"4+\", \n\t\t\t\t\tkey: \"secondaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"xy-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\tReact.createElement(XY_resetLabels, {\n\t\t\t\t\tannotations: chartProps._annotations, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"_annotations\")}\n\t\t\t\t), \n\t\t\t\t\tchartSettings\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * When labels are dragged, this component appears and allows you to reset them\n * @property {object} annotations - Current `chartProps._annotations`\n * @property {function} onUpdate - Callback that passes a reset version of\n * `chartProps._annotation`\n * @instance\n * @memberof XYEditor\n */\nvar XY_resetLabels = React.createClass({displayName: \"XY_resetLabels\",\n\n\t_handleLabelReset: function() {\n\t\t/*\n\t\t * To reset labels, delete all `pos.x` and `pos.y` from the label object.\n\t\t * We will keep the width cached as it is used to calculate distance from a\n\t\t * previous label\n\t\t*/\n\t\tvar labels = clone(this.props.annotations.labels, true);\n\t\teach(keys(labels.values), function(labelKey, i) {\n\t\t\tif (labelKey !== \"hasDragged\") {\n\t\t\t\tvar currLabel = labels.values[i];\n\t\t\t\tif (currLabel.dragged == true) {\n\t\t\t\t\tlabels.values[i] = {\n\t\t\t\t\t\tdragged: false,\n\t\t\t\t\t\tname: currLabel.name,\n\t\t\t\t\t\twidth: currLabel.width\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* Tell the app that the labels are no longer dragged */\n\t\tlabels.hasDragged = false;\n\t\tvar annotations = update(this.props.annotations, { $merge: {\n\t\t\tlabels: labels\n\t\t}});\n\t\tthis.props.onUpdate(annotations);\n\t},\n\n\trender: function() {\n\t\tvar className = cx({\n\t\t\t\"label-reset\": true,\n\t\t\t\"active\": this.props.annotations.labels.hasDragged // only show if we've dragged\n\t\t});\n\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\tonClick: this._handleLabelReset, \n\t\t\t\tclassName: className, \n\t\t\t\ttext: \"Reset labels\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * Series-specific settings for each column in data\n * @property {boolean} allowSecondaryAxis - Should a secondary axis be allowed\n * @property {object[]} chartSettings - Current settings for data series\n * @property {function} onUpdate - Callback that handles new series settings\n * @property {function} onUpdateReparse - Callback that handles new series settings,\n * but which need to be sent back to `parse-xy`\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof XYEditor\n */\nvar XY_chartSettings = React.createClass({displayName: \"XY_chartSettings\",\n\n\tpropTypes: {\n\t\tchartSettings: PropTypes.arrayOf(PropTypes.object),\n\t\tallowSecondaryAxis: PropTypes.bool,\n\t\tnumColors: PropTypes.number,\n\t\tonUpdate: PropTypes.func,\n\t\tonUpdateReparse: PropTypes.func,\n\t},\n\n\t_handleSettingsUpdate: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* We need the index (ix) of the settings object to know which to update */\n\t\tchartSettings[ix][k] = v;\n\t\t/* `axis` and `colorIndex` require reparsing the input and splitting it up */\n\t\tthis.props.onUpdateReparse(chartSettings);\n\t},\n\n\trender: function() {\n\t\tvar chartSetting = this.props.chartSettings[this.props.index];\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: chartSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"h3\", {className: \"series-label series-label-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section axis-color\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\t\tindex: this.props.index, \n\t\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section axissection\"}, \n\t\t\t\t\t\tReact.createElement(Toggle, {\n\t\t\t\t\t\t\tclassName: \"toggle-\" + chartSetting.colorIndex, \n\t\t\t\t\t\t\tonToggle: this._handleSettingsUpdate.bind(null, this.props.index, \"altAxis\"), \n\t\t\t\t\t\t\tlabel: \"Right axis\", \n\t\t\t\t\t\t\ttoggled: chartSetting.altAxis}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section typesection\"}, \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tclassName: \"button-group-wrapper\", \n\t\t\t\t\t\tonClick: this._handleSettingsUpdate.bind(null, this.props.index, \"type\"), \n\t\t\t\t\t\tbuttons: typeOptions, \n\t\t\t\t\t\tvalue: chartSetting.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = XYEditor;",
            "path": "src/js/components/chart-xy/XYEditor.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYEditor.jsx#L54-L174"
          },
          "properties": [
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numSteps"
            }
          ],
          "scope": "instance",
          "memberof": "editors",
          "name": "XYEditor",
          "kind": "function",
          "members": {
            "instance": [
              {
                "description": "Series-specific settings for each column in data",
                "tags": [
                  {
                    "title": "property",
                    "description": "Should a secondary axis be allowed",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "allowSecondaryAxis"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Callback that handles new series settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdate"
                  },
                  {
                    "title": "property",
                    "description": "Callback that handles new series settings,\nbut which need to be sent back to `parse-xy`",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdateReparse"
                  },
                  {
                    "title": "property",
                    "description": "Total number of possible colors",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numColors"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "XYEditor"
                  },
                  {
                    "title": "name",
                    "name": "XY_chartSettings"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 241,
                      "column": 0
                    },
                    "end": {
                      "line": 307,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYEditor.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar PureRenderMixin = React.addons.PureRenderMixin;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar keys = require(\"lodash/object/keys\");\nvar each = require(\"lodash/collection/each\");\n\nvar dateParsers = require(\"../../util/process-dates\").dateParsers;\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar Dropdown = chartbuilderUI.Dropdown;\nvar LabelledTangle = chartbuilderUI.LabelledTangle;\nvar TextInput = chartbuilderUI.TextInput;\nvar Toggle = chartbuilderUI.Toggle;\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/* Available XY chart type options */\nvar typeOptions = [\n\t{ title: \"Line\", content: \"Line\", value: \"line\" },\n\t{ title: \"Columns\", content: \"Columns\", value: \"column\" },\n\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" }\n];\n\n/* Available XY axis options */\nvar axisOptions = [\n\t{ title: \"Left axis\", content: \"Left axis\", value: \"left\" },\n\t{ title: \"Right axis\", content: \"Right axis\", value: \"right\" }\n];\n\n/**\n * ### Editor interface for a XY chart\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar XYEditor = React.createClass({displayName: \"XYEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.object,\n\t\t\t_annotations: PropTypes.object\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ChartEditorMixin],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 4\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar scaleSettings = [];\n\n\t\t/*\n\t\t * If all but one series is set to secondary axis, don't allow secondary\n\t\t * axis option\n\t\t*/\n\t\tvar allowSecondaryAxis = (chartProps._numSecondaryAxis < (chartProps.data.length - 1));\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tvar chartSettings = map(chartProps.chartSettings, function(chartSetting, i) {\n\t\t\treturn React.createElement(XY_chartSettings, {\n\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\tallowSecondaryAxis: allowSecondaryAxis, \n\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\tindex: i, \n\t\t\t\tkey: i}\n\t\t\t)\n\t\t}, this);\n\n\t\t/* Y scale settings */\n\t\tscaleSettings.push(\n\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\tscale: chartProps.scale, \n\t\t\t\tclassName: \"scale-options\", \n\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tid: \"primaryScale\", \n\t\t\t\tname: \"Primary\", \n\t\t\t\tstepNumber: \"4\", \n\t\t\t\tkey: \"primaryScale\"}\n\t\t\t)\n\t\t);\n\n\t\t/* render a second y scale component if altAxis is specified */\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tid: \"secondaryScale\", \n\t\t\t\t\tname: \"Secondary\", \n\t\t\t\t\tstepNumber: \"4+\", \n\t\t\t\t\tkey: \"secondaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"xy-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\tReact.createElement(XY_resetLabels, {\n\t\t\t\t\tannotations: chartProps._annotations, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"_annotations\")}\n\t\t\t\t), \n\t\t\t\t\tchartSettings\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * When labels are dragged, this component appears and allows you to reset them\n * @property {object} annotations - Current `chartProps._annotations`\n * @property {function} onUpdate - Callback that passes a reset version of\n * `chartProps._annotation`\n * @instance\n * @memberof XYEditor\n */\nvar XY_resetLabels = React.createClass({displayName: \"XY_resetLabels\",\n\n\t_handleLabelReset: function() {\n\t\t/*\n\t\t * To reset labels, delete all `pos.x` and `pos.y` from the label object.\n\t\t * We will keep the width cached as it is used to calculate distance from a\n\t\t * previous label\n\t\t*/\n\t\tvar labels = clone(this.props.annotations.labels, true);\n\t\teach(keys(labels.values), function(labelKey, i) {\n\t\t\tif (labelKey !== \"hasDragged\") {\n\t\t\t\tvar currLabel = labels.values[i];\n\t\t\t\tif (currLabel.dragged == true) {\n\t\t\t\t\tlabels.values[i] = {\n\t\t\t\t\t\tdragged: false,\n\t\t\t\t\t\tname: currLabel.name,\n\t\t\t\t\t\twidth: currLabel.width\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* Tell the app that the labels are no longer dragged */\n\t\tlabels.hasDragged = false;\n\t\tvar annotations = update(this.props.annotations, { $merge: {\n\t\t\tlabels: labels\n\t\t}});\n\t\tthis.props.onUpdate(annotations);\n\t},\n\n\trender: function() {\n\t\tvar className = cx({\n\t\t\t\"label-reset\": true,\n\t\t\t\"active\": this.props.annotations.labels.hasDragged // only show if we've dragged\n\t\t});\n\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\tonClick: this._handleLabelReset, \n\t\t\t\tclassName: className, \n\t\t\t\ttext: \"Reset labels\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * Series-specific settings for each column in data\n * @property {boolean} allowSecondaryAxis - Should a secondary axis be allowed\n * @property {object[]} chartSettings - Current settings for data series\n * @property {function} onUpdate - Callback that handles new series settings\n * @property {function} onUpdateReparse - Callback that handles new series settings,\n * but which need to be sent back to `parse-xy`\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof XYEditor\n */\nvar XY_chartSettings = React.createClass({displayName: \"XY_chartSettings\",\n\n\tpropTypes: {\n\t\tchartSettings: PropTypes.arrayOf(PropTypes.object),\n\t\tallowSecondaryAxis: PropTypes.bool,\n\t\tnumColors: PropTypes.number,\n\t\tonUpdate: PropTypes.func,\n\t\tonUpdateReparse: PropTypes.func,\n\t},\n\n\t_handleSettingsUpdate: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* We need the index (ix) of the settings object to know which to update */\n\t\tchartSettings[ix][k] = v;\n\t\t/* `axis` and `colorIndex` require reparsing the input and splitting it up */\n\t\tthis.props.onUpdateReparse(chartSettings);\n\t},\n\n\trender: function() {\n\t\tvar chartSetting = this.props.chartSettings[this.props.index];\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: chartSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"h3\", {className: \"series-label series-label-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section axis-color\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\t\tindex: this.props.index, \n\t\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section axissection\"}, \n\t\t\t\t\t\tReact.createElement(Toggle, {\n\t\t\t\t\t\t\tclassName: \"toggle-\" + chartSetting.colorIndex, \n\t\t\t\t\t\t\tonToggle: this._handleSettingsUpdate.bind(null, this.props.index, \"altAxis\"), \n\t\t\t\t\t\t\tlabel: \"Right axis\", \n\t\t\t\t\t\t\ttoggled: chartSetting.altAxis}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section typesection\"}, \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tclassName: \"button-group-wrapper\", \n\t\t\t\t\t\tonClick: this._handleSettingsUpdate.bind(null, this.props.index, \"type\"), \n\t\t\t\t\t\tbuttons: typeOptions, \n\t\t\t\t\t\tvalue: chartSetting.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = XYEditor;",
                  "path": "src/js/components/chart-xy/XYEditor.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYEditor.jsx#L241-L307"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Should a secondary axis be allowed",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "allowSecondaryAxis"
                  },
                  {
                    "title": "property",
                    "description": "Current settings for data series",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Callback that handles new series settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdate"
                  },
                  {
                    "title": "property",
                    "description": "Callback that handles new series settings,\nbut which need to be sent back to `parse-xy`",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdateReparse"
                  },
                  {
                    "title": "property",
                    "description": "Total number of possible colors",
                    "type": {
                      "type": "NameExpression",
                      "name": "number"
                    },
                    "name": "numColors"
                  }
                ],
                "scope": "instance",
                "memberof": "XYEditor",
                "name": "XY_chartSettings",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "XYEditor",
                  "XY_chartSettings"
                ]
              },
              {
                "description": "When labels are dragged, this component appears and allows you to reset them",
                "tags": [
                  {
                    "title": "property",
                    "description": "Current `chartProps._annotations`",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "annotations"
                  },
                  {
                    "title": "property",
                    "description": "Callback that passes a reset version of\n`chartProps._annotation`",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdate"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "XYEditor"
                  },
                  {
                    "title": "name",
                    "name": "XY_resetLabels"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 184,
                      "column": 0
                    },
                    "end": {
                      "line": 228,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYEditor.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar PureRenderMixin = React.addons.PureRenderMixin;\nvar update = React.addons.update;\nvar cx = React.addons.classSet;\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar keys = require(\"lodash/object/keys\");\nvar each = require(\"lodash/collection/each\");\n\nvar dateParsers = require(\"../../util/process-dates\").dateParsers;\n\n/* Shared Chartbuilder components */\nvar DataInput = require(\"../shared/DataInput.jsx\");\nvar DateScaleSettings = require(\"../shared/DateScaleSettings.jsx\");\nvar XY_yScaleSettings = require(\"../shared/XY_yScaleSettings.jsx\");\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar ButtonGroup = chartbuilderUI.ButtonGroup;\nvar ColorPicker = chartbuilderUI.ColorPicker;\nvar Dropdown = chartbuilderUI.Dropdown;\nvar LabelledTangle = chartbuilderUI.LabelledTangle;\nvar TextInput = chartbuilderUI.TextInput;\nvar Toggle = chartbuilderUI.Toggle;\n\nvar ChartEditorMixin = require(\"../mixins/ChartEditorMixin.js\");\n\n/* Available XY chart type options */\nvar typeOptions = [\n\t{ title: \"Line\", content: \"Line\", value: \"line\" },\n\t{ title: \"Columns\", content: \"Columns\", value: \"column\" },\n\t{ title: \"Dots\", content: \"Dots\", value: \"scatterPlot\" }\n];\n\n/* Available XY axis options */\nvar axisOptions = [\n\t{ title: \"Left axis\", content: \"Left axis\", value: \"left\" },\n\t{ title: \"Right axis\", content: \"Right axis\", value: \"right\" }\n];\n\n/**\n * ### Editor interface for a XY chart\n * @property {object} chartProps - Properties used to draw this chart\n * @property {number} numSteps - Allow the rendered component to interacted with and edited\n * @instance\n * @memberof editors\n */\nvar XYEditor = React.createClass({displayName: \"XYEditor\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.shape({\n\t\t\tinput: PropTypes.shape({\n\t\t\t\traw: PropTypes.string,\n\t\t\t\tstatus: PropTypes.string,\n\t\t\t\tvalid: PropTypes.bool\n\t\t\t}).isRequired,\n\t\t\tchartSettings: PropTypes.array,\n\t\t\tdata: PropTypes.array,\n\t\t\tscale: PropTypes.object,\n\t\t\t_annotations: PropTypes.object\n\t\t}),\n\t\tnumSteps: PropTypes.number\n\t},\n\n\tmixins: [ChartEditorMixin],\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tnumSteps: 4\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar scaleSettings = [];\n\n\t\t/*\n\t\t * If all but one series is set to secondary axis, don't allow secondary\n\t\t * axis option\n\t\t*/\n\t\tvar allowSecondaryAxis = (chartProps._numSecondaryAxis < (chartProps.data.length - 1));\n\n\t\t/* Create a settings component for each data series (column) */\n\t\tvar chartSettings = map(chartProps.chartSettings, function(chartSetting, i) {\n\t\t\treturn React.createElement(XY_chartSettings, {\n\t\t\t\tchartSettings: chartProps.chartSettings, \n\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"chartSettings\"), \n\t\t\t\tonUpdateReparse: this._handlePropAndReparse.bind(null, \"chartSettings\"), \n\t\t\t\tallowSecondaryAxis: allowSecondaryAxis, \n\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\tindex: i, \n\t\t\t\tkey: i}\n\t\t\t)\n\t\t}, this);\n\n\t\t/* Y scale settings */\n\t\tscaleSettings.push(\n\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\tscale: chartProps.scale, \n\t\t\t\tclassName: \"scale-options\", \n\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\tid: \"primaryScale\", \n\t\t\t\tname: \"Primary\", \n\t\t\t\tstepNumber: \"4\", \n\t\t\t\tkey: \"primaryScale\"}\n\t\t\t)\n\t\t);\n\n\t\t/* render a second y scale component if altAxis is specified */\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(XY_yScaleSettings, {\n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tonUpdate: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tonReset: this._handlePropAndReparse.bind(null, \"scale\"), \n\t\t\t\t\tclassName: \"scale-options\", \n\t\t\t\t\tid: \"secondaryScale\", \n\t\t\t\t\tname: \"Secondary\", \n\t\t\t\t\tstepNumber: \"4+\", \n\t\t\t\t\tkey: \"secondaryScale\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t/* Add date settings if we are parsing a date */\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tscaleSettings.push(\n\t\t\t\tReact.createElement(DateScaleSettings, {\n\t\t\t\t\tkey: \"xScale\", \n\t\t\t\t\tscale: chartProps.scale, \n\t\t\t\t\tstepNumber: \"5\", \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"scale\")}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"xy-editor\"}, \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"2\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Input your data\")\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(DataInput, {\n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tclassName: \"data-input\"}\n\t\t\t\t\t)\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tReact.createElement(\"h2\", null, \n\t\t\t\t\t\tReact.createElement(\"span\", {className: \"step-number\"}, \"3\"), \n\t\t\t\t\t\tReact.createElement(\"span\", null, \"Set series options\")\n\t\t\t\t\t), \n\t\t\t\tReact.createElement(XY_resetLabels, {\n\t\t\t\t\tannotations: chartProps._annotations, \n\t\t\t\t\tonUpdate: this._handlePropUpdate.bind(null, \"_annotations\")}\n\t\t\t\t), \n\t\t\t\t\tchartSettings\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"div\", {className: \"editor-options\"}, \n\t\t\t\t\tscaleSettings\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * When labels are dragged, this component appears and allows you to reset them\n * @property {object} annotations - Current `chartProps._annotations`\n * @property {function} onUpdate - Callback that passes a reset version of\n * `chartProps._annotation`\n * @instance\n * @memberof XYEditor\n */\nvar XY_resetLabels = React.createClass({displayName: \"XY_resetLabels\",\n\n\t_handleLabelReset: function() {\n\t\t/*\n\t\t * To reset labels, delete all `pos.x` and `pos.y` from the label object.\n\t\t * We will keep the width cached as it is used to calculate distance from a\n\t\t * previous label\n\t\t*/\n\t\tvar labels = clone(this.props.annotations.labels, true);\n\t\teach(keys(labels.values), function(labelKey, i) {\n\t\t\tif (labelKey !== \"hasDragged\") {\n\t\t\t\tvar currLabel = labels.values[i];\n\t\t\t\tif (currLabel.dragged == true) {\n\t\t\t\t\tlabels.values[i] = {\n\t\t\t\t\t\tdragged: false,\n\t\t\t\t\t\tname: currLabel.name,\n\t\t\t\t\t\twidth: currLabel.width\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* Tell the app that the labels are no longer dragged */\n\t\tlabels.hasDragged = false;\n\t\tvar annotations = update(this.props.annotations, { $merge: {\n\t\t\tlabels: labels\n\t\t}});\n\t\tthis.props.onUpdate(annotations);\n\t},\n\n\trender: function() {\n\t\tvar className = cx({\n\t\t\t\"label-reset\": true,\n\t\t\t\"active\": this.props.annotations.labels.hasDragged // only show if we've dragged\n\t\t});\n\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\tonClick: this._handleLabelReset, \n\t\t\t\tclassName: className, \n\t\t\t\ttext: \"Reset labels\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * Series-specific settings for each column in data\n * @property {boolean} allowSecondaryAxis - Should a secondary axis be allowed\n * @property {object[]} chartSettings - Current settings for data series\n * @property {function} onUpdate - Callback that handles new series settings\n * @property {function} onUpdateReparse - Callback that handles new series settings,\n * but which need to be sent back to `parse-xy`\n * @property {number} numColors - Total number of possible colors\n * @instance\n * @memberof XYEditor\n */\nvar XY_chartSettings = React.createClass({displayName: \"XY_chartSettings\",\n\n\tpropTypes: {\n\t\tchartSettings: PropTypes.arrayOf(PropTypes.object),\n\t\tallowSecondaryAxis: PropTypes.bool,\n\t\tnumColors: PropTypes.number,\n\t\tonUpdate: PropTypes.func,\n\t\tonUpdateReparse: PropTypes.func,\n\t},\n\n\t_handleSettingsUpdate: function(ix, k, v) {\n\t\t/* Clone the array of objects so that we dont mutate existing state */\n\t\tvar chartSettings = map(this.props.chartSettings, clone);\n\t\t/* We need the index (ix) of the settings object to know which to update */\n\t\tchartSettings[ix][k] = v;\n\t\t/* `axis` and `colorIndex` require reparsing the input and splitting it up */\n\t\tthis.props.onUpdateReparse(chartSettings);\n\t},\n\n\trender: function() {\n\t\tvar chartSetting = this.props.chartSettings[this.props.index];\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: \"series-control\"}, \n\t\t\t\tReact.createElement(TextInput, {\n\t\t\t\t\ttype: \"text\", \n\t\t\t\t\tvalue: chartSetting.label, \n\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"label\"), \n\t\t\t\t\tclassName: \"series-label-input series-label-input-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"h3\", {className: \"series-label series-label-\" + chartSetting.colorIndex}\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section axis-color\"}, \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section colorsection\"}, \n\t\t\t\t\t\tReact.createElement(\"label\", null, \"Color\"), \n\t\t\t\t\t\tReact.createElement(ColorPicker, {\n\t\t\t\t\t\t\tonChange: this._handleSettingsUpdate.bind(null, this.props.index, \"colorIndex\"), \n\t\t\t\t\t\t\tnumColors: this.props.numColors, \n\t\t\t\t\t\t\tindex: this.props.index, \n\t\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(\"div\", {className: \"section axissection\"}, \n\t\t\t\t\t\tReact.createElement(Toggle, {\n\t\t\t\t\t\t\tclassName: \"toggle-\" + chartSetting.colorIndex, \n\t\t\t\t\t\t\tonToggle: this._handleSettingsUpdate.bind(null, this.props.index, \"altAxis\"), \n\t\t\t\t\t\t\tlabel: \"Right axis\", \n\t\t\t\t\t\t\ttoggled: chartSetting.altAxis}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"section typesection\"}, \n\t\t\t\t\tReact.createElement(ButtonGroup, {\n\t\t\t\t\t\tclassName: \"button-group-wrapper\", \n\t\t\t\t\t\tonClick: this._handleSettingsUpdate.bind(null, this.props.index, \"type\"), \n\t\t\t\t\t\tbuttons: typeOptions, \n\t\t\t\t\t\tvalue: chartSetting.type}\n\t\t\t\t\t)\n\t\t\t\t), \n\n\t\t\t\tReact.createElement(\"div\", {className: \"clearfix\"})\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = XYEditor;",
                  "path": "src/js/components/chart-xy/XYEditor.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYEditor.jsx#L184-L228"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Current `chartProps._annotations`",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "annotations"
                  },
                  {
                    "title": "property",
                    "description": "Callback that passes a reset version of\n`chartProps._annotation`",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "onUpdate"
                  }
                ],
                "scope": "instance",
                "memberof": "XYEditor",
                "name": "XY_resetLabels",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "editors",
                  "XYEditor",
                  "XY_resetLabels"
                ]
              }
            ],
            "static": []
          },
          "path": [
            "editors",
            "XYEditor"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "editors"
    ]
  },
  {
    "description": "Helper functions!",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "helper"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 216,
          "column": 0
        },
        "end": {
          "line": 224,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
      "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
      "path": "src/js/util/helper.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L216-L224"
    },
    "name": "helper",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "combine_margin_pading",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "m"
            },
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "p"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "combine_margin_pading"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 150,
                "column": 0
              },
              "end": {
                "line": 157,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L150-L157"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "m"
            },
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "p"
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "returns": [
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "combine_margin_pading",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "combine_margin_pading"
          ]
        },
        {
          "description": "compute_scale_domain",
          "tags": [
            {
              "title": "param",
              "description": "Current scale before generating new domain",
              "type": null,
              "name": "scaleObj"
            },
            {
              "title": "param",
              "description": "All values in the current scale",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "data"
            },
            {
              "title": "param",
              "description": "Whether to return nice values or force a minimum of 0\nor below",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "opts"
            },
            {
              "title": "returns",
              "description": "{ domain: [min, max], custom: <boolean> }",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "name",
              "name": "compute_scale_domain"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 55,
                "column": 0
              },
              "end": {
                "line": 98,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L55-L98"
          },
          "params": [
            {
              "title": "param",
              "description": "Current scale before generating new domain",
              "type": null,
              "name": "scaleObj"
            },
            {
              "title": "param",
              "description": "All values in the current scale",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "data"
            },
            {
              "title": "param",
              "description": "Whether to return nice values or force a minimum of 0\nor below",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "opts"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "{ domain: [min, max], custom: <boolean> }",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "name": "compute_scale_domain",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "compute_scale_domain"
          ]
        },
        {
          "description": "Generate an exact number of ticks given a domain",
          "tags": [
            {
              "title": "param",
              "description": "min/max of the current scale",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "domain"
            },
            {
              "title": "param",
              "description": "desired number of ticks",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numticks"
            },
            {
              "title": "returns",
              "description": "Array of ticks",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "name",
              "name": "exact_ticks"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 17,
                "column": 0
              },
              "end": {
                "line": 42,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L17-L42"
          },
          "params": [
            {
              "title": "param",
              "description": "min/max of the current scale",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "domain"
            },
            {
              "title": "param",
              "description": "desired number of ticks",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "numticks"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Array of ticks",
              "type": {
                "type": "TypeApplication",
                "expression": {
                  "type": "NameExpression",
                  "name": "Array"
                },
                "applications": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "name": "exact_ticks",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "exact_ticks"
          ]
        },
        {
          "description": "Given a defaults object and a source object, copy the value from the source\nif it contains the same key, otherwise return the default. Skip keys that\nonly exist in the source object.",
          "tags": [
            {
              "title": "param",
              "description": "Default schema",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "defaults"
            },
            {
              "title": "param",
              "description": "Source object to copy properties from",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "source"
            },
            {
              "title": "returns",
              "description": "Result has identical keys to defaults",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "name",
              "name": "merge_or_apply"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 198,
                "column": 0
              },
              "end": {
                "line": 210,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L198-L210"
          },
          "params": [
            {
              "title": "param",
              "description": "Default schema",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "defaults"
            },
            {
              "title": "param",
              "description": "Source object to copy properties from",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "source"
            }
          ],
          "returns": [
            {
              "title": "returns",
              "description": "Result has identical keys to defaults",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "name": "merge_or_apply",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "merge_or_apply"
          ]
        },
        {
          "description": "precision",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "a"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "UndefinedLiteral"
              }
            },
            {
              "title": "name",
              "name": "precision"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 167,
                "column": 0
              },
              "end": {
                "line": 172,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L167-L172"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "a"
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "returns": [
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "UndefinedLiteral"
              }
            }
          ],
          "name": "precision",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "precision"
          ]
        },
        {
          "description": "round_to_precision\nRound a number to N decimal places",
          "tags": [
            {
              "title": "param",
              "description": "Number to be rounded",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "num"
            },
            {
              "title": "param",
              "description": "Desired precision",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "precision"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "supress_thou_sep"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "returns",
              "description": "Rounded number",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            },
            {
              "title": "name",
              "name": "round_to_precision"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 111,
                "column": 0
              },
              "end": {
                "line": 139,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L111-L139"
          },
          "params": [
            {
              "title": "param",
              "description": "Number to be rounded",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "num"
            },
            {
              "title": "param",
              "description": "Desired precision",
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "precision"
            },
            {
              "title": "param",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "supress_thou_sep"
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "returns": [
            {
              "title": "returns",
              "description": "Rounded number",
              "type": {
                "type": "NameExpression",
                "name": "number"
              }
            }
          ],
          "name": "round_to_precision",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "round_to_precision"
          ]
        },
        {
          "description": "transform_coords",
          "tags": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "transformString"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "helper"
            },
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "UndefinedLiteral"
              }
            },
            {
              "title": "name",
              "name": "transform_coords"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 182,
                "column": 0
              },
              "end": {
                "line": 186,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/util/helper.js",
            "code": "var isArray = require(\"lodash/lang/isArray\");\nvar isUndefined = require(\"lodash/lang/isUndefined\");\nvar keys = require(\"lodash/object/keys\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar d3 = require(\"d3\");\nvar processDates = require(\"./process-dates\");\n\n/**\n * Generate an exact number of ticks given a domain\n *\n * @param {number[]} domain - min/max of the current scale\n * @param {number} numticks - desired number of ticks\n * @return {string[]} Array of ticks\n * @static\n * @memberof helper\n */\nfunction exact_ticks(domain, numticks) {\n\tnumticks -= 1;\n\tvar ticks = [];\n\tvar delta = domain[1] - domain[0];\n\tvar i;\n\tfor (i = 0; i < numticks; i++) {\n\t\tticks.push(domain[0] + (delta / numticks) * i);\n\t}\n\tticks.push(domain[1]);\n\n\tif (domain[1] * domain[0] < 0) {\n\t\t//if the domain crosses zero, make sure there is a zero line\n\t\tvar hasZero = false;\n\t\tfor (i = ticks.length - 1; i >= 0; i--) {\n\t\t\t//check if there is already a zero line\n\t\t\tif (ticks[i] === 0) {\n\t\t\t\thasZero = true;\n\t\t\t}\n\t\t}\n\t\tif (!hasZero) {\n\t\t\tticks.push(0);\n\t\t}\n\t}\n\n\treturn ticks;\n}\n\n/**\n * compute_scale_domain\n *\n * @param scaleObj - Current scale before generating new domain\n * @param {number[]} data - All values in the current scale\n * @param {object} opts - Whether to return nice values or force a minimum of 0\n * or below\n * @return {object} { domain: [min, max], custom: <boolean> }\n * @static\n * @memberof helper\n */\nfunction compute_scale_domain(scaleObj, data, opts) {\n\t// Compute the domain (`[min, max]`) of a scale based on its data points.\n\t// `data` is a flat array of all values used in this scale, and is\n\t// created by `input-parsers/parse-<chart>.js`\n\topts = opts || {};\n\tvar scaleDomain = scaleObj.domain || [];\n\tvar _domain;\n\tvar defaultMin;\n\tvar defaultMax;\n\n\tif (!isArray(data)) {\n\t\tthrow new TypeError(\"data passed to compute_scale_domain must be an array\");\n\t}\n\n\tvar extent = d3.extent(data);\n\tvar niced = d3.scale.linear()\n\t\t\t.domain(extent)\n\t\t\t.nice()\n\t\t\t.domain();\n\n\tif (!scaleObj.domain || !scaleObj.custom) {\n\t\tif (opts.nice) {\n\t\t\t_domain = niced;\n\t\t} else {\n\t\t\t_domain = extent;\n\t\t}\n\t\tdefaultMin = true;\n\t\tdefaultMax = true;\n\t} else {\n\t\t_domain = (opts.nice) ? niced : extent;\n\t\tdefaultMin = (_domain[0] === scaleDomain[0] || isUndefined(scaleDomain[0]));\n\t\tdefaultMax = (_domain[1] === scaleDomain[1] || isUndefined(scaleDomain[1]));\n\t\t_domain = scaleDomain;\n\t}\n\n\tif (opts.minZero) {\n\t\t_domain[0] = Math.min(_domain[0], 0);\n\t}\n\n\treturn {\n\t\tdomain: _domain,\n\t\tcustom: (!defaultMin || !defaultMax)\n\t};\n}\n\n/**\n * round_to_precision\n * Round a number to N decimal places\n *\n * @param {number} num - Number to be rounded\n * @param {number} precision - Desired precision\n * @param {boolean} supress_thou_sep\n * @static\n * @memberof helper\n * @return {number} Rounded number\n */\nfunction round_to_precision(num, precision, supress_thou_sep) {\n\tif (num === 0) {\n\t\t//zero should always be \"0\"\n\t\treturn \"0\";\n\t}\n\n\tvar s = Math.round(num * Math.pow(10,precision)) / Math.pow(10,precision);\n\ts = s + \"\";\n\n\ts = s.split(\".\");\n\n\tif (s.length == 1) {\n\t\ts[1] = \"\";\n\t}\n\n\tif (s[1].length < precision) {\n\t\ts[1] += Array(precision-s[1].length + 1).join(\"0\");\n\t}\n\n\tif (!supress_thou_sep) {\n\t\ts[0] = d3.format(\",\")(parseInt(s[0]));\n\t}\n\n\tif (precision === 0) {\n\t\treturn s[0];\n\t}\n\n\treturn s.join(\".\");\n}\n\n/**\n * combine_margin_pading\n *\n * @param m\n * @param p\n * @static\n * @memberof helper\n * @return {object}\n */\nfunction combine_margin_pading(m,p) {\n\treturn {\n\t\ttop: m.top + p.top,\n\t\tright: m.right + p.right,\n\t\tbottom: m.bottom + p.bottom,\n\t\tleft: m.left + p.left\n\t};\n}\n\n/**\n * precision\n *\n * @param a\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction precision(a) {\n  // http://stackoverflow.com/a/27865285/1181761\n  var e = 1;\n  while (Math.round(a * e) / e !== a) e *= 10;\n  return Math.round(Math.log(e) / Math.LN10);\n}\n\n/**\n * transform_coords\n *\n * @param transformString\n * @static\n * @memberof helper\n * @return {undefined}\n */\nfunction transform_coords(transformString) {\n\t// Split on both space and comma because IE10 likes spaces?\n\tvar s = transformString.split(/\\s|,/);\n\treturn [s[0].split(\"(\")[1],s[1].split(\")\")[0]].map(parseFloat);\n}\n\n/**\n * Given a defaults object and a source object, copy the value from the source\n * if it contains the same key, otherwise return the default. Skip keys that\n * only exist in the source object.\n * @param {object} defaults - Default schema\n * @param {object} source - Source object to copy properties from\n * @returns {object} - Result has identical keys to defaults\n * @static\n * @memberof helper\n*/\nfunction merge_or_apply(defaults, source) {\n\tvar defaultKeys = keys(defaults);\n\tvar sourceKeys = keys(source);\n\treturn reduce(defaultKeys, function(result, key) {\n\t\tif (sourceKeys.indexOf(key) > -1) {\n\t\t\tresult[key] = source[key];\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult[key] = defaults[key];\n\t\t\treturn result;\n\t\t}\n\t}, {});\n}\n\n/**\n * Helper functions!\n * @name helper\n */\nvar helper = {\n\texactTicks : exact_ticks,\n\troundToPrecision: round_to_precision,\n\tcombineMarginPadding: combine_margin_pading,\n\tcomputeScaleDomain: compute_scale_domain,\n\tprecision: precision,\n\ttransformCoords: transform_coords,\n\tmergeOrApply: merge_or_apply\n};\n\nmodule.exports = helper;",
            "path": "src/js/util/helper.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/util/helper.js#L182-L186"
          },
          "params": [
            {
              "title": "param",
              "description": null,
              "type": null,
              "name": "transformString"
            }
          ],
          "scope": "static",
          "memberof": "helper",
          "returns": [
            {
              "title": "returns",
              "description": null,
              "type": {
                "type": "UndefinedLiteral"
              }
            }
          ],
          "name": "transform_coords",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "helper",
            "transform_coords"
          ]
        }
      ]
    },
    "path": [
      "helper"
    ]
  },
  {
    "description": "Button that persists for `TIMER_DURATION` and allows user to re-load the\nchart currently saved in `localStorage`. On click, it updates the\n`SessionStore`.",
    "tags": [
      {
        "title": "name",
        "name": "LocalStorageTimer"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 21,
          "column": 0
        },
        "end": {
          "line": 61,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/LocalStorageTimer.jsx",
      "code": "var SessionStore = require(\"../stores/SessionStore\");\nvar ChartViewActions = require(\"../actions/ChartViewActions\");\nvar ChartbuilderLocalStorageAPI = require(\"../util/ChartbuilderLocalStorageAPI\");\n\n/* Node modules */\nvar React = require(\"react\");\nvar cx = React.addons.classSet;\nvar PropTypes = React.PropTypes;\n\n/* Chartbuilder UI components */\nvar chartbuilderUI = require(\"chartbuilder-ui\");\nvar Button = chartbuilderUI.Button;\nvar timer;\nvar TIMER_DURATION = 30000;\n\n/**\n * Button that persists for `TIMER_DURATION` and allows user to re-load the\n * chart currently saved in `localStorage`. On click, it updates the\n * `SessionStore`.\n */\nvar LocalStorageTimer = React.createClass({displayName: \"LocalStorageTimer\",\n\tpropTypes: {\n\t\ttimerOn: PropTypes.bool.isRequired\n\t},\n\n\t_disableTimer: function() {\n\t\tclearTimeout(timer);\n\t\tChartViewActions.stopTimer();\n\t},\n\n\t_handleLoadChart: function() {\n\t\tChartbuilderLocalStorageAPI.getChart();\n\t\tthis._disableTimer();\n\t},\n\n\tcomponentWillMount: function() {\n\t\tif (localStorage.hasOwnProperty(\"model\")) {\n\t\t\ttimer = setTimeout(function() {\n\t\t\t\tthis._disableTimer();\n\t\t\t}.bind(this), TIMER_DURATION);\n\t\t\tChartViewActions.startTimer();\n\t\t} else {\n\t\t\tChartViewActions.stopTimer();\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar className = cx({\n\t\t\t\"load-localstorage\": true,\n\t\t\t\"active\": this.props.timerOn\n\t\t});\n\n\t\treturn (\n\t\t\tReact.createElement(Button, {\n\t\t\t\tonClick: this._handleLoadChart, \n\t\t\t\tclassName: className, \n\t\t\t\ttext: \"Load previous chart\"}\n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = LocalStorageTimer;",
      "path": "src/js/components/LocalStorageTimer.jsx",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/LocalStorageTimer.jsx#L21-L61"
    },
    "name": "LocalStorageTimer",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "LocalStorageTimer"
    ]
  },
  {
    "description": "",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "renderers"
      },
      {
        "title": "memberof",
        "description": "module"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 6,
          "column": 0
        },
        "end": {
          "line": 9,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/renderers.js",
      "code": "module.exports = {\n\txy: require(\"../components/chart-xy/XYRenderer.jsx\"),\n\tchartgrid: require(\"../components/chart-grid/ChartGridRenderer.jsx\")\n};",
      "path": "src/js/charts/renderers.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/renderers.js#L6-L9"
    },
    "name": "renderers",
    "memberof": "module",
    "scope": "static",
    "members": {
      "instance": [
        {
          "description": "### Component that renders bar (row) charts in a chart grid",
          "tags": [
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "editable"
            },
            {
              "title": "property",
              "description": "Parsed visual display configuration for chart grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "displayConfig"
            },
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "renderers"
            },
            {
              "title": "name",
              "name": "ChartGridRenderer"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 28,
                "column": 0
              },
              "end": {
                "line": 99,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridRenderer.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar chartSizes = require(\"../../config/chart-sizes\");\nvar clone = require(\"lodash/lang/clone\");\nvar assign = require(\"lodash/object/assign\");\nvar each = require(\"lodash/collection/each\");\n\n/* Chart grid types */\nvar ChartGridBars = require(\"./ChartGridBars.jsx\");\nvar ChartGridXY = require(\"./ChartGridXY.jsx\");\n\n/**\n * ### Component that renders bar (row) charts in a chart grid\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @instance\n * @memberof renderers\n */\nvar ChartGridRenderer = React.createClass({displayName: \"ChartGridRenderer\",\n\n\tpropTypes: {\n\t\teditable: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.obj,\n\t\t\tpadding: PropTypes.obj\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}).isRequired,\n\t\tshowMetadata: PropTypes.bool,\n\t\tmetadata: PropTypes.object\n\t},\n\n\t_createMobileScale: function(_chartProps) {\n\t\tvar mobile = clone(_chartProps.mobile.scale, true);\n\t\tvar scale = assign({}, _chartProps.scale, mobile);\n\t\teach([\"prefix\", \"suffix\"], function(text) {\n\t\t\tif (!mobile.primaryScale[text] || mobile.primaryScale[text] === \"\") {\n\t\t\t\tscale.primaryScale[text] = _chartProps.scale.primaryScale[text];\n\t\t\t}\n\t\t});\n\t\treturn scale;\n\t},\n\n\trender: function() {\n\t\tvar _chartProps = this.props.chartProps;\n\t\tvar gridTypeRenderer;\n\t\tvar dimensions;\n\t\tvar scale;\n\t\tif (this.props.enableResponsive && _chartProps.hasOwnProperty(\"mobile\") && this.props.isSmall) {\n\t\t\tif (_chartProps.mobile.scale) {\n\t\t\t\tscale = this._createMobileScale(_chartProps);\n\t\t\t} else {\n\t\t\t\tscale = _chartProps.scale;\n\t\t\t}\n\t\t} else {\n\t\t\tscale = _chartProps.scale;\n\t\t}\n\n\t\tvar chartProps = update(_chartProps, { $merge: { scale: scale }});\n\n\t\t/* Pass a boolean that detects whether there is a title */\n\t\tvar hasTitle = (this.props.metadata.title.length > 0 && this.props.showMetadata);\n\n\t\t/* Choose between grid of bars and grid of XY, and transfer all props to\n\t\t * relevant component\n\t\t*/\n\t\tif (this.props.chartProps._grid.type == \"bar\") {\n\t\t\tgridTypeRenderer = (\n\t\t\t\tReact.createElement(ChartGridBars, React.__spread({}, \n\t\t\t\t\tthis.props, \n\t\t\t\t\t{scale: scale, \n\t\t\t\t\thasTitle: hasTitle})\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tgridTypeRenderer = (\n\t\t\t\tReact.createElement(ChartGridXY, React.__spread({}, \n\t\t\t\t\tthis.props, \n\t\t\t\t\t{scale: scale, \n\t\t\t\t\thasTitle: hasTitle})\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\treturn gridTypeRenderer;\n\t}\n});\n\n\nmodule.exports = ChartGridRenderer;",
            "path": "src/js/components/chart-grid/ChartGridRenderer.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridRenderer.jsx#L28-L99"
          },
          "properties": [
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "editable"
            },
            {
              "title": "property",
              "description": "Parsed visual display configuration for chart grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "displayConfig"
            },
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            }
          ],
          "scope": "instance",
          "memberof": "renderers",
          "name": "ChartGridRenderer",
          "kind": "function",
          "members": {
            "instance": [
              {
                "description": "### Component that renders bar (row) charts in a chart grid",
                "tags": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "editable"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridRenderer"
                  },
                  {
                    "title": "name",
                    "name": "ChartGridBars"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 40,
                      "column": 0
                    },
                    "end": {
                      "line": 216,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridBars.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar d4 = require(\"d4\");\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar reduce = require(\"lodash/collection/reduce\");\n\nvar SessionStore = require(\"../../stores/SessionStore\");\nvar separators = SessionStore.get(\"separators\");\nvar formatThousands = require(\"d3\").format(separators.thousands);\n\n/* Helper functions */\nvar cb_bar_grid = require(\"../../charts/cb-charts\").cb_bar_grid;\nvar help = require(\"../../util/helper.js\");\n\n/* Renderer mixins */\nvar ChartRendererMixin = require(\"../mixins/ChartRendererMixin.js\");\n\n/* Svg components */\nvar HiddenSvg = require(\"../svg/HiddenSvg.jsx\");\n\n/* One `GridChart` will be drawn for every column used in our grid */\nvar GridChart = require(\"./GridChart.jsx\");\n\n/**\n * ### Component that renders bar (row) charts in a chart grid\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @instance\n * @memberof ChartGridRenderer\n */\nvar ChartGridBars = React.createClass({displayName: \"ChartGridBars\",\n\n\tpropTypes: {\n\t\teditable: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.obj,\n\t\t\tpadding: PropTypes.obj\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}).isRequired\n\t},\n\n\tmixins: [ ChartRendererMixin ],\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tmaxTickWidth: 0,\n\t\t\tbarLabelOverlap: 0 // how far a bar label is overlapping the available chart width\n\t\t};\n\t},\n\n\trender: function() {\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar hiddenSvg = [];\n\n\t\tvar chartProps = update(this.props.chartProps, { $merge: {\n\t\t\tdata: this._applySettingsToData(this.props.chartProps, { barHeight: displayConfig.barHeight }),\n\t\t\tscale: this.props.scale\n\t\t}});\n\t\tvar scale = chartProps.scale.primaryScale;\n\n\t\t/*\n\t\t * Set `extraPadding.left` to the width of the widest axis tick.\n\t\t*/\n\t\tvar extraPadding = {\n\t\t\ttop: chartProps.extraPadding.top,\n\t\t\tright: chartProps.extraPadding.right,\n\t\t\tbottom: chartProps.extraPadding.bottom,\n\t\t\tleft: this.state.maxTickWidth\n\t\t};\n\n\t\tvar dimensions = clone(this.props.dimensions);\n\n\t\t/* Divide total width by number of grids */\n\t\tvar dimensionsPerGrid = {\n\t\t\twidth: (dimensions.width - this.state.maxTickWidth) / chartProps._grid.cols\n\t\t};\n\n\t\t/* Height of each grid block */\n\t\tdimensionsPerGrid.height = (dimensions.height) / chartProps._grid.rows;\n\n\t\tif (this.props.hasTitle) {\n\t\t\textraPadding.top = extraPadding.top + displayConfig.afterTitle;\n\t\t\tdimensionsPerGrid.height -= displayConfig.afterTitle;\n\t\t}\n\n\n\t\t/* Get the number of charts and only render that many */\n\t\tvar numCharts = chartProps._grid.rows * chartProps._grid.cols;\n\n\t\t/*\n\t\t * Render a hidden set of SVG axis labels in order to find out the\n\t\t * maximum width the labels will take up. Doing this in a hidden component\n\t\t * cuts down on the number of chart redraws. The max width is set to this\n\t\t * component as `this.state.maxTickWidth`.\n\t\t*/\n\n\t\t/* Get the text values used for the labels */\n\t\tvar tickLabels = map(chartProps.data[0].values, function(d) {\n\t\t\treturn d.entry;\n\t\t});\n\n\t\t/* render a hidden SVG to get the width of the y axis labels */\n\t\thiddenSvg.push(\n\t\t\tReact.createElement(HiddenSvg.HiddenSvgAxis, {\n\t\t\t\tclassName: \"tick\", \n\t\t\t\tchartWidth: dimensions.width, \n\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\tformattedText: tickLabels, \n\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset, \n\t\t\t\tonUpdate: this._handleStateUpdate.bind(null, \"maxTickWidth\"), \n\t\t\t\tkey: \"hiddenText\"}\n\t\t\t)\n\t\t);\n\n\t\tif (this.state.maxTickWidth <= 0) {\n\t\t\t// We have not yet calculated maxTickWidth\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", null, hiddenSvg)\n\t\t\t);\n\t\t}\n\n\t\t/*\n\t\t * A second hidden SVG is rendered to calculate whether the labels to the\n\t\t * right of bars exceed the width of the chart area. This is set to\n\t\t * `this.state.barLabelOverlap` and will be passed to the `GridChart`.\n\t\t*/\n\t\tvar barLabels = reduce(chartProps.data, function(arr, d) {\n\t\t\treturn map(d.values, function(val, i) {\n\t\t\t\tvar formatted = format_bar_labels(val.value);\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tformatted = scale.prefix + formatted + scale.suffix;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tvalue: val.value,\n\t\t\t\t\tformatted: formatted\n\t\t\t\t};\n\t\t\t}).concat(arr);\n\t\t}, []);\n\n\t\t/* Relative position of chart area, used to place hidden labels correctly */\n\t\tvar offset = {\n\t\t\tleft: displayConfig.padding.left + displayConfig.margin.left,\n\t\t\tright: displayConfig.padding.right + displayConfig.margin.right\n\t\t};\n\n\t\thiddenSvg.push(\n\t\t\tReact.createElement(HiddenSvg.HiddenSvgBarLabels, {\n\t\t\t\tclassName: \"concealer-label\", \n\t\t\t\tlabelOverlap: this.state.barLabelOverlap, \n\t\t\t\tchartWidth: dimensionsPerGrid.width, \n\t\t\t\tmargin: displayConfig.margin, \n\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset + 5, \n\t\t\t\tformattedText: barLabels, \n\t\t\t\tscale: scale, \n\t\t\t\toffset: offset, \n\t\t\t\tonUpdate: this._handleStateUpdate.bind(null, \"barLabelOverlap\"), \n\t\t\t\tkey: \"hiddenLabel\"}\n\t\t\t)\n\t\t);\n\n\t\tvar gridCharts = map(chartProps.data.slice(0, numCharts), function(d, i) {\n\t\t\t// Get the props we need for each chart\n\t\t\tvar gridChartProps = {\n\t\t\t\tchartSettings: chartProps.chartSettings[i],\n\t\t\t\tdata: [d],\n\t\t\t\tscale: chartProps.scale,\n\t\t\t\tmargin: this.props.displayConfig.margin,\n\t\t\t\textraPadding: extraPadding\n\t\t\t};\n\n\t\t\treturn React.createElement(GridChart, {\n\t\t\t\tchartProps: gridChartProps, \n\t\t\t\trendererFunc: drawBarChartGrid, \n\t\t\t\tdisplayConfig: displayConfig, \n\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\tkey: i, \n\t\t\t\tindex: i, \n\t\t\t\tbarLabelOverlap: this.state.barLabelOverlap, \n\t\t\t\tgrid: chartProps._grid, \n\t\t\t\tdimensions: dimensionsPerGrid, \n\t\t\t\tpadding: displayConfig.padding}\n\t\t\t)\n\t\t}, this);\n\n\t\t/*\n\t\t * Pass the following JSX components to the `Svg` component, which will\n\t\t * render all SVG. See `../svg/Svg.jsx`.\n\t\t*/\n\t\tvar chartComponents = [\n\t\t];\n\n\t\treturn (\n\t\t\tReact.createElement(\"g\", null, \n\t\t\t\tReact.createElement(\"g\", {key: \"chart-wrapper\", className: \"renderer-chart-wrapper\"}, \n\t\t\t\t\tgridCharts\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"g\", {key: \"chart-annotations\", className: \"chart-annotations\"}), \n\t\t\t\thiddenSvg \n\t\t\t)\n\t\t);\n\t}\n});\n\nmodule.exports = ChartGridBars;\n\n/* Use d4 to actually draw the chart */\nfunction drawBarChartGrid(el, state) {\n\t// We are not able to modify an existing chart because a d4 `mixout` does not\n\t// remove a previously existing element. So we must delete the dom element\n\t// before rendering\n\t// TODO: look into adding this feature to d4\n\tif (el.childNodes[0]) {\n\t\tel.removeChild(el.childNodes[0]);\n\t}\n\n\tvar chartProps = state.chartProps;\n\tvar scale = chartProps.scale;\n\tvar colorIndex = chartProps.chartSettings.colorIndex;\n\tvar gridType = state.grid.type;\n\tvar styleConfig = state.styleConfig;\n\n\tvar chart = cb_bar_grid()\n\t\t.outerHeight(state.dimensions.height)\n\t\t.margin(chartProps.margin)\n\t\t.padding(state.padding)\n\n\tchart\n\t.using(\"series-label\",function(lab){\n\t\tlab.afterRender(function() {\n\t\t\tthis.container.selectAll(\"text.label\")\n\t\t\t\t.each(function(d,i) {\n\t\t\t\t\tvar index = !isNaN(colorIndex) ? colorIndex : i;\n\t\t\t\t\td3.select(this).attr(\"data-color-index\", index);\n\t\t\t\t});\n\t\t});\n\t})\n\t//TODO: make the rangeband the ratio of barheight to bargap\n\t.y(function(y) {\n\t\ty.key(\"entry\").rangeBands([\n\t\t\tthis.padding.top + state.displayConfig.afterLegend,\n\t\t\tthis.height - this.padding.bottom\n\t\t]);\n\t})\n\t.mixout(\"xAxis\")\n\t.chartAreaOnTop(true)\n\t.using(\"bars\", function(bar) {\n\t\tbar.height(state.displayConfig.barHeight);\n\t\tbar.y(function(d) {\n\t\t\t// Offset y placement based on bar height\n\t\t\tvar axis = this.y;\n\t\t\treturn (axis(d[axis.$key]) + axis.rangeBand() / 2) - (state.displayConfig.barHeight / 2);\n\t\t});\n\t\tbar.afterRender(function() {\n\t\t\tthis.container.selectAll(\"rect.bar\")\n\t\t\t\t.each(function(d,i) {\n\t\t\t\t\tvar index = !isNaN(colorIndex) ? colorIndex : i;\n\t\t\t\t\td3.select(this).attr(\"data-color-index\", index);\n\t\t\t\t});\n\t\t});\n\t})\n\t.using(\"concealer_label\",function(lab) {\n\t\tlab\n\t\t\t.stagger(false)\n\t\t\t.x(function(d) {\n\t\t\t\tvar val = d[this.x.$key] || 0;\n\t\t\t\treturn this.x(Math.max(val, 0)) + 6;\n\t\t\t})\n\t\t\t.y(function(d) {\n\t\t\t\treturn (this.y(d[this.y.$key]) + this.y.rangeBand() / 2);\n\t\t\t})\n\t\t\t.format(function(d,i) {\n\t\t\t\tif (i !== 0) {\n\t\t\t\t\treturn format_bar_labels(d);\n\t\t\t\t} else {\n\t\t\t\t\treturn scale.primaryScale.prefix + format_bar_labels(d) + scale.primaryScale.suffix;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.dy(function(d,i) {\n\t\t\t\treturn \"0.36em\";\n\t\t\t})\n\t\t\t.text(function(d, i) {\n\t\t\t\treturn d.value;\n\t\t\t});\n\t});\n\n\tif (state.positions.x === 0) {\n\t\t// The left-most bar, which contatins axis ticks\n\t\tchart = left_bar(chart, state);\n\t} else {\n\t\t// Bars to the right\n\t\tchart = right_bar(chart, state);\n\t}\n\n\td3.select(el)\n\t\t.append(\"g\")\n\t\t.datum(chartProps.data)\n\t\t.call(chart);\n}\n\nfunction left_bar(_chart, state) {\n\tvar chartProps = state.chartProps;\n\n\t_chart.extraPadding({\n\t\ttop: 0,\n\t\tleft: chartProps.extraPadding.left,\n\t\tbottom: chartProps.extraPadding.bottom,\n\t\tright: chartProps.extraPadding.right + state.barLabelOverlap\n\t})\n\t.outerWidth(state.dimensions.width + chartProps.extraPadding.left)\n\t.mixout(\"no-label-tick\")\n\t.using(\"leftAxis\", function(axis) {\n\t\taxis.orient(\"left\");\n\t\taxis.align(\"left\")\n\t\taxis.innerTickSize(\n\t\t\tbar_tick_size(state)\n\t\t);\n\t})\n\t.x(function(x) {\n\t\tx.key(\"value\").domain(chartProps.scale.primaryScale.domain);\n\t\tx.range([this.padding.left + state.styleConfig.xOverTick, this.outerWidth - this.padding.right])\n\t})\n\n\treturn _chart;\n}\n\nfunction right_bar(_chart, state) {\n\tvar chartProps = state.chartProps;\n\n\t_chart.extraPadding({\n\t\ttop: 0,\n\t\tleft: 0,\n\t\tbottom: chartProps.extraPadding.bottom,\n\t\tright: chartProps.extraPadding.right + state.barLabelOverlap\n\t})\n\t.outerWidth(state.dimensions.width)\n\t.mixout(\"leftAxis\")\n\t.using(\"no-label-tick\", function(line) {\n\t\tline.x2(function() {\n\t\t\treturn bar_tick_size(state);\n\t\t});\n\t})\n\t.x(function(x) {\n\t\tx.key(\"value\").domain(chartProps.scale.primaryScale.domain)\n\t\tx.range([0, this.outerWidth - this.padding.right - state.styleConfig.xOverTick])\n\t});\n\n\treturn _chart;\n}\n\n// The ticks on the rightmost bar (including if there's only a single one)\n// should not extend the full width of their chart area. All others should.\nfunction bar_tick_size(state) {\n\treturn 8;\n\t//if(state.positions.x === (state.grid.cols - 1)) {\n\t\t//return state.dimensions.width -\n\t\t//state.chartProps.margin.right -\n\t\t//state.chartProps.margin.left;\n\t//}\n\t//else {\n\t\t//return state.dimensions.width;\n\t//}\n}\n\nfunction format_bar_labels(label) {\n\tif (label === null) {\n\t\treturn \"no data\";\n\t} else {\n\t\treturn formatThousands(label);\n\t}\n}",
                  "path": "src/js/components/chart-grid/ChartGridBars.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridBars.jsx#L40-L216"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "editable"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridRenderer",
                "name": "ChartGridBars",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "ChartGridRenderer",
                  "ChartGridBars"
                ]
              },
              {
                "description": "### Component that renders xy charts in a chart grid",
                "tags": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "editable"
                  },
                  {
                    "title": "property",
                    "description": "Parsed global style config",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "styleConfig"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridRenderer"
                  },
                  {
                    "title": "name",
                    "name": "ChartGridXY"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 36,
                      "column": 0
                    },
                    "end": {
                      "line": 197,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/ChartGridXY.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar d4 = require(\"d4\");\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar filter = require(\"lodash/collection/filter\");\n\n/* Helper functions */\nvar cb_xy = require(\"../../charts/cb-charts\").cb_xy;\nvar help = require(\"../../util/helper.js\");\n\n/* Renderer mixins */\nvar ChartRendererMixin = require(\"../mixins/ChartRendererMixin.js\");\n\n/* Svg components */\nvar HiddenSvg = require(\"../svg/HiddenSvg.jsx\");\n\n/* One `GridChart` will be drawn for every column used in our grid */\nvar GridChart = require(\"./GridChart.jsx\");\n\n/**\n * ### Component that renders xy charts in a chart grid\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} styleConfig - Parsed global style config\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @instance\n * @memberof ChartGridRenderer\n */\nvar ChartGridXY = React.createClass({displayName: \"ChartGridXY\",\n\n\tpropTypes: {\n\t\teditable: PropTypes.bool.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.obj,\n\t\t\tpadding: PropTypes.obj\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_grid: PropTypes.object.isRequired\n\t\t}).isRequired\n\t},\n\n\tmixins: [ChartRendererMixin],\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tmaxTickWidth: 0, // widest y axis tick, needed to compute padding\n\t\t\textraHeight: 0 // height added to chart by wrapped source line\n\t\t};\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\t// Don't render if data is for some reason unavailable\n\t\tif (nextProps.chartProps.data) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar chartProps = update(this.props.chartProps, { $merge: {\n\t\t\tdata: this._applySettingsToData(this.props.chartProps, { altAxis: false }),\n\t\t\tscale: this.props.scale\n\t\t}});\n\n\t\tvar displayConfig = this.props.displayConfig;\n\t\txyConfig = displayConfig.xy;\n\n\t\tvar hiddenSvg = [];\n\n\t\t/*\n\t\t * Set `extraPadding.left` to the width of the widest axis tick.\n\t\t * Add extraHeight to the bottom if there is height added by source wrapping\n\t\t*/\n\t\tvar extraPadding = {\n\t\t\ttop: chartProps.extraPadding.top,\n\t\t\tright: chartProps.extraPadding.right + displayConfig.afterXYRight,\n\t\t\tbottom: chartProps.extraPadding.bottom + this.state.extraHeight,\n\t\t\tleft: this.state.maxTickWidth\n\t\t};\n\n\t\tvar dimensions = clone(this.props.dimensions);\n\n\t\tif (this.props.hasTitle) {\n\t\t\textraPadding.top = extraPadding.top + displayConfig.afterTitle;\n\t\t}\n\n\t\t/* Divide total width by number of grids, also subtracting the spade to be\n\t\t* used to the right of a chart */\n\t\tvar dimensionsPerGrid = {\n\t\t\twidth: (dimensions.width - this.state.maxTickWidth - displayConfig.afterXYRight) / chartProps._grid.cols\n\t\t};\n\n\t\t/*\n\t\t * Render a hidden set of SVG axis labels in order to find out the\n\t\t * maximum width the labels will take up. Doing this in a hidden component\n\t\t * cuts down on the number of chart redraws. The max width is set to this\n\t\t * component as `this.state.maxTickWidth`.\n\t\t*/\n\t\tvar currScale = chartProps.scale.primaryScale;\n\n\t\t/*\n\t\t * Get the tick values so that we can pass them both to the actual chart\n\t\t * renderer and to the component that will render hidden ticks\n\t\t*/\n\t\tvar tickValues = help.exactTicks(currScale.domain, currScale.ticks);\n\n\t\t/* We dont want to check against the first value */\n\t\tvar skipFirstValue = filter(tickValues, function(d) {\n\t\t\treturn (d !== currScale.domain[1]);\n\t\t});\n\n\t\tvar formattedTicks = map(skipFirstValue, function(tick) {\n\t\t\treturn help.roundToPrecision(tick, currScale.precision);\n\t\t});\n\n\t\tvar axisTicks = {\n\t\t\tname: \"scale\",\n\t\t\ttickValues: tickValues,\n\t\t\tformattedTicks: formattedTicks,\n\t\t\tprecision: currScale.precision,\n\t\t\tmax: currScale.domain[1]\n\t\t};\n\n\t\t/*\n\t\t * Render hidden y-axis ticks in order to compute the maxTickWidth\n\t\t * independent of rendering the chart itself, this is needed to set the\n\t\t * appropriate padding for the chart. We must do this for each y-axis.\n\t\t*/\n\t\thiddenSvg.push(\n\t\t\tReact.createElement(HiddenSvg.HiddenSvgAxis, {\n\t\t\t\tclassName: \"tick\", \n\t\t\t\tchartWidth: dimensions.width, \n\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\tformattedText: axisTicks.formattedTicks, \n\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset, \n\t\t\t\tkey: \"hidden-ticks\", \n\t\t\t\tonUpdate: this._handleStateUpdate.bind(null, \"maxTickWidth\")}\n\t\t\t)\n\t\t);\n\n\t\t/* Width and height of each grid block */\n\t\tvar paddingAfterOffset = (xyConfig.padding.bottom - displayConfig.afterXYBottom) / chartProps._grid.rows;\n\n\t\tdimensionsPerGrid.width = dimensionsPerGrid.width - displayConfig.afterXYRight;\n\t\tdimensionsPerGrid.height =\n\t\t\t(dimensions.height - this.state.extraHeight - extraPadding.top - paddingAfterOffset) /\n\t\t\tchartProps._grid.rows;\n\n\t\t/* Get the number of charts and only render that many */\n\t\tvar numCharts = chartProps._grid.rows * chartProps._grid.cols;\n\t\tvar gridCharts = map(chartProps.data.slice(0, numCharts), function(d, i) {\n\t\t\t// Get the props we need for each chart\n\t\t\tvar gridChartProps = {\n\t\t\t\tchartSettings: chartProps.chartSettings[i],\n\t\t\t\tdata: [d],\n\t\t\t\tscale: chartProps.scale,\n\t\t\t\tmargin: this.props.displayConfig.margin,\n\t\t\t\textraPadding: extraPadding\n\t\t\t};\n\n\t\t\treturn React.createElement(GridChart, {\n\t\t\t\tchartProps: gridChartProps, \n\t\t\t\tkey: i, \n\t\t\t\tindex: i, \n\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\trendererFunc: drawXYChartGrid, \n\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\tbarLabelOverlap: this.state.barLabelOverlap, \n\t\t\t\tgrid: chartProps._grid, \n\t\t\t\tdimensions: dimensionsPerGrid, \n\t\t\t\tpadding: displayConfig.padding}\n\t\t\t)\n\t\t}, this);\n\n\t\treturn (\n\t\t\tReact.createElement(\"g\", null, \n\t\t\t\tReact.createElement(\"g\", {ref: \"gridCharts\", key: \"chart-wrapper\", className: \"renderer-chart-wrapper\"}, \n\t\t\t\t\tgridCharts\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"g\", {key: \"chart-annotations\", className: \"chart-annotations\"}), \n\t\t\t\thiddenSvg\n\t\t\t)\n\t\t);\n\t}\n});\n\nfunction drawXYChartGrid(el, state) {\n\t// clear the previous d4 chart if necessary\n\t// TODO: this is not working otherwise because a d4 `mixout` does not remove\n\t// a previously existing element. look into adding this feature\n\n\tif (el.childNodes[0]) {\n\t\tel.removeChild(el.childNodes[0]);\n\t}\n\n\tvar chartProps = state.chartProps;\n\tvar scale = chartProps.scale;\n\tvar displayConfig = state.displayConfig;\n\tvar styleConfig = state.styleConfig;\n\tvar colorIndex = chartProps.chartSettings.colorIndex;\n\tvar gridType = state.grid.type;\n\tvar dateSettings = state.dateSettings;\n\n\txyConfig = displayConfig.xy;\n\n\tvar chart = cb_xy()\n\t\t.outerHeight(state.dimensions.height)\n\t\t.margin(chartProps.margin)\n\n\tchartProps.data[0].type = gridType;\n\t// set right padding to zero for xy chartgrid\n\tchart.padding({\n\t\ttop: displayConfig.padding.top,\n\t\tright: 0,\n\t\tbottom: displayConfig.padding.bottom,\n\t\tleft: displayConfig.padding.left\n\t})\n\n\tvar extraPadding = {\n\t\ttop: 0,\n\t\tright: 0\n\t};\n\n\t// If this is the bottom row (or the top row in a one-row grid), apply XY\n\t// bottom padding and add it back to the height, accounting for chartGrid\n\t// afterXY setting\n\tif ((state.positions.y === 0) && (state.grid.rows === 1)) {\n\t\textraPadding.bottom = xyConfig.padding.bottom;\n\t\tchart.outerHeight(state.dimensions.height + xyConfig.padding.bottom - displayConfig.afterLegend);\n\t} else if (state.positions.y === state.grid.rows - 1) {\n\t\textraPadding.bottom = xyConfig.padding.bottom;\n\t\tchart.outerHeight(state.dimensions.height + (Math.abs(xyConfig.padding.bottom - displayConfig.afterXYBottom)));\n\t} else {\n\t\t// Otherwise for non-bottom-row grids, apply afterXY for bottom padding\n\t\textraPadding.bottom = displayConfig.afterXYBottom;\n\t}\n\n\tif (state.positions.x === 0) {\n\t\tchart.using(\"series-label\",function(lab){\n\t\t\tlab.x(function() {\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t\tlab.afterRender(function() {\n\t\t\t\tthis.container.selectAll(\"text.label\")\n\t\t\t\t\t.each(function(d,i) {\n\t\t\t\t\t\tvar index = !isNaN(colorIndex) ? colorIndex : i;\n\t\t\t\t\t\td3.select(this).attr(\"data-color-index\", index);\n\t\t\t\t\t});\n\t\t\t})\n\t\t})\n\t\t.using(\"leftAxis\", function(axis){\n\t\t\tyAxisUsing.call(this, \"primary\", axis, state);\n\t\t})\n\t\t.outerWidth(state.dimensions.width + chartProps.extraPadding.left);\n\t\t// set tick width to left padding for first row\n\t\textraPadding.left = chartProps.extraPadding.left;\n\t\tchart.extraPadding(extraPadding);\n\t} else {\n\t\tchart\n\t\t.outerWidth(state.dimensions.width)\n\t\t.using(\"series-label\",function(lab){\n\t\t\tlab.x(function() {\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t\tlab.afterRender(function() {\n\t\t\t\tthis.container.selectAll(\"text.label\")\n\t\t\t\t\t.each(function(d,i) {\n\t\t\t\t\t\tvar index = !isNaN(colorIndex) ? colorIndex : i;\n\t\t\t\t\t\td3.select(this).attr(\"data-color-index\", index);\n\t\t\t\t\t});\n\t\t\t});\n\t\t})\n\t\t.using(\"leftAxis\", function(axis){\n\t\t\taxis.innerTickSize(state.dimensions.width);\n\t\t\taxis.tickValues(help.exactTicks(scale.primaryScale.domain, scale.primaryScale.ticks));\n\t\t\taxis.tickFormat(function() {\n\t\t\t\treturn \"\";\n\t\t\t});\n\t\t})\n\t\tchart.outerWidth(state.dimensions.width);\n\t\tchart.extraPadding(extraPadding);\n\t}\n\n\tchart\n\t.x(function(x) {\n\t\tx.key(\"entry\");\n\t\tvar rangeL = this.padding.left + styleConfig.xOverTick;\n\t\tvar rangeR = this.width - this.padding.right - (chartProps._numSecondaryAxis > 0 ? styleConfig.xOverTick : 0);\n\t\tif (state.hasColumn) {\n\t\t\trangeL += displayConfig.columnExtraPadding;\n\t\t\trangeR -= displayConfig.columnExtraPadding;\n\t\t}\n\t\tif (chartProps.scale.hasDate) {\n\t\t\tx.scale(\"time\");\n\t\t\tx.domain(dateSettings.domain);\n\t\t}\n\t\tx.range([rangeL, rangeR]);\n\t})\n\t.left(function(y) {\n\t\ty.key(\"value\")\n\t\t\t.domain(chartProps.scale.primaryScale.domain)\n\t\t\t.range([this.height - this.padding.bottom, this.padding.top + displayConfig.afterTitle]);\n\t})\n\t.chartAreaOnTop(false)\n\t.mixout(\"rightAxis\")\n\t.using(\"xAxis\", function(axis) {\n\t\tif (chartProps.scale.hasDate) {\n\t\t\taxis.tickValues(dateSettings.dateTicks);\n\t\t\taxis.tickFormat(function(d) {\n\t\t\t\treturn dateSettings.dateFormatter(d);\n\t\t\t});\n\t\t}\n\n\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t})\n\n\td3.select(el)\n\t\t.append(\"g\")\n\t\t.datum(chartProps.data)\n\t\t.call(chart);\n}\n\nfunction yAxisUsing(location, axis, state) {\n\tvar chartProps = state.chartProps;\n\tvar isPrimary = (location === \"primary\");\n\tvar scale = chartProps.scale;\n\n\taxis.tickValues(help.exactTicks(scale.primaryScale.domain, scale.primaryScale.ticks));\n\taxis.innerTickSize(state.dimensions.width);\n\n\tvar maxTickVal = d3.max(axis.tickValues());\n\taxis.tickFormat(function(d) {\n\t\tif (d == maxTickVal) {\n\t\t\treturn [\n\t\t\t\tscale.primaryScale.prefix,\n\t\t\t\thelp.roundToPrecision(d, scale.primaryScale.precision),\n\t\t\t\tscale.primaryScale.suffix\n\t\t\t].join(\"\");\n\t\t} else {\n\t\t\treturn help.roundToPrecision(d, scale.primaryScale.precision);\n\t\t}\n\t});\n}\n\n\nmodule.exports = ChartGridXY;",
                  "path": "src/js/components/chart-grid/ChartGridXY.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/ChartGridXY.jsx#L36-L197"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "boolean"
                    },
                    "name": "editable"
                  },
                  {
                    "title": "property",
                    "description": "Parsed global style config",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "styleConfig"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridRenderer",
                "name": "ChartGridXY",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "ChartGridRenderer",
                  "ChartGridXY"
                ]
              },
              {
                "description": "### Component that renders a single grid chart. One of these is rendered for each series in a chart grid",
                "tags": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "styleConfig"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  },
                  {
                    "title": "property",
                    "description": "Function that we will pass to grid to\ndraw the actual chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "rendererFunc"
                  },
                  {
                    "title": "property",
                    "description": "Settings for grid type, and number of columns/rows",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "grid"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "ChartGridRenderer"
                  },
                  {
                    "title": "name",
                    "name": "GridChart"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 26,
                      "column": 0
                    },
                    "end": {
                      "line": 162,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-grid/GridChart.jsx",
                  "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\nvar d4 = require(\"d4\");\n\n// Date parsing settings\nvar DateScaleMixin = require(\"../mixins/DateScaleMixin.js\");\n\n/**\n * ### Component that renders a single grid chart. One of these is rendered for each series in a chart grid\n * @property {object} styleConfig - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {function} rendererFunc - Function that we will pass to grid to\n * draw the actual chart\n * @property {object} grid - Settings for grid type, and number of columns/rows\n * @instance\n * @memberof ChartGridRenderer\n */\nvar GridChart = React.createClass({displayName: \"GridChart\",\n\n\tpropTypes: {\n\t\tindex: PropTypes.number.isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.object.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired\n\t\t}).isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\trendererFunc: PropTypes.func.isRequired,\n\t\tgrid: PropTypes.object.isRequired,\n\t\tpadding: PropTypes.object\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tpositions: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t}\n\t\t};\n\t},\n\n\tmixins: [DateScaleMixin],\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\t// Draw chart when updated\n\t\tvar el = this.getDOMNode();\n\t\tthis.props.rendererFunc(el, this._getChartState(nextProps, nextState));\n\t\treturn true;\n\t},\n\n\tcomponentWillMount: function() {\n\t\t// Set the position of this `GridChart`\n\t\tvar positions = this._computeGridPositions(this.props);\n\n\t\tthis.setState({\n\t\t\tpositions: positions\n\t\t});\n\t},\n\n\tcomponentDidMount: function() {\n\t\t// Draw chart once mounted\n\t\tvar el = this.getDOMNode();\n\n\t\tif (this.props.chartProps.data.length === 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tthis.props.rendererFunc(el, this._getChartState(this.props, this.state));\n\t\t}\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Update positions when new props are received\n\t\t// We do this in `componentWillReceiveProps` because it allows you to run\n\t\t// `setState` before the component renders, avoiding a double render\n\t\tvar positions = this._computeGridPositions(nextProps);\n\n\t\tthis.setState({\n\t\t\tpositions: positions\n\t\t});\n\t},\n\n\t_getChartState: function(props, state) {\n\n\t\tvar dateSettings;\n\t\t// Calculate date settings if date scale is being used\n\t\tif (props.chartProps.scale.hasDate) {\n\t\t\tdateSettings = this.generateDateScale(props);\n\t\t}\n\n\t\treturn {\n\t\t\tchartProps: props.chartProps,\n\t\t\tdimensions: props.dimensions,\n\t\t\tgrid: props.grid,\n\t\t\tstyleConfig: props.styleConfig,\n\t\t\tdisplayConfig: props.displayConfig,\n\t\t\thasColumn: (props.grid.type == \"column\"),\n\t\t\tbarLabelOverlap: props.barLabelOverlap,\n\t\t\tdateSettings: dateSettings,\n\t\t\tpositions: state.positions,\n\t\t\tpadding: props.padding,\n\t\t};\n\t},\n\n\t_computeGridPositions: function(props) {\n\t\t// Compute the position of each grid chart based on its index, the number\n\t\t// of rows and columns, and the dimensions of the chart. These return\n\t\t// [x,y] coordinates that correlate to its position in the grid, like so:\n\t\t//\n\t\t// ```\n\t\t// | 0,0 | 1,0 | 2,0 |\n\t\t// | 0,1 | 1,1 | 2,1 |\n\t\t// | 0,2 | 1,2 | 2,2 |\n\t\t// ```\n\t\t//\n\t\t// These values are then multiplied by the dimensions divided by number of\n\t\t// rows/cols to find the position in the SVG stage.\n\t\tvar grid = props.grid;\n\t\tvar ix = props.index;\n\n\t\treturn {\n\t\t\tx: ix % grid.cols,\n\t\t\ty: (ix === 0) ? 0 : Math.floor( ix / grid.cols )\n\t\t};\n\t},\n\n\trender: function() {\n\t\t// Draw `<svg:g>` for the chart and translate it to its positions\n\t\tvar chartProps = this.props.chartProps;\n\t\tvar translateY = 0;\n\t\tvar translateX = 0;\n\n\t\tif (this.state.positions.y > 0) {\n\t\t\ttranslateY =\n\t\t\t\tchartProps.extraPadding.top +\n\t\t\t\t(this.props.dimensions.height * this.state.positions.y);\n\t\t} else {\n\t\t\ttranslateY = chartProps.extraPadding.top;\n\t\t}\n\t\tif (this.state.positions.x > 0) {\n\t\t\ttranslateX =\n\t\t\t\tchartProps.extraPadding.left +\n\t\t\t\t(this.props.dimensions.width + chartProps.extraPadding.right) *\n\t\t\t\tthis.state.positions.x;\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tclassName: \"grid-chart-block\", \n\t\t\t\ttransform: \"translate(\" + [translateX, translateY] + \")\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n\nmodule.exports = GridChart;",
                  "path": "src/js/components/chart-grid/GridChart.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-grid/GridChart.jsx#L26-L162"
                },
                "properties": [
                  {
                    "title": "property",
                    "description": "Allow the rendered component to interacted with and edited",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "styleConfig"
                  },
                  {
                    "title": "property",
                    "description": "Parsed visual display configuration for chart grid",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "displayConfig"
                  },
                  {
                    "title": "property",
                    "description": "Properties used to draw this chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "chartProps"
                  },
                  {
                    "title": "property",
                    "description": "Function that we will pass to grid to\ndraw the actual chart",
                    "type": {
                      "type": "NameExpression",
                      "name": "function"
                    },
                    "name": "rendererFunc"
                  },
                  {
                    "title": "property",
                    "description": "Settings for grid type, and number of columns/rows",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "grid"
                  }
                ],
                "scope": "instance",
                "memberof": "ChartGridRenderer",
                "name": "GridChart",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "ChartGridRenderer",
                  "GridChart"
                ]
              }
            ],
            "static": []
          },
          "path": [
            "renderers",
            "ChartGridRenderer"
          ]
        },
        {
          "description": "### Functions common to chart renderers",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "renderers"
            },
            {
              "title": "name",
              "name": "ChartRendererMixin"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 11,
                "column": 0
              },
              "end": {
                "line": 46,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartRendererMixin.js",
            "code": "var React = require(\"react\");\nvar update = React.addons.update;\nvar assign = require(\"lodash/object/assign\");\nvar map = require(\"lodash/collection/map\");\n\n/**\n * ### Functions common to chart renderers\n * @instance\n * @memberof renderers\n */\nvar ChartRendererMixin = {\n\n\t/**\n\t * _applySettingsToData\n\t * Our d4 chart renderers expect any additional settings to be in the data\n\t * that is passed to it, so we merge them in (from a separate\n\t * `chartSettings` object). An optional `additional` parameter adds an\n\t * arbitray object to this\n\t * @param _chartProps - Current data and series settings\n\t * @param additional - Optional additional object to apply\n\t * @return {object} - Data with settings applied\n\t */\n\t_applySettingsToData: function(_chartProps, additional) {\n\t\treturn map(_chartProps.data, function(d, i) {\n\t\t\tvar series = {};\n\t\t\tseries.key = d.name;\n\t\t\tif (additional) {\n\t\t\t\tseries = assign(series, additional);\n\t\t\t}\n\t\t\treturn assign(series, d, _chartProps.chartSettings[i]);\n\t\t});\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the renderer component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t}\n\n};\n\nmodule.exports = ChartRendererMixin;",
            "path": "src/js/components/mixins/ChartRendererMixin.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartRendererMixin.js#L11-L46"
          },
          "scope": "instance",
          "memberof": "renderers",
          "name": "ChartRendererMixin",
          "kind": "function",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "_applySettingsToData\nOur d4 chart renderers expect any additional settings to be in the data\nthat is passed to it, so we merge them in (from a separate\n`chartSettings` object). An optional `additional` parameter adds an\narbitray object to this",
                "tags": [
                  {
                    "title": "param",
                    "description": "Current data and series settings",
                    "type": null,
                    "name": "_chartProps"
                  },
                  {
                    "title": "param",
                    "description": "Optional additional object to apply",
                    "type": null,
                    "name": "additional"
                  },
                  {
                    "title": "returns",
                    "description": "Data with settings applied",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    }
                  },
                  {
                    "title": "name",
                    "name": "_applySettingsToData"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "ChartRendererMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 23,
                      "column": 1
                    },
                    "end": {
                      "line": 32,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartRendererMixin.js",
                  "code": "{\n\n\t/**\n\t * _applySettingsToData\n\t * Our d4 chart renderers expect any additional settings to be in the data\n\t * that is passed to it, so we merge them in (from a separate\n\t * `chartSettings` object). An optional `additional` parameter adds an\n\t * arbitray object to this\n\t * @param _chartProps - Current data and series settings\n\t * @param additional - Optional additional object to apply\n\t * @return {object} - Data with settings applied\n\t */\n\t_applySettingsToData: function(_chartProps, additional) {\n\t\treturn map(_chartProps.data, function(d, i) {\n\t\t\tvar series = {};\n\t\t\tseries.key = d.name;\n\t\t\tif (additional) {\n\t\t\t\tseries = assign(series, additional);\n\t\t\t}\n\t\t\treturn assign(series, d, _chartProps.chartSettings[i]);\n\t\t});\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the renderer component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t}\n\n}",
                  "path": "src/js/components/mixins/ChartRendererMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartRendererMixin.js#L23-L32"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "Current data and series settings",
                    "type": null,
                    "name": "_chartProps"
                  },
                  {
                    "title": "param",
                    "description": "Optional additional object to apply",
                    "type": null,
                    "name": "additional"
                  }
                ],
                "returns": [
                  {
                    "title": "returns",
                    "description": "Data with settings applied",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    }
                  }
                ],
                "name": "_applySettingsToData",
                "kind": "function",
                "memberof": "ChartRendererMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "ChartRendererMixin",
                  "_applySettingsToData"
                ]
              },
              {
                "description": "_handleStateUpdate\nUpdate a key in the renderer component's state",
                "tags": [
                  {
                    "title": "param",
                    "description": "`this.state` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`this.state` value",
                    "type": null,
                    "name": "v"
                  },
                  {
                    "title": "name",
                    "name": "_handleStateUpdate"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "ChartRendererMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 40,
                      "column": 1
                    },
                    "end": {
                      "line": 44,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/ChartRendererMixin.js",
                  "code": "{\n\n\t/**\n\t * _applySettingsToData\n\t * Our d4 chart renderers expect any additional settings to be in the data\n\t * that is passed to it, so we merge them in (from a separate\n\t * `chartSettings` object). An optional `additional` parameter adds an\n\t * arbitray object to this\n\t * @param _chartProps - Current data and series settings\n\t * @param additional - Optional additional object to apply\n\t * @return {object} - Data with settings applied\n\t */\n\t_applySettingsToData: function(_chartProps, additional) {\n\t\treturn map(_chartProps.data, function(d, i) {\n\t\t\tvar series = {};\n\t\t\tseries.key = d.name;\n\t\t\tif (additional) {\n\t\t\t\tseries = assign(series, additional);\n\t\t\t}\n\t\t\treturn assign(series, d, _chartProps.chartSettings[i]);\n\t\t});\n\t},\n\n\t/**\n\t * _handleStateUpdate\n\t * Update a key in the renderer component's state\n\t * @param k - `this.state` key\n\t * @param v - `this.state` value\n\t */\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t}\n\n}",
                  "path": "src/js/components/mixins/ChartRendererMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/ChartRendererMixin.js#L40-L44"
                },
                "params": [
                  {
                    "title": "param",
                    "description": "`this.state` key",
                    "type": null,
                    "name": "k"
                  },
                  {
                    "title": "param",
                    "description": "`this.state` value",
                    "type": null,
                    "name": "v"
                  }
                ],
                "name": "_handleStateUpdate",
                "kind": "function",
                "memberof": "ChartRendererMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "ChartRendererMixin",
                  "_handleStateUpdate"
                ]
              }
            ]
          },
          "path": [
            "renderers",
            "ChartRendererMixin"
          ]
        },
        {
          "description": "### Mixin for renderers that require construction of a date scale",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "renderers"
            },
            {
              "title": "name",
              "name": "DateScaleMixin"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 11,
                "column": 0
              },
              "end": {
                "line": 61,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/DateScaleMixin.js",
            "code": "var clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar processDates = require(\"../../util/process-dates\");\n\n/**\n * ### Mixin for renderers that require construction of a date scale\n * @instance\n * @memberof renderers\n */\nvar DateScaleMixin = {\n\n\t/**\n\t * generateDateScale\n\t * Create a date scale given data, scale, and dimensions settings\n\t * @param props\n\t * @return {object} - `{ dateTicks: ...,  domain: ..., dateFormatter: ...}`\n\t */\n\tgenerateDateScale: function(props) {\n\t\t// Return the ticks used for a time scale based on the time span and settings\n\t\tvar formatAndFreq = {};\n\t\tvar _dateSettings = clone(props.chartProps.scale.dateSettings, true);\n\t\tvar dateFormat = _dateSettings.dateFormat;\n\t\tvar dateFrequency = _dateSettings.dateFrequency;\n\n\t\t// Create a flat array of all dates so that we know that we can calculate\n\t\t// the earliest and latest\n\t\tvar allDates = reduce(props.chartProps.data, function(prevArr, series) {\n\t\t\treturn map(series.values, function(values) {\n\t\t\t\treturn values.entry;\n\t\t\t}).concat(prevArr);\n\t\t}, []);\n\n\t\tvar dateRange = d3.extent(allDates);\n\t\tvar minDate = dateRange[0];\n\t\tvar maxDate = dateRange[1];\n\n\t\tvar extraPadding = props.chartProps.extraPadding;\n\t\tvar width = props.dimensions.width;\n\t\tvar availableWidth = props.dimensions.width - extraPadding.left - extraPadding.right;\n\t\tvar autoSettings = processDates.autoDateFormatAndFrequency(minDate, maxDate, dateFormat, availableWidth);\n\n\t\tif (dateFrequency !== \"auto\") {\n\t\t\tvar freqSettings = processDates.dateFrequencies[dateFrequency];\n\t\t\tformatAndFreq.frequency = freqSettings(minDate, maxDate);\n\t\t} else {\n\t\t\tformatAndFreq.frequency = autoSettings.frequency;\n\t\t}\n\t\tif (dateFormat !== \"auto\") {\n\t\t\tformatAndFreq.format = dateFormat;\n\t\t} else {\n\t\t\tformatAndFreq.format = autoSettings.format;\n\t\t}\n\n\t\treturn {\n\t\t\tdateTicks: formatAndFreq.frequency,\n\t\t\tdomain: [minDate, maxDate],\n\t\t\tdateFormatter: processDates.dateParsers[formatAndFreq.format]\n\t\t};\n\t}\n};\n\nmodule.exports = DateScaleMixin;",
            "path": "src/js/components/mixins/DateScaleMixin.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/DateScaleMixin.js#L11-L61"
          },
          "scope": "instance",
          "memberof": "renderers",
          "name": "DateScaleMixin",
          "kind": "function",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "generateDateScale\nCreate a date scale given data, scale, and dimensions settings",
                "tags": [
                  {
                    "title": "param",
                    "description": null,
                    "type": null,
                    "name": "props"
                  },
                  {
                    "title": "returns",
                    "description": "`{ dateTicks: ...,  domain: ..., dateFormatter: ...}`",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    }
                  },
                  {
                    "title": "name",
                    "name": "generateDateScale"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  },
                  {
                    "title": "memberof",
                    "description": "DateScaleMixin"
                  },
                  {
                    "title": "static"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 19,
                      "column": 1
                    },
                    "end": {
                      "line": 60,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/mixins/DateScaleMixin.js",
                  "code": "{\n\n\t/**\n\t * generateDateScale\n\t * Create a date scale given data, scale, and dimensions settings\n\t * @param props\n\t * @return {object} - `{ dateTicks: ...,  domain: ..., dateFormatter: ...}`\n\t */\n\tgenerateDateScale: function(props) {\n\t\t// Return the ticks used for a time scale based on the time span and settings\n\t\tvar formatAndFreq = {};\n\t\tvar _dateSettings = clone(props.chartProps.scale.dateSettings, true);\n\t\tvar dateFormat = _dateSettings.dateFormat;\n\t\tvar dateFrequency = _dateSettings.dateFrequency;\n\n\t\t// Create a flat array of all dates so that we know that we can calculate\n\t\t// the earliest and latest\n\t\tvar allDates = reduce(props.chartProps.data, function(prevArr, series) {\n\t\t\treturn map(series.values, function(values) {\n\t\t\t\treturn values.entry;\n\t\t\t}).concat(prevArr);\n\t\t}, []);\n\n\t\tvar dateRange = d3.extent(allDates);\n\t\tvar minDate = dateRange[0];\n\t\tvar maxDate = dateRange[1];\n\n\t\tvar extraPadding = props.chartProps.extraPadding;\n\t\tvar width = props.dimensions.width;\n\t\tvar availableWidth = props.dimensions.width - extraPadding.left - extraPadding.right;\n\t\tvar autoSettings = processDates.autoDateFormatAndFrequency(minDate, maxDate, dateFormat, availableWidth);\n\n\t\tif (dateFrequency !== \"auto\") {\n\t\t\tvar freqSettings = processDates.dateFrequencies[dateFrequency];\n\t\t\tformatAndFreq.frequency = freqSettings(minDate, maxDate);\n\t\t} else {\n\t\t\tformatAndFreq.frequency = autoSettings.frequency;\n\t\t}\n\t\tif (dateFormat !== \"auto\") {\n\t\t\tformatAndFreq.format = dateFormat;\n\t\t} else {\n\t\t\tformatAndFreq.format = autoSettings.format;\n\t\t}\n\n\t\treturn {\n\t\t\tdateTicks: formatAndFreq.frequency,\n\t\t\tdomain: [minDate, maxDate],\n\t\t\tdateFormatter: processDates.dateParsers[formatAndFreq.format]\n\t\t};\n\t}\n}",
                  "path": "src/js/components/mixins/DateScaleMixin.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/mixins/DateScaleMixin.js#L19-L60"
                },
                "params": [
                  {
                    "title": "param",
                    "description": null,
                    "type": null,
                    "name": "props"
                  }
                ],
                "returns": [
                  {
                    "title": "returns",
                    "description": "`{ dateTicks: ...,  domain: ..., dateFormatter: ...}`",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    }
                  }
                ],
                "name": "generateDateScale",
                "kind": "function",
                "memberof": "DateScaleMixin",
                "scope": "static",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "DateScaleMixin",
                  "generateDateScale"
                ]
              }
            ]
          },
          "path": [
            "renderers",
            "DateScaleMixin"
          ]
        },
        {
          "description": "### Component that renders XY (line, column, dot) charts",
          "tags": [
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "editable"
            },
            {
              "title": "property",
              "description": "Parsed visual display configuration for chart grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "displayConfig"
            },
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Title, data source, etc",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "metadata"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "renderers"
            },
            {
              "title": "name",
              "name": "XYRenderer"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 47,
                "column": 0
              },
              "end": {
                "line": 225,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYRenderer.jsx",
            "code": "var React = require(\"react\");\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\n// Node modules\nvar d3 = require(\"d3\");\nvar d4 = require(\"d4\");\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar assign = require(\"lodash/object/assign\");\nvar each = require(\"lodash/collection/each\");\nvar filter = require(\"lodash/collection/filter\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar some = require(\"lodash/collection/some\");\n\nvar ChartRendererMixin = require(\"../mixins/ChartRendererMixin.js\");\nvar DateScaleMixin = require(\"../mixins/DateScaleMixin.js\");\n\n// Flux actions\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\n// Svg components\nvar SvgRectLabel = require(\"../svg/SvgRectLabel.jsx\");\nvar HiddenSvg = require(\"../svg/HiddenSvg.jsx\");\n\n// Helpers\nvar cb_xy = require(\"../../charts/cb-charts\").cb_xy;\nvar help = require(\"../../util/helper.js\");\n\nvar scaleNames = [\"primaryScale\", \"secondaryScale\"];\n\n/**\n * ### Component that renders XY (line, column, dot) charts\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {object} metadata - Title, data source, etc\n * @instance\n * @memberof renderers\n */\nvar XYRenderer = React.createClass({displayName: \"XYRenderer\",\n\n\tpropTypes: {\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.object.isRequired,\n\t\t\tpadding: PropTypes.object.isRequired,\n\t\t\tlabelRectSize: PropTypes.number.isRequired,\n\t\t\tafterLegend: PropTypes.number.isRequired\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_annotations: PropTypes.object,\n\t\t\tdate: PropTypes.object,\n\t\t\tmobile: PropTypes.object\n\t\t}).isRequired,\n\t\tmetadata: PropTypes.object,\n\t\tshowMetadata: PropTypes.bool,\n\t\teditable: PropTypes.bool,\n\t\tuseMobileSettings: PropTypes.bool\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tlabelYMax: 0,\n\t\t\tmaxTickWidth: {\n\t\t\t\tprimaryScale: 0,\n\t\t\t\tsecondaryScale: 0\n\t\t\t}\n\t\t};\n\t},\n\n\tmixins: [ChartRendererMixin],\n\n\t_handleMaxTickWidth: function(k, v) {\n\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\tmaxTickWidth[k] = v;\n\t\tthis._handleStateUpdate(\"maxTickWidth\", maxTickWidth);\n\t},\n\n\t_updateLabelYMax: function(labelYMax) {\n\t\tthis.setState({ labelYMax: labelYMax });\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tif (nextProps.chartProps._numSecondaryAxis === 0) {\n\t\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\t\tmaxTickWidth.secondaryScale = 0;\n\t\t\tthis.setState({ maxTickWidth: maxTickWidth });\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar _chartProps = this.props.chartProps;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar axis = d3.svg.axis();\n\t\tvar axisTicks = [];\n\t\tvar labelComponents;\n\t\tvar dimensions = this.props.dimensions;\n\n\t\t// Dimensions of the chart area\n\t\tvar chartAreaDimensions = {\n\t\t\twidth: (dimensions.width -\n\t\t\t\t\t\t\tdisplayConfig.margin.left - displayConfig.margin.right -\n\t\t\t\t\t\t\tdisplayConfig.padding.left - displayConfig.padding.right -\n\t\t\t\t\t\t\tthis.state.maxTickWidth.primaryScale - this.state.maxTickWidth.secondaryScale),\n\t\t\theight: (dimensions.height -\n\t\t\t\t\t\t\t displayConfig.margin.top - displayConfig.margin.bottom -\n\t\t\t\t\t\t\t displayConfig.padding.top - displayConfig.padding.bottom)\n\t\t};\n\n\t\tif (this.props.enableResponsive && _chartProps.hasOwnProperty(\"mobile\") && this.props.isSmall) {\n\t\t\tif (_chartProps.mobile.scale) {\n\t\t\t\tscale = assign({}, _chartProps.scale, _chartProps.mobile.scale);\n\t\t\t} else {\n\t\t\t\tscale = _chartProps.scale;\n\t\t\t}\n\t\t} else {\n\t\t\tscale = _chartProps.scale;\n\t\t}\n\n\t\t// apply `chartSettings` to data\n\t\tvar dataWithSettings = this._applySettingsToData(_chartProps);\n\t\t// compute margin based on existence of labels and title, based on default\n\t\t// margin set in config\n\t\tvar labels = _chartProps._annotations.labels;\n\t\tvar hasTitle = (this.props.metadata.title.length > 0 && this.props.showMetadata);\n\n\t\t// compute the max tick width for each scale\n\t\teach(scaleNames, function(scaleKey) {\n\t\t\tvar currScale = scale[scaleKey];\n\n\t\t\tif (currScale) {\n\t\t\t\t// get the tick values so that we can pass them both to the actual chart\n\t\t\t\t// renderer and to the component that will render hidden ticks\n\t\t\t\tvar tickValues = currScale.tickValues;\n\n\t\t\t\tvar skipFirstNode = filter(tickValues, function(d) {\n\t\t\t\t\treturn (d !== currScale.domain[1]);\n\t\t\t\t});\n\n\t\t\t\tvar formattedTicks = map(skipFirstNode, function(tick) {\n\t\t\t\t\treturn help.roundToPrecision(tick, currScale.precision);\n\t\t\t\t});\n\n\t\t\t\taxisTicks.push({\n\t\t\t\t\tname: scaleKey,\n\t\t\t\t\ttickValues: tickValues,\n\t\t\t\t\tformattedTicks: formattedTicks,\n\t\t\t\t\tprecision: currScale.precision,\n\t\t\t\t\tmax: currScale.domain[1]\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\n\t\t// Render hidden y-axis ticks in order to compute the maxTickWidth\n\t\t// independent of rendering the chart itself, this is needed to set the\n\t\t// appropriate padding for the chart. We must do this for each y-axis.\n\t\tvar HiddenAxes = map(axisTicks, function(axis, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(HiddenSvg.HiddenSvgAxis, {\n\t\t\t\t\tclassName: \"tick\", \n\t\t\t\t\tchartWidth: dimensions.width, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth[axis.name], \n\t\t\t\t\tformattedText: axis.formattedTicks, \n\t\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset, \n\t\t\t\t\tkey: i, \n\t\t\t\t\tonUpdate: this._handleMaxTickWidth.bind(null, axis.name)}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\tif (this.state.maxTickWidth.primaryScale <= 0) {\n\t\t\t// We have not yet calculated maxTickWidth\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", null, HiddenAxes)\n\t\t\t);\n\t\t}\n\n\t\t// Create array of chart-specific components that will be passed to the Svg\n\t\t// chart template, which adds title/credit/source etc\n\t\treturn (\n\t\t\tReact.createElement(\"g\", null, \n\t\t\t\tReact.createElement(XYChart, {\n\t\t\t\t\tkey: \"xy-chart\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tmetadata: this.props.metadata, \n\t\t\t\t\tlabelYMax: this.state.labelYMax, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\taxisTicks: axisTicks}\n\t\t\t\t), \n\t\t\t\tReact.createElement(XYLabels, {\n\t\t\t\t\tkey: \"xy-labels\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\teditable: this.props.editable, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tupdateLabelYMax: this._updateLabelYMax, \n\t\t\t\t\tlabelYMax: this.state.labelYMax}\n\t\t\t\t), \n\t\t\t\tHiddenAxes\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * ### Component that renders the XY chart area (not annotations)\n * See `React.PropTypes` declaration:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYChart = React.createClass({displayName: \"XYChart\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tpaddingTop: 0,\n\t\t\tlabelsDragged: false\n\t\t}\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentDidMount: function() {\n\t\t// Draw chart once mounted\n\t\tvar el = this.getDOMNode();\n\n\t\tif (this.props.chartProps.data.length === 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\t// On component mount, delete any existing chart\n\t\t\tif (el.childNodes[0]) {\n\t\t\t\tel.removeChild(el.childNodes[0]);\n\t\t\t}\n\t\t\tdrawXY(el, this._getChartState(this.props));\n\t\t}\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\t// always update by redrawing the chart\n\t\tvar el = this.getDOMNode();\n\t\tdrawXY(el, this._getChartState(nextProps));\n\t\treturn false;\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\tthis.setState({\n\t\t\tyOffset: yOffset\n\t\t});\n\t},\n\n\t_getChartState: function(props) {\n\t\t// Generate and return the state needed to draw the chart. This is what will\n\t\t// passed to the d4/d3 draw function.\n\t\tvar dateSettings;\n\t\tif (props.chartProps.scale.hasDate) {\n\t\t\tdateSettings = this.generateDateScale(props);\n\t\t}\n\t\tvar computedPadding = computePadding(props);\n\t\tvar hasColumn = some(props.chartProps.chartSettings, function(setting) {\n\t\t\treturn setting.type == \"column\";\n\t\t});\n\n\t\treturn {\n\t\t\tchartRenderer: cb_xy(),\n\t\t\tstyleConfig: props.styleConfig,\n\t\t\tdisplayConfig: props.displayConfig,\n\t\t\tdateSettings: dateSettings,\n\t\t\tmaxTickWidth: props.maxTickWidth,\n\t\t\thasColumn: hasColumn,\n\t\t\taxisTicks: props.axisTicks,\n\t\t\tdimensions: props.dimensions,\n\t\t\tdata: props.data,\n\t\t\tpadding: computedPadding,\n\t\t\tchartProps: props.chartProps,\n\t\t\tscale: props.scale\n\t\t};\n\t},\n\n\trender: function() {\n\t\t// empty <svg:g> that will be drawn into using `this.getDOMNode()`\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"renderer-chart\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * ### Component that renders the legend labels for an XY chart\n * See `React.PropTypes` declaration for properties:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   updateLabelYMax: PropTypes.func,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYLabels = React.createClass({displayName: \"XYLabels\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tupdateLabelYMax: PropTypes.func,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tyOffset: 10,\n\t\t\tundraggedLabels: {},\n\t\t\tdateScaleInfo: null\n\t\t};\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Determine how far down vertically the labels should be placed, depending\n\t\t// on presence (or not) of a title\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\t/*\n\t\t* We use this XYLabels component's state to save locations of undragged\n\t\t* labels. Dragged labels are saved to the parent store so that they can be\n\t\t* reloaded later.\n\t\t*/\n\t\t/* Make sure only undragged labels exist in XYLabels state, removing others */\n\t\tvar updateUndragged = reduce(nextProps.chartProps._annotations.labels.values, function(obj, v, i) {\n\t\t\tif (!v.dragged) {\n\t\t\t\tif (this.state.undraggedLabels[i]) {\n\t\t\t\t\tobj[i] = this.state.undraggedLabels[i];\n\t\t\t\t\treturn obj;\n\t\t\t\t} else {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}, {}, this);\n\t\tthis.setState({\n\t\t\tyOffset: yOffset,\n\t\t\tundraggedLabels: updateUndragged,\n\t\t\tdateScaleInfo: nextProps.chartProps.scale.hasDate ? this.generateDateScale(nextProps) : null\n\t\t});\n\t},\n\n\t_getLabelYMax: function(labels, height) {\n\t\tvar labelYMax = 0;\n\n\t\t// Find out how much vertical space the labels are taking up\n\t\t// by identifying the one with the largest `y` value\n\t\t// Only do this if the labels have not been dragged\n\t\tif (!labels.hasDragged) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar currLabel = labels[i];\n\t\t\t\tif (currLabel) {\n\t\t\t\t\tif (currLabel.y > labelYMax) {\n\t\t\t\t\t\tlabelYMax = currLabel.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\treturn labelYMax;\n\t},\n\n\t_computePadding: function(props) {\n\t\treturn computePadding(props)\n\t},\n\n\t_enableDrag: function() {\n\t\t// tell the parent app that dragging has been enabled\n\t\tvar annotations = this.props.chartProps._annotations;\n\t\tannotations.labels.hasDragged = true;\n\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t},\n\n\t_handleLabelPositionUpdate: function(ix, pos) {\n\t\t/* If a label is dragged, update its position in the parent app */\n\t\tif (pos.dragged) {\n\t\t\tvar values = clone(this.props.chartProps._annotations.labels.values);\n\t\t\tvalues[ix] = pos;\n\t\t\tvar annotations = update(this.props.chartProps._annotations, { $merge: {\n\t\t\t\tlabels: {\n\t\t\t\t\tvalues: values,\n\t\t\t\t\thasDragged: this.props.chartProps._annotations.labels.hasDragged\n\t\t\t\t}\n\t\t\t}});\n\t\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t\t/* Otherwise if undragged, update in XYLabls state */\n\t\t} else {\n\t\t\tvar undragged = this.state.undraggedLabels;\n\t\t\tundragged[ix] = pos;\n\t\t\tthis.setState(update(this.state, { $merge: {\n\t\t\t\tundraggedLabels: undragged\n\t\t\t}}));\n\t\t\tvar labelYMax = this._getLabelYMax(undragged, this.props.dimensions.height);\n\t\t\tif (labelYMax !== this.props.labelYMax) {\n\t\t\t\tthis.props.updateLabelYMax(labelYMax);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * XYLabels#_getPrevUndraggedNode\n\t * Recursively traverse through previous labels to find one that is undragged\n\t * This is used to calculate the default placement of a label (ie to the\n\t * right of the previous undragged node)\n\t * @param {number} ix - The index of this undragged node in an array of undragged nodes\n\t * @param {object[]} undraggedLabels - Position and size settings for all undraggedlabels\n\t * @instance\n\t * @memberof XYLabels\n\t */\n\t_getPrevUndraggedNode: function(ix, undraggedLabels) {\n\t\tif (ix < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (undraggedLabels[ix]) {\n\t\t\treturn undraggedLabels[ix];\n\t\t} else {\n\t\t\treturn this._getPrevUndraggedNode(ix - 1, undraggedLabels);\n\t\t}\n\t},\n\n\trender: function() {\n\t\t// create array of SvgRectLabel components\n\t\tvar labels = this.props.chartProps._annotations.labels;\n\t\tvar styleConfig = this.props.styleConfig;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar props = this.props;\n\t\tvar dimensions = props.dimensions;\n\t\tvar padding = computePadding(props, this.props.dimensions.height);\n\n\t\tvar labelConfig = {\n\t\t\txMargin: displayConfig.labelXMargin,\n\t\t\ttextMargin: displayConfig.labelTextMargin,\n\t\t\trowHeight: displayConfig.labelRowHeight,\n\t\t\trectSize: displayConfig.labelRectSize\n\t\t};\n\n\t\tvar labelComponents = [];\n\t\tif (this.props.chartProps.data.length > 1) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar labelSettings = {};\n\t\t\t\tvar prevNode = null;\n\t\t\t\tvar chartSetting = this.props.chartProps.chartSettings[i];\n\n\t\t\t\t// Use existing positions if possible\n\t\t\t\tif (labels.values[i].dragged) {\n\t\t\t\t\tlabelSettings = labels.values[i];\n\t\t\t\t} else {\n\t\t\t\t\tlabelSettings = this.state.undraggedLabels[i];\n\t\t\t\t\tprevNode = this._getPrevUndraggedNode(i - 1, this.state.undraggedLabels);\n\t\t\t\t}\n\n\t\t\t\tvar scales = this.props.scale;\n\t\t\t\tyScale_info = !chartSetting.altAxis ? scales.primaryScale : scales.secondaryScale;\n\t\t\t\txScale_info = xScaleInfo(this.props.dimensions.width,padding,styleConfig,displayConfig,{dateSettings: this.state.dateScaleInfo});\n\t\t\t\tscale = {\n\t\t\t\t\ty: {\n\t\t\t\t\t\tdomain: yScale_info.domain,\n\t\t\t\t\t\trange:[\n\t\t\t\t\t\t\tthis.props.dimensions.height - padding.bottom - displayConfig.margin.bottom,\n\t\t\t\t\t\t\tpadding.top + displayConfig.margin.top\n\t\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tx: {\n\t\t\t\t\t\tdomain: xScale_info.domain ? xScale_info.domain : [],\n\t\t\t\t\t\trange: props.chartProps.scale.hasDate ? [\n\t\t\t\t\t\t\tpadding.left + displayConfig.margin.left + this.props.maxTickWidth.primaryScale,\n\t\t\t\t\t\t\txScale_info.rangeR-padding.right-displayConfig.margin.right-this.props.maxTickWidth.secondaryScale - displayConfig.minPaddingOuter\n\t\t\t\t\t\t\t] : []\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlabelComponents.push(\n\t\t\t\t\tReact.createElement(SvgRectLabel, {\n\t\t\t\t\t\tkey: i, \n\t\t\t\t\t\ttext: chartSetting.label, \n\t\t\t\t\t\tlabelConfig: labelConfig, \n\t\t\t\t\t\tdimensions: this.props.chartAreaDimensions, \n\t\t\t\t\t\tindex: i, \n\t\t\t\t\t\tenableDrag: this._enableDrag, \n\t\t\t\t\t\tonPositionUpdate: this._handleLabelPositionUpdate, \n\t\t\t\t\t\teditable: props.editable, \n\t\t\t\t\t\toffset: { x: displayConfig.margin.left, y: this.state.yOffset}, \n\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex, \n\t\t\t\t\t\tsettings: labelSettings, \n\t\t\t\t\t\tprevNode: prevNode, \n\t\t\t\t\t\tscale: scale}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}, this);\n\t\t}\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tref: \"chartAnnotations\", \n\t\t\t\tclassName: \"renderer-annotations\", \n\t\t\t\ttransform: \"translate(\" + [displayConfig.margin.left, this.state.yOffset] + \")\"\n\t\t\t}, \n\t\t\t\tlabelComponents\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nd3.selection.prototype.moveToFront = function() {\n  return this.each(function(){\n    this.parentNode.appendChild(this);\n  });\n};\n\nvar xy_render_options = {\n\taxis : {\n\t\tafterRender: function(feature,data,chartArea,selection,isPrimary) {\n\t\t\t/* SO HERES THE DEAL\n\t\t\t// this is a lot of effort to customize axes\n\t\t\t// what we do at Quartz instead of this is build\n\t\t\t// our own d3 that draws axes exactly how we want them\n\t\t\t// If you're getting serious about customization,\n\t\t\t// I suggest you do the same.\n\t\t\t*/\n\t\t\tvar chart = this;\n\t\t\tvar ticks = selection.selectAll(\".tick\");\n\t\t\tvar text = ticks.selectAll(\"text\");\n\t\t\tvar max = d3.max(this.y.domain());\n\n\t\t\tticks.classed(\"zero\", function(d) {\n\t\t\t\treturn (d === 0);\n\t\t\t});\n\n\t\t\tif (isPrimary) {\n\t\t\t\tvar maxTick = ticks.filter(function(d) {\n\t\t\t\t\treturn (d === max);\n\t\t\t\t});\n\t\t\t\tvar maxTickRect = maxTick.selectAll(\"rect\").data([0]).enter().append(\"rect\");\n\t\t\t\tvar maxTickText = maxTick.select(\"text\");\n\t\t\t\tvar textNode = maxTickText.node();\n\t\t\t\tvar bcr = textNode.getBoundingClientRect();\n\t\t\t\tvar width = bcr.width;\n\t\t\t\tvar x = parseFloat(textNode.getAttribute(\"x\"));\n\t\t\t\tvar newX = x;\n\t\t\t\tif (width + (-x) > chart.width - 12) {\n\t\t\t\t\tnewX = width - chart.width + chart.margin.left + 12;\n\t\t\t\t\tmaxTickText.attr(\"x\", newX);\n\t\t\t\t}\n\t\t\t\tmaxTick.select(\"rect\").attr({\n\t\t\t\t\tx: newX - width,\n\t\t\t\t\ty: (-1 * bcr.height / 2),\n\t\t\t\t\twidth: width + 6,\n\t\t\t\t\theight: bcr.height\n\t\t\t\t});\n\t\t\t\tmaxTickText.moveToFront();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction drawXY(el, state) {\n\tvar chartProps = state.chartProps;\n\tvar dateSettings = state.dateSettings;\n\tvar displayConfig = state.displayConfig;\n\tvar styleConfig = state.styleConfig;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scale = state.scale;\n\t//var borderSpace = help.combineMarginPadding(chartProps.margin,chartProps.padding);\n\n\t// set the `extraPadding` based on pre-computed `maxTickWidth` values,\n\t// generated by the `HiddenAxes` component\n\tvar extraPadding = {\n\t\ttop: chartProps.extraPadding.top,\n\t\tright: Math.max(state.maxTickWidth.secondaryScale, displayConfig.minPaddingOuter),\n\t\tbottom: chartProps.extraPadding.bottom,\n\t\tleft: state.maxTickWidth.primaryScale\n\t};\n\n\tvar mixouts = chartProps._numSecondaryAxis ? [] : [\"rightAxis\"]\n\n\tvar xyChart = state.chartRenderer\n\t\t.outerWidth(state.dimensions.width)\n\t\t.outerHeight(state.dimensions.height)\n\t\t.margin(displayConfig.margin)\n\t\t.padding(state.padding)\n\t\t.extraPadding(extraPadding)\n\t\t.mixout(\"series-label\")\n\t\t.using(\"leftAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"primary\",axis,el,state)\n\t\t})\n\t\t.x(function(x) {\n\t\t\tx.key(\"entry\");\n\t\t\tvar o = xScaleInfo(this.width,this.padding,styleConfig,displayConfig,state);\n\t\t\tif (state.dateSettings) {\n\t\t\t\tx.scale(\"time\");\n\t\t\t\tx.domain(o.domain);\n\t\t\t\tx.range([o.rangeL, o.rangeR]);\n\t\t\t}\n\t\t})\n\t\t.y(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.left(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.using(\"rightAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"secondary\",axis,el,state)\n\t\t})\n\t\t.chartAreaOnTop(false)\n\t\t.using(\"xAxis\", function(axis) {\n\n\t\t\taxis.beforeRender(function(data) {\n\t\t\t\t// Center ticks if all data series are columns\n\t\t\t\tvar numColumns = filter(data, function(d) {\n\t\t\t\t\treturn d.type === \"column\";\n\t\t\t\t}).length;\n\n\t\t\t\t// Don't display the x axis grid tick if all series are columns\n\t\t\t\tif (numColumns === data.length) {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t} else {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t\tthis.container.selectAll(\".xAxis .tick\").attr(\"data-anchor\", \"start\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (state.dateSettings) {\n\t\t\t\taxis.tickValues(dateSettings.dateTicks);\n\t\t\t\taxis.tickFormat(function(d,i) {\n\t\t\t\t\treturn dateSettings.dateFormatter(d,i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\txyChart.right(function(y) {\n\t\t\t\ty.key(\"value\")\n\t\t\t\t\t.domain(scale.secondaryScale.domain)\n\t\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\td3.select(el)\n\t\t.datum(state.data)\n\t\t.call(xyChart);\n}\n\nfunction xScaleInfo(width, padding, styleConfig, displayConfig, state) {\n\tvar hasMultipleYAxes = false\n\tif(state.secondaryScale) {\n\t\thasMultipleYAxes = true;\n\t}\n\tif (state.chartProps && state.chartProps._numSecondaryAxis) {\n\t\thasMultipleYAxes = true;\n\t}\n\tvar o = {\n\t\trangeL: padding.left + styleConfig.xOverTick,\n\t\trangeR: width - padding.right - (hasMultipleYAxes ? styleConfig.xOverTick : 0),\n\t\tdomain: state.dateSettings ? state.dateSettings.domain : null\n\t}\n\n\tif (state.hasColumn) {\n\t\tvar numData = state.chartProps.data[0].values.length;\n\t\tvar widthPerColumn = width / numData;\n\t\to.rangeL += (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t\to.rangeR -= (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t}\n\treturn o;\n}\n\nfunction yAxisUsing(location, axis, el, state) {\n\tvar chartProps = state.chartProps;\n\tvar isPrimary = location == \"primary\"\n\tvar scale = isPrimary ? state.scale.primaryScale : state.scale.secondaryScale;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scaleId = isPrimary ? \"left\" : \"right\";\n\n\tif(!hasOtherAxis && !isPrimary) {\n\t\taxis.render = function() {\n\t\t\tthis.container.selectAll(\".right.axis\").remove();\n\t\t}\n\t\tstate.chartProps.extraPadding.right = 0;\n\t\treturn null;\n\t}\n\n\t// axis tick values have been computed by parent compnent in order to draw\n\t// hidden axes, so we pass them in here\n\tvar axisTicks = isPrimary ? state.axisTicks[0] : state.axisTicks[1];\n\taxis.tickValues(axisTicks.tickValues);\n\n\t// format using our precision and suffix/prefix\n\taxis.tickFormat(function(d) {\n\t\tif (d == axisTicks.max) {\n\t\t\treturn [\n\t\t\t\tscale.prefix,\n\t\t\t\thelp.roundToPrecision(d, scale.precision),\n\t\t\t\tscale.suffix\n\t\t\t].join(\"\");\n\t\t} else {\n\t\t\treturn help.roundToPrecision(d, scale.precision);\n\t\t}\n\t});\n\n\taxis.afterRender(function(feature,data,chartArea,selection) {\n\t\tthis.container.select(\".axis.\" + scaleId).selectAll(\".tick text\")\n\t\t\t.attr(\"data-color-index\", scale.colorIndex);\n\n\t\txy_render_options.axis.afterRender.call(this,feature,data,chartArea,selection,isPrimary);\n\t});\n\n\tvar innerTickSize;\n\tif (isPrimary) {\n\t\tinnerTickSize = this.width - this.padding.left - this.padding.right;\n\t\tif (hasOtherAxis) {\n\t\t\tinnerTickSize -= state.displayConfig.blockerRectOffset;\n\t\t}\n\t} else {\n\t\tinnerTickSize = 0;\n\t}\n\n\taxis.innerTickSize( innerTickSize );\n\taxis.scaleId(scaleId);\n}\n\nfunction computePadding(props, chartHeight) {\n\tvar labels = props.chartProps._annotations.labels;\n\tvar displayConfig = props.displayConfig;\n\tvar _top = (props.labelYMax * props.chartAreaDimensions.height) + displayConfig.afterLegend;\n\n\tif (props.hasTitle) {\n\t\t_top += displayConfig.afterTitle;\n\t}\n\n\t// Maintain space between legend and chart area unless all legend labels\n\t// have been dragged\n\tvar allLabelsDragged = reduce(labels.values, function(prev, value) {\n\t\treturn (prev === true && value.dragged === true);\n\t}, true);\n\n\t// Reduce top padding if all labels or dragged or there is only one series,\n\t// meaning no label will be shown\n\tif (allLabelsDragged || props.chartProps.data.length === 1) {\n\t\t_top -= displayConfig.afterLegend;\n\t}\n\treturn {\n\t\ttop: _top,\n\t\tright: displayConfig.padding.right,\n\t\tbottom: displayConfig.padding.bottom,\n\t\tleft: displayConfig.padding.left\n\t};\n}\n\nmodule.exports = XYRenderer;",
            "path": "src/js/components/chart-xy/XYRenderer.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYRenderer.jsx#L47-L225"
          },
          "properties": [
            {
              "title": "property",
              "description": "Allow the rendered component to interacted with and edited",
              "type": {
                "type": "NameExpression",
                "name": "boolean"
              },
              "name": "editable"
            },
            {
              "title": "property",
              "description": "Parsed visual display configuration for chart grid",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "displayConfig"
            },
            {
              "title": "property",
              "description": "Properties used to draw this chart",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "chartProps"
            },
            {
              "title": "property",
              "description": "Title, data source, etc",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "metadata"
            }
          ],
          "scope": "instance",
          "memberof": "renderers",
          "name": "XYRenderer",
          "kind": "function",
          "members": {
            "instance": [
              {
                "description": "### Component that renders the XY chart area (not annotations)\nSee `React.PropTypes` declaration:",
                "tags": [
                  {
                    "title": "example",
                    "description": "propTypes: {\n  chartProps: PropTypes.object.isRequired,\n  hasTitle: PropTypes.bool.isRequired,\n  displayConfig: PropTypes.object.isRequired,\n  styleConfig: PropTypes.object.isRequired,\n  data: PropTypes.arrayOf(PropTypes.object).isRequired,\n  dimensions: PropTypes.shape({\n    width: PropTypes.number,\n    height: PropTypes.number\n  }).isRequired,\n  scale: PropTypes.object.isRequired,\n  chartAreaDimensions: PropTypes.object,\n  metadata: PropTypes.object,\n  labelYMax: PropTypes.number,\n  maxTickWidth: PropTypes.object,\n  axisTicks: PropTypes.array\n},"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "XYRenderer"
                  },
                  {
                    "title": "name",
                    "name": "XYChart"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 251,
                      "column": 0
                    },
                    "end": {
                      "line": 351,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYRenderer.jsx",
                  "code": "var React = require(\"react\");\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\n// Node modules\nvar d3 = require(\"d3\");\nvar d4 = require(\"d4\");\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar assign = require(\"lodash/object/assign\");\nvar each = require(\"lodash/collection/each\");\nvar filter = require(\"lodash/collection/filter\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar some = require(\"lodash/collection/some\");\n\nvar ChartRendererMixin = require(\"../mixins/ChartRendererMixin.js\");\nvar DateScaleMixin = require(\"../mixins/DateScaleMixin.js\");\n\n// Flux actions\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\n// Svg components\nvar SvgRectLabel = require(\"../svg/SvgRectLabel.jsx\");\nvar HiddenSvg = require(\"../svg/HiddenSvg.jsx\");\n\n// Helpers\nvar cb_xy = require(\"../../charts/cb-charts\").cb_xy;\nvar help = require(\"../../util/helper.js\");\n\nvar scaleNames = [\"primaryScale\", \"secondaryScale\"];\n\n/**\n * ### Component that renders XY (line, column, dot) charts\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {object} metadata - Title, data source, etc\n * @instance\n * @memberof renderers\n */\nvar XYRenderer = React.createClass({displayName: \"XYRenderer\",\n\n\tpropTypes: {\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.object.isRequired,\n\t\t\tpadding: PropTypes.object.isRequired,\n\t\t\tlabelRectSize: PropTypes.number.isRequired,\n\t\t\tafterLegend: PropTypes.number.isRequired\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_annotations: PropTypes.object,\n\t\t\tdate: PropTypes.object,\n\t\t\tmobile: PropTypes.object\n\t\t}).isRequired,\n\t\tmetadata: PropTypes.object,\n\t\tshowMetadata: PropTypes.bool,\n\t\teditable: PropTypes.bool,\n\t\tuseMobileSettings: PropTypes.bool\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tlabelYMax: 0,\n\t\t\tmaxTickWidth: {\n\t\t\t\tprimaryScale: 0,\n\t\t\t\tsecondaryScale: 0\n\t\t\t}\n\t\t};\n\t},\n\n\tmixins: [ChartRendererMixin],\n\n\t_handleMaxTickWidth: function(k, v) {\n\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\tmaxTickWidth[k] = v;\n\t\tthis._handleStateUpdate(\"maxTickWidth\", maxTickWidth);\n\t},\n\n\t_updateLabelYMax: function(labelYMax) {\n\t\tthis.setState({ labelYMax: labelYMax });\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tif (nextProps.chartProps._numSecondaryAxis === 0) {\n\t\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\t\tmaxTickWidth.secondaryScale = 0;\n\t\t\tthis.setState({ maxTickWidth: maxTickWidth });\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar _chartProps = this.props.chartProps;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar axis = d3.svg.axis();\n\t\tvar axisTicks = [];\n\t\tvar labelComponents;\n\t\tvar dimensions = this.props.dimensions;\n\n\t\t// Dimensions of the chart area\n\t\tvar chartAreaDimensions = {\n\t\t\twidth: (dimensions.width -\n\t\t\t\t\t\t\tdisplayConfig.margin.left - displayConfig.margin.right -\n\t\t\t\t\t\t\tdisplayConfig.padding.left - displayConfig.padding.right -\n\t\t\t\t\t\t\tthis.state.maxTickWidth.primaryScale - this.state.maxTickWidth.secondaryScale),\n\t\t\theight: (dimensions.height -\n\t\t\t\t\t\t\t displayConfig.margin.top - displayConfig.margin.bottom -\n\t\t\t\t\t\t\t displayConfig.padding.top - displayConfig.padding.bottom)\n\t\t};\n\n\t\tif (this.props.enableResponsive && _chartProps.hasOwnProperty(\"mobile\") && this.props.isSmall) {\n\t\t\tif (_chartProps.mobile.scale) {\n\t\t\t\tscale = assign({}, _chartProps.scale, _chartProps.mobile.scale);\n\t\t\t} else {\n\t\t\t\tscale = _chartProps.scale;\n\t\t\t}\n\t\t} else {\n\t\t\tscale = _chartProps.scale;\n\t\t}\n\n\t\t// apply `chartSettings` to data\n\t\tvar dataWithSettings = this._applySettingsToData(_chartProps);\n\t\t// compute margin based on existence of labels and title, based on default\n\t\t// margin set in config\n\t\tvar labels = _chartProps._annotations.labels;\n\t\tvar hasTitle = (this.props.metadata.title.length > 0 && this.props.showMetadata);\n\n\t\t// compute the max tick width for each scale\n\t\teach(scaleNames, function(scaleKey) {\n\t\t\tvar currScale = scale[scaleKey];\n\n\t\t\tif (currScale) {\n\t\t\t\t// get the tick values so that we can pass them both to the actual chart\n\t\t\t\t// renderer and to the component that will render hidden ticks\n\t\t\t\tvar tickValues = currScale.tickValues;\n\n\t\t\t\tvar skipFirstNode = filter(tickValues, function(d) {\n\t\t\t\t\treturn (d !== currScale.domain[1]);\n\t\t\t\t});\n\n\t\t\t\tvar formattedTicks = map(skipFirstNode, function(tick) {\n\t\t\t\t\treturn help.roundToPrecision(tick, currScale.precision);\n\t\t\t\t});\n\n\t\t\t\taxisTicks.push({\n\t\t\t\t\tname: scaleKey,\n\t\t\t\t\ttickValues: tickValues,\n\t\t\t\t\tformattedTicks: formattedTicks,\n\t\t\t\t\tprecision: currScale.precision,\n\t\t\t\t\tmax: currScale.domain[1]\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\n\t\t// Render hidden y-axis ticks in order to compute the maxTickWidth\n\t\t// independent of rendering the chart itself, this is needed to set the\n\t\t// appropriate padding for the chart. We must do this for each y-axis.\n\t\tvar HiddenAxes = map(axisTicks, function(axis, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(HiddenSvg.HiddenSvgAxis, {\n\t\t\t\t\tclassName: \"tick\", \n\t\t\t\t\tchartWidth: dimensions.width, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth[axis.name], \n\t\t\t\t\tformattedText: axis.formattedTicks, \n\t\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset, \n\t\t\t\t\tkey: i, \n\t\t\t\t\tonUpdate: this._handleMaxTickWidth.bind(null, axis.name)}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\tif (this.state.maxTickWidth.primaryScale <= 0) {\n\t\t\t// We have not yet calculated maxTickWidth\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", null, HiddenAxes)\n\t\t\t);\n\t\t}\n\n\t\t// Create array of chart-specific components that will be passed to the Svg\n\t\t// chart template, which adds title/credit/source etc\n\t\treturn (\n\t\t\tReact.createElement(\"g\", null, \n\t\t\t\tReact.createElement(XYChart, {\n\t\t\t\t\tkey: \"xy-chart\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tmetadata: this.props.metadata, \n\t\t\t\t\tlabelYMax: this.state.labelYMax, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\taxisTicks: axisTicks}\n\t\t\t\t), \n\t\t\t\tReact.createElement(XYLabels, {\n\t\t\t\t\tkey: \"xy-labels\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\teditable: this.props.editable, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tupdateLabelYMax: this._updateLabelYMax, \n\t\t\t\t\tlabelYMax: this.state.labelYMax}\n\t\t\t\t), \n\t\t\t\tHiddenAxes\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * ### Component that renders the XY chart area (not annotations)\n * See `React.PropTypes` declaration:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYChart = React.createClass({displayName: \"XYChart\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tpaddingTop: 0,\n\t\t\tlabelsDragged: false\n\t\t}\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentDidMount: function() {\n\t\t// Draw chart once mounted\n\t\tvar el = this.getDOMNode();\n\n\t\tif (this.props.chartProps.data.length === 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\t// On component mount, delete any existing chart\n\t\t\tif (el.childNodes[0]) {\n\t\t\t\tel.removeChild(el.childNodes[0]);\n\t\t\t}\n\t\t\tdrawXY(el, this._getChartState(this.props));\n\t\t}\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\t// always update by redrawing the chart\n\t\tvar el = this.getDOMNode();\n\t\tdrawXY(el, this._getChartState(nextProps));\n\t\treturn false;\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\tthis.setState({\n\t\t\tyOffset: yOffset\n\t\t});\n\t},\n\n\t_getChartState: function(props) {\n\t\t// Generate and return the state needed to draw the chart. This is what will\n\t\t// passed to the d4/d3 draw function.\n\t\tvar dateSettings;\n\t\tif (props.chartProps.scale.hasDate) {\n\t\t\tdateSettings = this.generateDateScale(props);\n\t\t}\n\t\tvar computedPadding = computePadding(props);\n\t\tvar hasColumn = some(props.chartProps.chartSettings, function(setting) {\n\t\t\treturn setting.type == \"column\";\n\t\t});\n\n\t\treturn {\n\t\t\tchartRenderer: cb_xy(),\n\t\t\tstyleConfig: props.styleConfig,\n\t\t\tdisplayConfig: props.displayConfig,\n\t\t\tdateSettings: dateSettings,\n\t\t\tmaxTickWidth: props.maxTickWidth,\n\t\t\thasColumn: hasColumn,\n\t\t\taxisTicks: props.axisTicks,\n\t\t\tdimensions: props.dimensions,\n\t\t\tdata: props.data,\n\t\t\tpadding: computedPadding,\n\t\t\tchartProps: props.chartProps,\n\t\t\tscale: props.scale\n\t\t};\n\t},\n\n\trender: function() {\n\t\t// empty <svg:g> that will be drawn into using `this.getDOMNode()`\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"renderer-chart\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * ### Component that renders the legend labels for an XY chart\n * See `React.PropTypes` declaration for properties:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   updateLabelYMax: PropTypes.func,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYLabels = React.createClass({displayName: \"XYLabels\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tupdateLabelYMax: PropTypes.func,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tyOffset: 10,\n\t\t\tundraggedLabels: {},\n\t\t\tdateScaleInfo: null\n\t\t};\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Determine how far down vertically the labels should be placed, depending\n\t\t// on presence (or not) of a title\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\t/*\n\t\t* We use this XYLabels component's state to save locations of undragged\n\t\t* labels. Dragged labels are saved to the parent store so that they can be\n\t\t* reloaded later.\n\t\t*/\n\t\t/* Make sure only undragged labels exist in XYLabels state, removing others */\n\t\tvar updateUndragged = reduce(nextProps.chartProps._annotations.labels.values, function(obj, v, i) {\n\t\t\tif (!v.dragged) {\n\t\t\t\tif (this.state.undraggedLabels[i]) {\n\t\t\t\t\tobj[i] = this.state.undraggedLabels[i];\n\t\t\t\t\treturn obj;\n\t\t\t\t} else {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}, {}, this);\n\t\tthis.setState({\n\t\t\tyOffset: yOffset,\n\t\t\tundraggedLabels: updateUndragged,\n\t\t\tdateScaleInfo: nextProps.chartProps.scale.hasDate ? this.generateDateScale(nextProps) : null\n\t\t});\n\t},\n\n\t_getLabelYMax: function(labels, height) {\n\t\tvar labelYMax = 0;\n\n\t\t// Find out how much vertical space the labels are taking up\n\t\t// by identifying the one with the largest `y` value\n\t\t// Only do this if the labels have not been dragged\n\t\tif (!labels.hasDragged) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar currLabel = labels[i];\n\t\t\t\tif (currLabel) {\n\t\t\t\t\tif (currLabel.y > labelYMax) {\n\t\t\t\t\t\tlabelYMax = currLabel.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\treturn labelYMax;\n\t},\n\n\t_computePadding: function(props) {\n\t\treturn computePadding(props)\n\t},\n\n\t_enableDrag: function() {\n\t\t// tell the parent app that dragging has been enabled\n\t\tvar annotations = this.props.chartProps._annotations;\n\t\tannotations.labels.hasDragged = true;\n\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t},\n\n\t_handleLabelPositionUpdate: function(ix, pos) {\n\t\t/* If a label is dragged, update its position in the parent app */\n\t\tif (pos.dragged) {\n\t\t\tvar values = clone(this.props.chartProps._annotations.labels.values);\n\t\t\tvalues[ix] = pos;\n\t\t\tvar annotations = update(this.props.chartProps._annotations, { $merge: {\n\t\t\t\tlabels: {\n\t\t\t\t\tvalues: values,\n\t\t\t\t\thasDragged: this.props.chartProps._annotations.labels.hasDragged\n\t\t\t\t}\n\t\t\t}});\n\t\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t\t/* Otherwise if undragged, update in XYLabls state */\n\t\t} else {\n\t\t\tvar undragged = this.state.undraggedLabels;\n\t\t\tundragged[ix] = pos;\n\t\t\tthis.setState(update(this.state, { $merge: {\n\t\t\t\tundraggedLabels: undragged\n\t\t\t}}));\n\t\t\tvar labelYMax = this._getLabelYMax(undragged, this.props.dimensions.height);\n\t\t\tif (labelYMax !== this.props.labelYMax) {\n\t\t\t\tthis.props.updateLabelYMax(labelYMax);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * XYLabels#_getPrevUndraggedNode\n\t * Recursively traverse through previous labels to find one that is undragged\n\t * This is used to calculate the default placement of a label (ie to the\n\t * right of the previous undragged node)\n\t * @param {number} ix - The index of this undragged node in an array of undragged nodes\n\t * @param {object[]} undraggedLabels - Position and size settings for all undraggedlabels\n\t * @instance\n\t * @memberof XYLabels\n\t */\n\t_getPrevUndraggedNode: function(ix, undraggedLabels) {\n\t\tif (ix < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (undraggedLabels[ix]) {\n\t\t\treturn undraggedLabels[ix];\n\t\t} else {\n\t\t\treturn this._getPrevUndraggedNode(ix - 1, undraggedLabels);\n\t\t}\n\t},\n\n\trender: function() {\n\t\t// create array of SvgRectLabel components\n\t\tvar labels = this.props.chartProps._annotations.labels;\n\t\tvar styleConfig = this.props.styleConfig;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar props = this.props;\n\t\tvar dimensions = props.dimensions;\n\t\tvar padding = computePadding(props, this.props.dimensions.height);\n\n\t\tvar labelConfig = {\n\t\t\txMargin: displayConfig.labelXMargin,\n\t\t\ttextMargin: displayConfig.labelTextMargin,\n\t\t\trowHeight: displayConfig.labelRowHeight,\n\t\t\trectSize: displayConfig.labelRectSize\n\t\t};\n\n\t\tvar labelComponents = [];\n\t\tif (this.props.chartProps.data.length > 1) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar labelSettings = {};\n\t\t\t\tvar prevNode = null;\n\t\t\t\tvar chartSetting = this.props.chartProps.chartSettings[i];\n\n\t\t\t\t// Use existing positions if possible\n\t\t\t\tif (labels.values[i].dragged) {\n\t\t\t\t\tlabelSettings = labels.values[i];\n\t\t\t\t} else {\n\t\t\t\t\tlabelSettings = this.state.undraggedLabels[i];\n\t\t\t\t\tprevNode = this._getPrevUndraggedNode(i - 1, this.state.undraggedLabels);\n\t\t\t\t}\n\n\t\t\t\tvar scales = this.props.scale;\n\t\t\t\tyScale_info = !chartSetting.altAxis ? scales.primaryScale : scales.secondaryScale;\n\t\t\t\txScale_info = xScaleInfo(this.props.dimensions.width,padding,styleConfig,displayConfig,{dateSettings: this.state.dateScaleInfo});\n\t\t\t\tscale = {\n\t\t\t\t\ty: {\n\t\t\t\t\t\tdomain: yScale_info.domain,\n\t\t\t\t\t\trange:[\n\t\t\t\t\t\t\tthis.props.dimensions.height - padding.bottom - displayConfig.margin.bottom,\n\t\t\t\t\t\t\tpadding.top + displayConfig.margin.top\n\t\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tx: {\n\t\t\t\t\t\tdomain: xScale_info.domain ? xScale_info.domain : [],\n\t\t\t\t\t\trange: props.chartProps.scale.hasDate ? [\n\t\t\t\t\t\t\tpadding.left + displayConfig.margin.left + this.props.maxTickWidth.primaryScale,\n\t\t\t\t\t\t\txScale_info.rangeR-padding.right-displayConfig.margin.right-this.props.maxTickWidth.secondaryScale - displayConfig.minPaddingOuter\n\t\t\t\t\t\t\t] : []\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlabelComponents.push(\n\t\t\t\t\tReact.createElement(SvgRectLabel, {\n\t\t\t\t\t\tkey: i, \n\t\t\t\t\t\ttext: chartSetting.label, \n\t\t\t\t\t\tlabelConfig: labelConfig, \n\t\t\t\t\t\tdimensions: this.props.chartAreaDimensions, \n\t\t\t\t\t\tindex: i, \n\t\t\t\t\t\tenableDrag: this._enableDrag, \n\t\t\t\t\t\tonPositionUpdate: this._handleLabelPositionUpdate, \n\t\t\t\t\t\teditable: props.editable, \n\t\t\t\t\t\toffset: { x: displayConfig.margin.left, y: this.state.yOffset}, \n\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex, \n\t\t\t\t\t\tsettings: labelSettings, \n\t\t\t\t\t\tprevNode: prevNode, \n\t\t\t\t\t\tscale: scale}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}, this);\n\t\t}\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tref: \"chartAnnotations\", \n\t\t\t\tclassName: \"renderer-annotations\", \n\t\t\t\ttransform: \"translate(\" + [displayConfig.margin.left, this.state.yOffset] + \")\"\n\t\t\t}, \n\t\t\t\tlabelComponents\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nd3.selection.prototype.moveToFront = function() {\n  return this.each(function(){\n    this.parentNode.appendChild(this);\n  });\n};\n\nvar xy_render_options = {\n\taxis : {\n\t\tafterRender: function(feature,data,chartArea,selection,isPrimary) {\n\t\t\t/* SO HERES THE DEAL\n\t\t\t// this is a lot of effort to customize axes\n\t\t\t// what we do at Quartz instead of this is build\n\t\t\t// our own d3 that draws axes exactly how we want them\n\t\t\t// If you're getting serious about customization,\n\t\t\t// I suggest you do the same.\n\t\t\t*/\n\t\t\tvar chart = this;\n\t\t\tvar ticks = selection.selectAll(\".tick\");\n\t\t\tvar text = ticks.selectAll(\"text\");\n\t\t\tvar max = d3.max(this.y.domain());\n\n\t\t\tticks.classed(\"zero\", function(d) {\n\t\t\t\treturn (d === 0);\n\t\t\t});\n\n\t\t\tif (isPrimary) {\n\t\t\t\tvar maxTick = ticks.filter(function(d) {\n\t\t\t\t\treturn (d === max);\n\t\t\t\t});\n\t\t\t\tvar maxTickRect = maxTick.selectAll(\"rect\").data([0]).enter().append(\"rect\");\n\t\t\t\tvar maxTickText = maxTick.select(\"text\");\n\t\t\t\tvar textNode = maxTickText.node();\n\t\t\t\tvar bcr = textNode.getBoundingClientRect();\n\t\t\t\tvar width = bcr.width;\n\t\t\t\tvar x = parseFloat(textNode.getAttribute(\"x\"));\n\t\t\t\tvar newX = x;\n\t\t\t\tif (width + (-x) > chart.width - 12) {\n\t\t\t\t\tnewX = width - chart.width + chart.margin.left + 12;\n\t\t\t\t\tmaxTickText.attr(\"x\", newX);\n\t\t\t\t}\n\t\t\t\tmaxTick.select(\"rect\").attr({\n\t\t\t\t\tx: newX - width,\n\t\t\t\t\ty: (-1 * bcr.height / 2),\n\t\t\t\t\twidth: width + 6,\n\t\t\t\t\theight: bcr.height\n\t\t\t\t});\n\t\t\t\tmaxTickText.moveToFront();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction drawXY(el, state) {\n\tvar chartProps = state.chartProps;\n\tvar dateSettings = state.dateSettings;\n\tvar displayConfig = state.displayConfig;\n\tvar styleConfig = state.styleConfig;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scale = state.scale;\n\t//var borderSpace = help.combineMarginPadding(chartProps.margin,chartProps.padding);\n\n\t// set the `extraPadding` based on pre-computed `maxTickWidth` values,\n\t// generated by the `HiddenAxes` component\n\tvar extraPadding = {\n\t\ttop: chartProps.extraPadding.top,\n\t\tright: Math.max(state.maxTickWidth.secondaryScale, displayConfig.minPaddingOuter),\n\t\tbottom: chartProps.extraPadding.bottom,\n\t\tleft: state.maxTickWidth.primaryScale\n\t};\n\n\tvar mixouts = chartProps._numSecondaryAxis ? [] : [\"rightAxis\"]\n\n\tvar xyChart = state.chartRenderer\n\t\t.outerWidth(state.dimensions.width)\n\t\t.outerHeight(state.dimensions.height)\n\t\t.margin(displayConfig.margin)\n\t\t.padding(state.padding)\n\t\t.extraPadding(extraPadding)\n\t\t.mixout(\"series-label\")\n\t\t.using(\"leftAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"primary\",axis,el,state)\n\t\t})\n\t\t.x(function(x) {\n\t\t\tx.key(\"entry\");\n\t\t\tvar o = xScaleInfo(this.width,this.padding,styleConfig,displayConfig,state);\n\t\t\tif (state.dateSettings) {\n\t\t\t\tx.scale(\"time\");\n\t\t\t\tx.domain(o.domain);\n\t\t\t\tx.range([o.rangeL, o.rangeR]);\n\t\t\t}\n\t\t})\n\t\t.y(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.left(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.using(\"rightAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"secondary\",axis,el,state)\n\t\t})\n\t\t.chartAreaOnTop(false)\n\t\t.using(\"xAxis\", function(axis) {\n\n\t\t\taxis.beforeRender(function(data) {\n\t\t\t\t// Center ticks if all data series are columns\n\t\t\t\tvar numColumns = filter(data, function(d) {\n\t\t\t\t\treturn d.type === \"column\";\n\t\t\t\t}).length;\n\n\t\t\t\t// Don't display the x axis grid tick if all series are columns\n\t\t\t\tif (numColumns === data.length) {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t} else {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t\tthis.container.selectAll(\".xAxis .tick\").attr(\"data-anchor\", \"start\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (state.dateSettings) {\n\t\t\t\taxis.tickValues(dateSettings.dateTicks);\n\t\t\t\taxis.tickFormat(function(d,i) {\n\t\t\t\t\treturn dateSettings.dateFormatter(d,i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\txyChart.right(function(y) {\n\t\t\t\ty.key(\"value\")\n\t\t\t\t\t.domain(scale.secondaryScale.domain)\n\t\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\td3.select(el)\n\t\t.datum(state.data)\n\t\t.call(xyChart);\n}\n\nfunction xScaleInfo(width, padding, styleConfig, displayConfig, state) {\n\tvar hasMultipleYAxes = false\n\tif(state.secondaryScale) {\n\t\thasMultipleYAxes = true;\n\t}\n\tif (state.chartProps && state.chartProps._numSecondaryAxis) {\n\t\thasMultipleYAxes = true;\n\t}\n\tvar o = {\n\t\trangeL: padding.left + styleConfig.xOverTick,\n\t\trangeR: width - padding.right - (hasMultipleYAxes ? styleConfig.xOverTick : 0),\n\t\tdomain: state.dateSettings ? state.dateSettings.domain : null\n\t}\n\n\tif (state.hasColumn) {\n\t\tvar numData = state.chartProps.data[0].values.length;\n\t\tvar widthPerColumn = width / numData;\n\t\to.rangeL += (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t\to.rangeR -= (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t}\n\treturn o;\n}\n\nfunction yAxisUsing(location, axis, el, state) {\n\tvar chartProps = state.chartProps;\n\tvar isPrimary = location == \"primary\"\n\tvar scale = isPrimary ? state.scale.primaryScale : state.scale.secondaryScale;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scaleId = isPrimary ? \"left\" : \"right\";\n\n\tif(!hasOtherAxis && !isPrimary) {\n\t\taxis.render = function() {\n\t\t\tthis.container.selectAll(\".right.axis\").remove();\n\t\t}\n\t\tstate.chartProps.extraPadding.right = 0;\n\t\treturn null;\n\t}\n\n\t// axis tick values have been computed by parent compnent in order to draw\n\t// hidden axes, so we pass them in here\n\tvar axisTicks = isPrimary ? state.axisTicks[0] : state.axisTicks[1];\n\taxis.tickValues(axisTicks.tickValues);\n\n\t// format using our precision and suffix/prefix\n\taxis.tickFormat(function(d) {\n\t\tif (d == axisTicks.max) {\n\t\t\treturn [\n\t\t\t\tscale.prefix,\n\t\t\t\thelp.roundToPrecision(d, scale.precision),\n\t\t\t\tscale.suffix\n\t\t\t].join(\"\");\n\t\t} else {\n\t\t\treturn help.roundToPrecision(d, scale.precision);\n\t\t}\n\t});\n\n\taxis.afterRender(function(feature,data,chartArea,selection) {\n\t\tthis.container.select(\".axis.\" + scaleId).selectAll(\".tick text\")\n\t\t\t.attr(\"data-color-index\", scale.colorIndex);\n\n\t\txy_render_options.axis.afterRender.call(this,feature,data,chartArea,selection,isPrimary);\n\t});\n\n\tvar innerTickSize;\n\tif (isPrimary) {\n\t\tinnerTickSize = this.width - this.padding.left - this.padding.right;\n\t\tif (hasOtherAxis) {\n\t\t\tinnerTickSize -= state.displayConfig.blockerRectOffset;\n\t\t}\n\t} else {\n\t\tinnerTickSize = 0;\n\t}\n\n\taxis.innerTickSize( innerTickSize );\n\taxis.scaleId(scaleId);\n}\n\nfunction computePadding(props, chartHeight) {\n\tvar labels = props.chartProps._annotations.labels;\n\tvar displayConfig = props.displayConfig;\n\tvar _top = (props.labelYMax * props.chartAreaDimensions.height) + displayConfig.afterLegend;\n\n\tif (props.hasTitle) {\n\t\t_top += displayConfig.afterTitle;\n\t}\n\n\t// Maintain space between legend and chart area unless all legend labels\n\t// have been dragged\n\tvar allLabelsDragged = reduce(labels.values, function(prev, value) {\n\t\treturn (prev === true && value.dragged === true);\n\t}, true);\n\n\t// Reduce top padding if all labels or dragged or there is only one series,\n\t// meaning no label will be shown\n\tif (allLabelsDragged || props.chartProps.data.length === 1) {\n\t\t_top -= displayConfig.afterLegend;\n\t}\n\treturn {\n\t\ttop: _top,\n\t\tright: displayConfig.padding.right,\n\t\tbottom: displayConfig.padding.bottom,\n\t\tleft: displayConfig.padding.left\n\t};\n}\n\nmodule.exports = XYRenderer;",
                  "path": "src/js/components/chart-xy/XYRenderer.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYRenderer.jsx#L251-L351"
                },
                "examples": [
                  "propTypes: {\n  chartProps: PropTypes.object.isRequired,\n  hasTitle: PropTypes.bool.isRequired,\n  displayConfig: PropTypes.object.isRequired,\n  styleConfig: PropTypes.object.isRequired,\n  data: PropTypes.arrayOf(PropTypes.object).isRequired,\n  dimensions: PropTypes.shape({\n    width: PropTypes.number,\n    height: PropTypes.number\n  }).isRequired,\n  scale: PropTypes.object.isRequired,\n  chartAreaDimensions: PropTypes.object,\n  metadata: PropTypes.object,\n  labelYMax: PropTypes.number,\n  maxTickWidth: PropTypes.object,\n  axisTicks: PropTypes.array\n},"
                ],
                "scope": "instance",
                "memberof": "XYRenderer",
                "name": "XYChart",
                "kind": "function",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "renderers",
                  "XYRenderer",
                  "XYChart"
                ]
              },
              {
                "description": "### Component that renders the legend labels for an XY chart\nSee `React.PropTypes` declaration for properties:",
                "tags": [
                  {
                    "title": "example",
                    "description": "propTypes: {\n  chartProps: PropTypes.object.isRequired,\n  hasTitle: PropTypes.bool.isRequired,\n  displayConfig: PropTypes.object.isRequired,\n  styleConfig: PropTypes.object.isRequired,\n  data: PropTypes.arrayOf(PropTypes.object).isRequired,\n  dimensions: PropTypes.shape({\n    width: PropTypes.number,\n    height: PropTypes.number\n  }).isRequired,\n  scale: PropTypes.object.isRequired,\n  chartAreaDimensions: PropTypes.object,\n  metadata: PropTypes.object,\n  labelYMax: PropTypes.number,\n  updateLabelYMax: PropTypes.func,\n  maxTickWidth: PropTypes.object,\n  axisTicks: PropTypes.array\n},"
                  },
                  {
                    "title": "instance",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "XYRenderer"
                  },
                  {
                    "title": "name",
                    "name": "XYLabels"
                  },
                  {
                    "title": "kind",
                    "kind": "function"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 378,
                      "column": 0
                    },
                    "end": {
                      "line": 603,
                      "column": 3
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYRenderer.jsx",
                  "code": "var React = require(\"react\");\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\nvar update = React.addons.update;\n\n// Node modules\nvar d3 = require(\"d3\");\nvar d4 = require(\"d4\");\n\nvar clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar assign = require(\"lodash/object/assign\");\nvar each = require(\"lodash/collection/each\");\nvar filter = require(\"lodash/collection/filter\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar some = require(\"lodash/collection/some\");\n\nvar ChartRendererMixin = require(\"../mixins/ChartRendererMixin.js\");\nvar DateScaleMixin = require(\"../mixins/DateScaleMixin.js\");\n\n// Flux actions\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\n// Svg components\nvar SvgRectLabel = require(\"../svg/SvgRectLabel.jsx\");\nvar HiddenSvg = require(\"../svg/HiddenSvg.jsx\");\n\n// Helpers\nvar cb_xy = require(\"../../charts/cb-charts\").cb_xy;\nvar help = require(\"../../util/helper.js\");\n\nvar scaleNames = [\"primaryScale\", \"secondaryScale\"];\n\n/**\n * ### Component that renders XY (line, column, dot) charts\n * @property {boolean} editable - Allow the rendered component to interacted with and edited\n * @property {object} displayConfig - Parsed visual display configuration for chart grid\n * @property {object} chartProps - Properties used to draw this chart\n * @property {object} metadata - Title, data source, etc\n * @instance\n * @memberof renderers\n */\nvar XYRenderer = React.createClass({displayName: \"XYRenderer\",\n\n\tpropTypes: {\n\t\tdisplayConfig: PropTypes.shape({\n\t\t\tmargin: PropTypes.object.isRequired,\n\t\t\tpadding: PropTypes.object.isRequired,\n\t\t\tlabelRectSize: PropTypes.number.isRequired,\n\t\t\tafterLegend: PropTypes.number.isRequired\n\t\t}).isRequired,\n\t\tchartProps: PropTypes.shape({\n\t\t\tchartSettings: PropTypes.array.isRequired,\n\t\t\tdata: PropTypes.array.isRequired,\n\t\t\tscale: PropTypes.object.isRequired,\n\t\t\t_annotations: PropTypes.object,\n\t\t\tdate: PropTypes.object,\n\t\t\tmobile: PropTypes.object\n\t\t}).isRequired,\n\t\tmetadata: PropTypes.object,\n\t\tshowMetadata: PropTypes.bool,\n\t\teditable: PropTypes.bool,\n\t\tuseMobileSettings: PropTypes.bool\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tlabelYMax: 0,\n\t\t\tmaxTickWidth: {\n\t\t\t\tprimaryScale: 0,\n\t\t\t\tsecondaryScale: 0\n\t\t\t}\n\t\t};\n\t},\n\n\tmixins: [ChartRendererMixin],\n\n\t_handleMaxTickWidth: function(k, v) {\n\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\tmaxTickWidth[k] = v;\n\t\tthis._handleStateUpdate(\"maxTickWidth\", maxTickWidth);\n\t},\n\n\t_updateLabelYMax: function(labelYMax) {\n\t\tthis.setState({ labelYMax: labelYMax });\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tif (nextProps.chartProps._numSecondaryAxis === 0) {\n\t\t\tvar maxTickWidth = this.state.maxTickWidth;\n\t\t\tmaxTickWidth.secondaryScale = 0;\n\t\t\tthis.setState({ maxTickWidth: maxTickWidth });\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar _chartProps = this.props.chartProps;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar axis = d3.svg.axis();\n\t\tvar axisTicks = [];\n\t\tvar labelComponents;\n\t\tvar dimensions = this.props.dimensions;\n\n\t\t// Dimensions of the chart area\n\t\tvar chartAreaDimensions = {\n\t\t\twidth: (dimensions.width -\n\t\t\t\t\t\t\tdisplayConfig.margin.left - displayConfig.margin.right -\n\t\t\t\t\t\t\tdisplayConfig.padding.left - displayConfig.padding.right -\n\t\t\t\t\t\t\tthis.state.maxTickWidth.primaryScale - this.state.maxTickWidth.secondaryScale),\n\t\t\theight: (dimensions.height -\n\t\t\t\t\t\t\t displayConfig.margin.top - displayConfig.margin.bottom -\n\t\t\t\t\t\t\t displayConfig.padding.top - displayConfig.padding.bottom)\n\t\t};\n\n\t\tif (this.props.enableResponsive && _chartProps.hasOwnProperty(\"mobile\") && this.props.isSmall) {\n\t\t\tif (_chartProps.mobile.scale) {\n\t\t\t\tscale = assign({}, _chartProps.scale, _chartProps.mobile.scale);\n\t\t\t} else {\n\t\t\t\tscale = _chartProps.scale;\n\t\t\t}\n\t\t} else {\n\t\t\tscale = _chartProps.scale;\n\t\t}\n\n\t\t// apply `chartSettings` to data\n\t\tvar dataWithSettings = this._applySettingsToData(_chartProps);\n\t\t// compute margin based on existence of labels and title, based on default\n\t\t// margin set in config\n\t\tvar labels = _chartProps._annotations.labels;\n\t\tvar hasTitle = (this.props.metadata.title.length > 0 && this.props.showMetadata);\n\n\t\t// compute the max tick width for each scale\n\t\teach(scaleNames, function(scaleKey) {\n\t\t\tvar currScale = scale[scaleKey];\n\n\t\t\tif (currScale) {\n\t\t\t\t// get the tick values so that we can pass them both to the actual chart\n\t\t\t\t// renderer and to the component that will render hidden ticks\n\t\t\t\tvar tickValues = currScale.tickValues;\n\n\t\t\t\tvar skipFirstNode = filter(tickValues, function(d) {\n\t\t\t\t\treturn (d !== currScale.domain[1]);\n\t\t\t\t});\n\n\t\t\t\tvar formattedTicks = map(skipFirstNode, function(tick) {\n\t\t\t\t\treturn help.roundToPrecision(tick, currScale.precision);\n\t\t\t\t});\n\n\t\t\t\taxisTicks.push({\n\t\t\t\t\tname: scaleKey,\n\t\t\t\t\ttickValues: tickValues,\n\t\t\t\t\tformattedTicks: formattedTicks,\n\t\t\t\t\tprecision: currScale.precision,\n\t\t\t\t\tmax: currScale.domain[1]\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\n\t\t// Render hidden y-axis ticks in order to compute the maxTickWidth\n\t\t// independent of rendering the chart itself, this is needed to set the\n\t\t// appropriate padding for the chart. We must do this for each y-axis.\n\t\tvar HiddenAxes = map(axisTicks, function(axis, i) {\n\t\t\treturn (\n\t\t\t\tReact.createElement(HiddenSvg.HiddenSvgAxis, {\n\t\t\t\t\tclassName: \"tick\", \n\t\t\t\t\tchartWidth: dimensions.width, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth[axis.name], \n\t\t\t\t\tformattedText: axis.formattedTicks, \n\t\t\t\t\tblockerRectOffset: this.props.displayConfig.blockerRectOffset, \n\t\t\t\t\tkey: i, \n\t\t\t\t\tonUpdate: this._handleMaxTickWidth.bind(null, axis.name)}\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\n\t\tif (this.state.maxTickWidth.primaryScale <= 0) {\n\t\t\t// We have not yet calculated maxTickWidth\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", null, HiddenAxes)\n\t\t\t);\n\t\t}\n\n\t\t// Create array of chart-specific components that will be passed to the Svg\n\t\t// chart template, which adds title/credit/source etc\n\t\treturn (\n\t\t\tReact.createElement(\"g\", null, \n\t\t\t\tReact.createElement(XYChart, {\n\t\t\t\t\tkey: \"xy-chart\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tmetadata: this.props.metadata, \n\t\t\t\t\tlabelYMax: this.state.labelYMax, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\taxisTicks: axisTicks}\n\t\t\t\t), \n\t\t\t\tReact.createElement(XYLabels, {\n\t\t\t\t\tkey: \"xy-labels\", \n\t\t\t\t\tchartProps: _chartProps, \n\t\t\t\t\tdisplayConfig: this.props.displayConfig, \n\t\t\t\t\tstyleConfig: this.props.styleConfig, \n\t\t\t\t\tchartAreaDimensions: chartAreaDimensions, \n\t\t\t\t\tdata: dataWithSettings, \n\t\t\t\t\thasTitle: hasTitle, \n\t\t\t\t\tscale: scale, \n\t\t\t\t\teditable: this.props.editable, \n\t\t\t\t\tmaxTickWidth: this.state.maxTickWidth, \n\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\tupdateLabelYMax: this._updateLabelYMax, \n\t\t\t\t\tlabelYMax: this.state.labelYMax}\n\t\t\t\t), \n\t\t\t\tHiddenAxes\n\t\t\t)\n\t\t);\n\t}\n});\n\n/**\n * ### Component that renders the XY chart area (not annotations)\n * See `React.PropTypes` declaration:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYChart = React.createClass({displayName: \"XYChart\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tpaddingTop: 0,\n\t\t\tlabelsDragged: false\n\t\t}\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentDidMount: function() {\n\t\t// Draw chart once mounted\n\t\tvar el = this.getDOMNode();\n\n\t\tif (this.props.chartProps.data.length === 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\t// On component mount, delete any existing chart\n\t\t\tif (el.childNodes[0]) {\n\t\t\t\tel.removeChild(el.childNodes[0]);\n\t\t\t}\n\t\t\tdrawXY(el, this._getChartState(this.props));\n\t\t}\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\t// always update by redrawing the chart\n\t\tvar el = this.getDOMNode();\n\t\tdrawXY(el, this._getChartState(nextProps));\n\t\treturn false;\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\tthis.setState({\n\t\t\tyOffset: yOffset\n\t\t});\n\t},\n\n\t_getChartState: function(props) {\n\t\t// Generate and return the state needed to draw the chart. This is what will\n\t\t// passed to the d4/d3 draw function.\n\t\tvar dateSettings;\n\t\tif (props.chartProps.scale.hasDate) {\n\t\t\tdateSettings = this.generateDateScale(props);\n\t\t}\n\t\tvar computedPadding = computePadding(props);\n\t\tvar hasColumn = some(props.chartProps.chartSettings, function(setting) {\n\t\t\treturn setting.type == \"column\";\n\t\t});\n\n\t\treturn {\n\t\t\tchartRenderer: cb_xy(),\n\t\t\tstyleConfig: props.styleConfig,\n\t\t\tdisplayConfig: props.displayConfig,\n\t\t\tdateSettings: dateSettings,\n\t\t\tmaxTickWidth: props.maxTickWidth,\n\t\t\thasColumn: hasColumn,\n\t\t\taxisTicks: props.axisTicks,\n\t\t\tdimensions: props.dimensions,\n\t\t\tdata: props.data,\n\t\t\tpadding: computedPadding,\n\t\t\tchartProps: props.chartProps,\n\t\t\tscale: props.scale\n\t\t};\n\t},\n\n\trender: function() {\n\t\t// empty <svg:g> that will be drawn into using `this.getDOMNode()`\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"renderer-chart\"}\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * ### Component that renders the legend labels for an XY chart\n * See `React.PropTypes` declaration for properties:\n * @example\n * propTypes: {\n *   chartProps: PropTypes.object.isRequired,\n *   hasTitle: PropTypes.bool.isRequired,\n *   displayConfig: PropTypes.object.isRequired,\n *   styleConfig: PropTypes.object.isRequired,\n *   data: PropTypes.arrayOf(PropTypes.object).isRequired,\n *   dimensions: PropTypes.shape({\n *     width: PropTypes.number,\n *     height: PropTypes.number\n *   }).isRequired,\n *   scale: PropTypes.object.isRequired,\n *   chartAreaDimensions: PropTypes.object,\n *   metadata: PropTypes.object,\n *   labelYMax: PropTypes.number,\n *   updateLabelYMax: PropTypes.func,\n *   maxTickWidth: PropTypes.object,\n *   axisTicks: PropTypes.array\n * },\n * @instance\n * @memberof XYRenderer\n */\nvar XYLabels = React.createClass({displayName: \"XYLabels\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tupdateLabelYMax: PropTypes.func,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tyOffset: 10,\n\t\t\tundraggedLabels: {},\n\t\t\tdateScaleInfo: null\n\t\t};\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Determine how far down vertically the labels should be placed, depending\n\t\t// on presence (or not) of a title\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\t/*\n\t\t* We use this XYLabels component's state to save locations of undragged\n\t\t* labels. Dragged labels are saved to the parent store so that they can be\n\t\t* reloaded later.\n\t\t*/\n\t\t/* Make sure only undragged labels exist in XYLabels state, removing others */\n\t\tvar updateUndragged = reduce(nextProps.chartProps._annotations.labels.values, function(obj, v, i) {\n\t\t\tif (!v.dragged) {\n\t\t\t\tif (this.state.undraggedLabels[i]) {\n\t\t\t\t\tobj[i] = this.state.undraggedLabels[i];\n\t\t\t\t\treturn obj;\n\t\t\t\t} else {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}, {}, this);\n\t\tthis.setState({\n\t\t\tyOffset: yOffset,\n\t\t\tundraggedLabels: updateUndragged,\n\t\t\tdateScaleInfo: nextProps.chartProps.scale.hasDate ? this.generateDateScale(nextProps) : null\n\t\t});\n\t},\n\n\t_getLabelYMax: function(labels, height) {\n\t\tvar labelYMax = 0;\n\n\t\t// Find out how much vertical space the labels are taking up\n\t\t// by identifying the one with the largest `y` value\n\t\t// Only do this if the labels have not been dragged\n\t\tif (!labels.hasDragged) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar currLabel = labels[i];\n\t\t\t\tif (currLabel) {\n\t\t\t\t\tif (currLabel.y > labelYMax) {\n\t\t\t\t\t\tlabelYMax = currLabel.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\treturn labelYMax;\n\t},\n\n\t_computePadding: function(props) {\n\t\treturn computePadding(props)\n\t},\n\n\t_enableDrag: function() {\n\t\t// tell the parent app that dragging has been enabled\n\t\tvar annotations = this.props.chartProps._annotations;\n\t\tannotations.labels.hasDragged = true;\n\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t},\n\n\t_handleLabelPositionUpdate: function(ix, pos) {\n\t\t/* If a label is dragged, update its position in the parent app */\n\t\tif (pos.dragged) {\n\t\t\tvar values = clone(this.props.chartProps._annotations.labels.values);\n\t\t\tvalues[ix] = pos;\n\t\t\tvar annotations = update(this.props.chartProps._annotations, { $merge: {\n\t\t\t\tlabels: {\n\t\t\t\t\tvalues: values,\n\t\t\t\t\thasDragged: this.props.chartProps._annotations.labels.hasDragged\n\t\t\t\t}\n\t\t\t}});\n\t\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t\t/* Otherwise if undragged, update in XYLabls state */\n\t\t} else {\n\t\t\tvar undragged = this.state.undraggedLabels;\n\t\t\tundragged[ix] = pos;\n\t\t\tthis.setState(update(this.state, { $merge: {\n\t\t\t\tundraggedLabels: undragged\n\t\t\t}}));\n\t\t\tvar labelYMax = this._getLabelYMax(undragged, this.props.dimensions.height);\n\t\t\tif (labelYMax !== this.props.labelYMax) {\n\t\t\t\tthis.props.updateLabelYMax(labelYMax);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * XYLabels#_getPrevUndraggedNode\n\t * Recursively traverse through previous labels to find one that is undragged\n\t * This is used to calculate the default placement of a label (ie to the\n\t * right of the previous undragged node)\n\t * @param {number} ix - The index of this undragged node in an array of undragged nodes\n\t * @param {object[]} undraggedLabels - Position and size settings for all undraggedlabels\n\t * @instance\n\t * @memberof XYLabels\n\t */\n\t_getPrevUndraggedNode: function(ix, undraggedLabels) {\n\t\tif (ix < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (undraggedLabels[ix]) {\n\t\t\treturn undraggedLabels[ix];\n\t\t} else {\n\t\t\treturn this._getPrevUndraggedNode(ix - 1, undraggedLabels);\n\t\t}\n\t},\n\n\trender: function() {\n\t\t// create array of SvgRectLabel components\n\t\tvar labels = this.props.chartProps._annotations.labels;\n\t\tvar styleConfig = this.props.styleConfig;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar props = this.props;\n\t\tvar dimensions = props.dimensions;\n\t\tvar padding = computePadding(props, this.props.dimensions.height);\n\n\t\tvar labelConfig = {\n\t\t\txMargin: displayConfig.labelXMargin,\n\t\t\ttextMargin: displayConfig.labelTextMargin,\n\t\t\trowHeight: displayConfig.labelRowHeight,\n\t\t\trectSize: displayConfig.labelRectSize\n\t\t};\n\n\t\tvar labelComponents = [];\n\t\tif (this.props.chartProps.data.length > 1) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar labelSettings = {};\n\t\t\t\tvar prevNode = null;\n\t\t\t\tvar chartSetting = this.props.chartProps.chartSettings[i];\n\n\t\t\t\t// Use existing positions if possible\n\t\t\t\tif (labels.values[i].dragged) {\n\t\t\t\t\tlabelSettings = labels.values[i];\n\t\t\t\t} else {\n\t\t\t\t\tlabelSettings = this.state.undraggedLabels[i];\n\t\t\t\t\tprevNode = this._getPrevUndraggedNode(i - 1, this.state.undraggedLabels);\n\t\t\t\t}\n\n\t\t\t\tvar scales = this.props.scale;\n\t\t\t\tyScale_info = !chartSetting.altAxis ? scales.primaryScale : scales.secondaryScale;\n\t\t\t\txScale_info = xScaleInfo(this.props.dimensions.width,padding,styleConfig,displayConfig,{dateSettings: this.state.dateScaleInfo});\n\t\t\t\tscale = {\n\t\t\t\t\ty: {\n\t\t\t\t\t\tdomain: yScale_info.domain,\n\t\t\t\t\t\trange:[\n\t\t\t\t\t\t\tthis.props.dimensions.height - padding.bottom - displayConfig.margin.bottom,\n\t\t\t\t\t\t\tpadding.top + displayConfig.margin.top\n\t\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tx: {\n\t\t\t\t\t\tdomain: xScale_info.domain ? xScale_info.domain : [],\n\t\t\t\t\t\trange: props.chartProps.scale.hasDate ? [\n\t\t\t\t\t\t\tpadding.left + displayConfig.margin.left + this.props.maxTickWidth.primaryScale,\n\t\t\t\t\t\t\txScale_info.rangeR-padding.right-displayConfig.margin.right-this.props.maxTickWidth.secondaryScale - displayConfig.minPaddingOuter\n\t\t\t\t\t\t\t] : []\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlabelComponents.push(\n\t\t\t\t\tReact.createElement(SvgRectLabel, {\n\t\t\t\t\t\tkey: i, \n\t\t\t\t\t\ttext: chartSetting.label, \n\t\t\t\t\t\tlabelConfig: labelConfig, \n\t\t\t\t\t\tdimensions: this.props.chartAreaDimensions, \n\t\t\t\t\t\tindex: i, \n\t\t\t\t\t\tenableDrag: this._enableDrag, \n\t\t\t\t\t\tonPositionUpdate: this._handleLabelPositionUpdate, \n\t\t\t\t\t\teditable: props.editable, \n\t\t\t\t\t\toffset: { x: displayConfig.margin.left, y: this.state.yOffset}, \n\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex, \n\t\t\t\t\t\tsettings: labelSettings, \n\t\t\t\t\t\tprevNode: prevNode, \n\t\t\t\t\t\tscale: scale}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}, this);\n\t\t}\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tref: \"chartAnnotations\", \n\t\t\t\tclassName: \"renderer-annotations\", \n\t\t\t\ttransform: \"translate(\" + [displayConfig.margin.left, this.state.yOffset] + \")\"\n\t\t\t}, \n\t\t\t\tlabelComponents\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nd3.selection.prototype.moveToFront = function() {\n  return this.each(function(){\n    this.parentNode.appendChild(this);\n  });\n};\n\nvar xy_render_options = {\n\taxis : {\n\t\tafterRender: function(feature,data,chartArea,selection,isPrimary) {\n\t\t\t/* SO HERES THE DEAL\n\t\t\t// this is a lot of effort to customize axes\n\t\t\t// what we do at Quartz instead of this is build\n\t\t\t// our own d3 that draws axes exactly how we want them\n\t\t\t// If you're getting serious about customization,\n\t\t\t// I suggest you do the same.\n\t\t\t*/\n\t\t\tvar chart = this;\n\t\t\tvar ticks = selection.selectAll(\".tick\");\n\t\t\tvar text = ticks.selectAll(\"text\");\n\t\t\tvar max = d3.max(this.y.domain());\n\n\t\t\tticks.classed(\"zero\", function(d) {\n\t\t\t\treturn (d === 0);\n\t\t\t});\n\n\t\t\tif (isPrimary) {\n\t\t\t\tvar maxTick = ticks.filter(function(d) {\n\t\t\t\t\treturn (d === max);\n\t\t\t\t});\n\t\t\t\tvar maxTickRect = maxTick.selectAll(\"rect\").data([0]).enter().append(\"rect\");\n\t\t\t\tvar maxTickText = maxTick.select(\"text\");\n\t\t\t\tvar textNode = maxTickText.node();\n\t\t\t\tvar bcr = textNode.getBoundingClientRect();\n\t\t\t\tvar width = bcr.width;\n\t\t\t\tvar x = parseFloat(textNode.getAttribute(\"x\"));\n\t\t\t\tvar newX = x;\n\t\t\t\tif (width + (-x) > chart.width - 12) {\n\t\t\t\t\tnewX = width - chart.width + chart.margin.left + 12;\n\t\t\t\t\tmaxTickText.attr(\"x\", newX);\n\t\t\t\t}\n\t\t\t\tmaxTick.select(\"rect\").attr({\n\t\t\t\t\tx: newX - width,\n\t\t\t\t\ty: (-1 * bcr.height / 2),\n\t\t\t\t\twidth: width + 6,\n\t\t\t\t\theight: bcr.height\n\t\t\t\t});\n\t\t\t\tmaxTickText.moveToFront();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction drawXY(el, state) {\n\tvar chartProps = state.chartProps;\n\tvar dateSettings = state.dateSettings;\n\tvar displayConfig = state.displayConfig;\n\tvar styleConfig = state.styleConfig;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scale = state.scale;\n\t//var borderSpace = help.combineMarginPadding(chartProps.margin,chartProps.padding);\n\n\t// set the `extraPadding` based on pre-computed `maxTickWidth` values,\n\t// generated by the `HiddenAxes` component\n\tvar extraPadding = {\n\t\ttop: chartProps.extraPadding.top,\n\t\tright: Math.max(state.maxTickWidth.secondaryScale, displayConfig.minPaddingOuter),\n\t\tbottom: chartProps.extraPadding.bottom,\n\t\tleft: state.maxTickWidth.primaryScale\n\t};\n\n\tvar mixouts = chartProps._numSecondaryAxis ? [] : [\"rightAxis\"]\n\n\tvar xyChart = state.chartRenderer\n\t\t.outerWidth(state.dimensions.width)\n\t\t.outerHeight(state.dimensions.height)\n\t\t.margin(displayConfig.margin)\n\t\t.padding(state.padding)\n\t\t.extraPadding(extraPadding)\n\t\t.mixout(\"series-label\")\n\t\t.using(\"leftAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"primary\",axis,el,state)\n\t\t})\n\t\t.x(function(x) {\n\t\t\tx.key(\"entry\");\n\t\t\tvar o = xScaleInfo(this.width,this.padding,styleConfig,displayConfig,state);\n\t\t\tif (state.dateSettings) {\n\t\t\t\tx.scale(\"time\");\n\t\t\t\tx.domain(o.domain);\n\t\t\t\tx.range([o.rangeL, o.rangeR]);\n\t\t\t}\n\t\t})\n\t\t.y(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.left(function(y) {\n\t\t\ty.key(\"value\")\n\t\t\t\t.domain(scale.primaryScale.domain)\n\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t})\n\t\t.using(\"rightAxis\", function(axis){\n\t\t\tyAxisUsing.call(this,\"secondary\",axis,el,state)\n\t\t})\n\t\t.chartAreaOnTop(false)\n\t\t.using(\"xAxis\", function(axis) {\n\n\t\t\taxis.beforeRender(function(data) {\n\t\t\t\t// Center ticks if all data series are columns\n\t\t\t\tvar numColumns = filter(data, function(d) {\n\t\t\t\t\treturn d.type === \"column\";\n\t\t\t\t}).length;\n\n\t\t\t\t// Don't display the x axis grid tick if all series are columns\n\t\t\t\tif (numColumns === data.length) {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t} else {\n\t\t\t\t\taxis.innerTickSize(styleConfig.overtick_bottom);\n\t\t\t\t\tthis.container.selectAll(\".xAxis .tick\").attr(\"data-anchor\", \"start\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (state.dateSettings) {\n\t\t\t\taxis.tickValues(dateSettings.dateTicks);\n\t\t\t\taxis.tickFormat(function(d,i) {\n\t\t\t\t\treturn dateSettings.dateFormatter(d,i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\t\tif (chartProps._numSecondaryAxis > 0) {\n\t\t\txyChart.right(function(y) {\n\t\t\t\ty.key(\"value\")\n\t\t\t\t\t.domain(scale.secondaryScale.domain)\n\t\t\t\t\t.range([this.height - this.padding.bottom, state.padding.top])\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\td3.select(el)\n\t\t.datum(state.data)\n\t\t.call(xyChart);\n}\n\nfunction xScaleInfo(width, padding, styleConfig, displayConfig, state) {\n\tvar hasMultipleYAxes = false\n\tif(state.secondaryScale) {\n\t\thasMultipleYAxes = true;\n\t}\n\tif (state.chartProps && state.chartProps._numSecondaryAxis) {\n\t\thasMultipleYAxes = true;\n\t}\n\tvar o = {\n\t\trangeL: padding.left + styleConfig.xOverTick,\n\t\trangeR: width - padding.right - (hasMultipleYAxes ? styleConfig.xOverTick : 0),\n\t\tdomain: state.dateSettings ? state.dateSettings.domain : null\n\t}\n\n\tif (state.hasColumn) {\n\t\tvar numData = state.chartProps.data[0].values.length;\n\t\tvar widthPerColumn = width / numData;\n\t\to.rangeL += (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t\to.rangeR -= (widthPerColumn * displayConfig.columnPaddingCoefficient);\n\t}\n\treturn o;\n}\n\nfunction yAxisUsing(location, axis, el, state) {\n\tvar chartProps = state.chartProps;\n\tvar isPrimary = location == \"primary\"\n\tvar scale = isPrimary ? state.scale.primaryScale : state.scale.secondaryScale;\n\tvar hasOtherAxis = chartProps._numSecondaryAxis > 0;\n\tvar scaleId = isPrimary ? \"left\" : \"right\";\n\n\tif(!hasOtherAxis && !isPrimary) {\n\t\taxis.render = function() {\n\t\t\tthis.container.selectAll(\".right.axis\").remove();\n\t\t}\n\t\tstate.chartProps.extraPadding.right = 0;\n\t\treturn null;\n\t}\n\n\t// axis tick values have been computed by parent compnent in order to draw\n\t// hidden axes, so we pass them in here\n\tvar axisTicks = isPrimary ? state.axisTicks[0] : state.axisTicks[1];\n\taxis.tickValues(axisTicks.tickValues);\n\n\t// format using our precision and suffix/prefix\n\taxis.tickFormat(function(d) {\n\t\tif (d == axisTicks.max) {\n\t\t\treturn [\n\t\t\t\tscale.prefix,\n\t\t\t\thelp.roundToPrecision(d, scale.precision),\n\t\t\t\tscale.suffix\n\t\t\t].join(\"\");\n\t\t} else {\n\t\t\treturn help.roundToPrecision(d, scale.precision);\n\t\t}\n\t});\n\n\taxis.afterRender(function(feature,data,chartArea,selection) {\n\t\tthis.container.select(\".axis.\" + scaleId).selectAll(\".tick text\")\n\t\t\t.attr(\"data-color-index\", scale.colorIndex);\n\n\t\txy_render_options.axis.afterRender.call(this,feature,data,chartArea,selection,isPrimary);\n\t});\n\n\tvar innerTickSize;\n\tif (isPrimary) {\n\t\tinnerTickSize = this.width - this.padding.left - this.padding.right;\n\t\tif (hasOtherAxis) {\n\t\t\tinnerTickSize -= state.displayConfig.blockerRectOffset;\n\t\t}\n\t} else {\n\t\tinnerTickSize = 0;\n\t}\n\n\taxis.innerTickSize( innerTickSize );\n\taxis.scaleId(scaleId);\n}\n\nfunction computePadding(props, chartHeight) {\n\tvar labels = props.chartProps._annotations.labels;\n\tvar displayConfig = props.displayConfig;\n\tvar _top = (props.labelYMax * props.chartAreaDimensions.height) + displayConfig.afterLegend;\n\n\tif (props.hasTitle) {\n\t\t_top += displayConfig.afterTitle;\n\t}\n\n\t// Maintain space between legend and chart area unless all legend labels\n\t// have been dragged\n\tvar allLabelsDragged = reduce(labels.values, function(prev, value) {\n\t\treturn (prev === true && value.dragged === true);\n\t}, true);\n\n\t// Reduce top padding if all labels or dragged or there is only one series,\n\t// meaning no label will be shown\n\tif (allLabelsDragged || props.chartProps.data.length === 1) {\n\t\t_top -= displayConfig.afterLegend;\n\t}\n\treturn {\n\t\ttop: _top,\n\t\tright: displayConfig.padding.right,\n\t\tbottom: displayConfig.padding.bottom,\n\t\tleft: displayConfig.padding.left\n\t};\n}\n\nmodule.exports = XYRenderer;",
                  "path": "src/js/components/chart-xy/XYRenderer.jsx",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYRenderer.jsx#L378-L603"
                },
                "examples": [
                  "propTypes: {\n  chartProps: PropTypes.object.isRequired,\n  hasTitle: PropTypes.bool.isRequired,\n  displayConfig: PropTypes.object.isRequired,\n  styleConfig: PropTypes.object.isRequired,\n  data: PropTypes.arrayOf(PropTypes.object).isRequired,\n  dimensions: PropTypes.shape({\n    width: PropTypes.number,\n    height: PropTypes.number\n  }).isRequired,\n  scale: PropTypes.object.isRequired,\n  chartAreaDimensions: PropTypes.object,\n  metadata: PropTypes.object,\n  labelYMax: PropTypes.number,\n  updateLabelYMax: PropTypes.func,\n  maxTickWidth: PropTypes.object,\n  axisTicks: PropTypes.array\n},"
                ],
                "scope": "instance",
                "memberof": "XYRenderer",
                "name": "XYLabels",
                "kind": "function",
                "members": {
                  "instance": [
                    {
                      "description": "XYLabels#_getPrevUndraggedNode\nRecursively traverse through previous labels to find one that is undragged\nThis is used to calculate the default placement of a label (ie to the\nright of the previous undragged node)",
                      "tags": [
                        {
                          "title": "param",
                          "description": "The index of this undragged node in an array of undragged nodes",
                          "type": {
                            "type": "NameExpression",
                            "name": "number"
                          },
                          "name": "ix"
                        },
                        {
                          "title": "param",
                          "description": "Position and size settings for all undraggedlabels",
                          "type": {
                            "type": "TypeApplication",
                            "expression": {
                              "type": "NameExpression",
                              "name": "Array"
                            },
                            "applications": [
                              {
                                "type": "NameExpression",
                                "name": "object"
                              }
                            ]
                          },
                          "name": "undraggedLabels"
                        },
                        {
                          "title": "instance",
                          "description": null
                        },
                        {
                          "title": "memberof",
                          "description": "XYLabels"
                        },
                        {
                          "title": "name",
                          "name": "_getPrevUndraggedNode"
                        },
                        {
                          "title": "kind",
                          "kind": "function"
                        }
                      ],
                      "context": {
                        "loc": {
                          "start": {
                            "line": 510,
                            "column": 1
                          },
                          "end": {
                            "line": 520,
                            "column": 2
                          }
                        },
                        "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/chart-xy/XYRenderer.jsx",
                        "code": "{displayName: \"XYLabels\",\n\n\tpropTypes: {\n\t\tchartProps: PropTypes.object.isRequired,\n\t\thasTitle: PropTypes.bool.isRequired,\n\t\tdisplayConfig: PropTypes.object.isRequired,\n\t\tstyleConfig: PropTypes.object.isRequired,\n\t\tdata: PropTypes.arrayOf(PropTypes.object).isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tchartAreaDimensions: PropTypes.object,\n\t\tmetadata: PropTypes.object,\n\t\tlabelYMax: PropTypes.number,\n\t\tupdateLabelYMax: PropTypes.func,\n\t\tmaxTickWidth: PropTypes.object,\n\t\taxisTicks: PropTypes.array\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tyOffset: 10,\n\t\t\tundraggedLabels: {},\n\t\t\tdateScaleInfo: null\n\t\t};\n\t},\n\n\tmixins: [ DateScaleMixin ],\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Determine how far down vertically the labels should be placed, depending\n\t\t// on presence (or not) of a title\n\t\tvar yOffset;\n\t\tif (nextProps.hasTitle) {\n\t\t\tyOffset = nextProps.displayConfig.margin.top + nextProps.displayConfig.afterTitle;\n\t\t} else {\n\t\t\tyOffset = nextProps.displayConfig.margin.top;\n\t\t}\n\n\t\t/*\n\t\t* We use this XYLabels component's state to save locations of undragged\n\t\t* labels. Dragged labels are saved to the parent store so that they can be\n\t\t* reloaded later.\n\t\t*/\n\t\t/* Make sure only undragged labels exist in XYLabels state, removing others */\n\t\tvar updateUndragged = reduce(nextProps.chartProps._annotations.labels.values, function(obj, v, i) {\n\t\t\tif (!v.dragged) {\n\t\t\t\tif (this.state.undraggedLabels[i]) {\n\t\t\t\t\tobj[i] = this.state.undraggedLabels[i];\n\t\t\t\t\treturn obj;\n\t\t\t\t} else {\n\t\t\t\t\treturn obj;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}, {}, this);\n\t\tthis.setState({\n\t\t\tyOffset: yOffset,\n\t\t\tundraggedLabels: updateUndragged,\n\t\t\tdateScaleInfo: nextProps.chartProps.scale.hasDate ? this.generateDateScale(nextProps) : null\n\t\t});\n\t},\n\n\t_getLabelYMax: function(labels, height) {\n\t\tvar labelYMax = 0;\n\n\t\t// Find out how much vertical space the labels are taking up\n\t\t// by identifying the one with the largest `y` value\n\t\t// Only do this if the labels have not been dragged\n\t\tif (!labels.hasDragged) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar currLabel = labels[i];\n\t\t\t\tif (currLabel) {\n\t\t\t\t\tif (currLabel.y > labelYMax) {\n\t\t\t\t\t\tlabelYMax = currLabel.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t\treturn labelYMax;\n\t},\n\n\t_computePadding: function(props) {\n\t\treturn computePadding(props)\n\t},\n\n\t_enableDrag: function() {\n\t\t// tell the parent app that dragging has been enabled\n\t\tvar annotations = this.props.chartProps._annotations;\n\t\tannotations.labels.hasDragged = true;\n\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t},\n\n\t_handleLabelPositionUpdate: function(ix, pos) {\n\t\t/* If a label is dragged, update its position in the parent app */\n\t\tif (pos.dragged) {\n\t\t\tvar values = clone(this.props.chartProps._annotations.labels.values);\n\t\t\tvalues[ix] = pos;\n\t\t\tvar annotations = update(this.props.chartProps._annotations, { $merge: {\n\t\t\t\tlabels: {\n\t\t\t\t\tvalues: values,\n\t\t\t\t\thasDragged: this.props.chartProps._annotations.labels.hasDragged\n\t\t\t\t}\n\t\t\t}});\n\t\t\tChartViewActions.updateChartProp(\"_annotations\", annotations);\n\t\t/* Otherwise if undragged, update in XYLabls state */\n\t\t} else {\n\t\t\tvar undragged = this.state.undraggedLabels;\n\t\t\tundragged[ix] = pos;\n\t\t\tthis.setState(update(this.state, { $merge: {\n\t\t\t\tundraggedLabels: undragged\n\t\t\t}}));\n\t\t\tvar labelYMax = this._getLabelYMax(undragged, this.props.dimensions.height);\n\t\t\tif (labelYMax !== this.props.labelYMax) {\n\t\t\t\tthis.props.updateLabelYMax(labelYMax);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * XYLabels#_getPrevUndraggedNode\n\t * Recursively traverse through previous labels to find one that is undragged\n\t * This is used to calculate the default placement of a label (ie to the\n\t * right of the previous undragged node)\n\t * @param {number} ix - The index of this undragged node in an array of undragged nodes\n\t * @param {object[]} undraggedLabels - Position and size settings for all undraggedlabels\n\t * @instance\n\t * @memberof XYLabels\n\t */\n\t_getPrevUndraggedNode: function(ix, undraggedLabels) {\n\t\tif (ix < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (undraggedLabels[ix]) {\n\t\t\treturn undraggedLabels[ix];\n\t\t} else {\n\t\t\treturn this._getPrevUndraggedNode(ix - 1, undraggedLabels);\n\t\t}\n\t},\n\n\trender: function() {\n\t\t// create array of SvgRectLabel components\n\t\tvar labels = this.props.chartProps._annotations.labels;\n\t\tvar styleConfig = this.props.styleConfig;\n\t\tvar displayConfig = this.props.displayConfig;\n\t\tvar props = this.props;\n\t\tvar dimensions = props.dimensions;\n\t\tvar padding = computePadding(props, this.props.dimensions.height);\n\n\t\tvar labelConfig = {\n\t\t\txMargin: displayConfig.labelXMargin,\n\t\t\ttextMargin: displayConfig.labelTextMargin,\n\t\t\trowHeight: displayConfig.labelRowHeight,\n\t\t\trectSize: displayConfig.labelRectSize\n\t\t};\n\n\t\tvar labelComponents = [];\n\t\tif (this.props.chartProps.data.length > 1) {\n\t\t\teach(this.props.chartProps.data, function(d, i) {\n\t\t\t\tvar labelSettings = {};\n\t\t\t\tvar prevNode = null;\n\t\t\t\tvar chartSetting = this.props.chartProps.chartSettings[i];\n\n\t\t\t\t// Use existing positions if possible\n\t\t\t\tif (labels.values[i].dragged) {\n\t\t\t\t\tlabelSettings = labels.values[i];\n\t\t\t\t} else {\n\t\t\t\t\tlabelSettings = this.state.undraggedLabels[i];\n\t\t\t\t\tprevNode = this._getPrevUndraggedNode(i - 1, this.state.undraggedLabels);\n\t\t\t\t}\n\n\t\t\t\tvar scales = this.props.scale;\n\t\t\t\tyScale_info = !chartSetting.altAxis ? scales.primaryScale : scales.secondaryScale;\n\t\t\t\txScale_info = xScaleInfo(this.props.dimensions.width,padding,styleConfig,displayConfig,{dateSettings: this.state.dateScaleInfo});\n\t\t\t\tscale = {\n\t\t\t\t\ty: {\n\t\t\t\t\t\tdomain: yScale_info.domain,\n\t\t\t\t\t\trange:[\n\t\t\t\t\t\t\tthis.props.dimensions.height - padding.bottom - displayConfig.margin.bottom,\n\t\t\t\t\t\t\tpadding.top + displayConfig.margin.top\n\t\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tx: {\n\t\t\t\t\t\tdomain: xScale_info.domain ? xScale_info.domain : [],\n\t\t\t\t\t\trange: props.chartProps.scale.hasDate ? [\n\t\t\t\t\t\t\tpadding.left + displayConfig.margin.left + this.props.maxTickWidth.primaryScale,\n\t\t\t\t\t\t\txScale_info.rangeR-padding.right-displayConfig.margin.right-this.props.maxTickWidth.secondaryScale - displayConfig.minPaddingOuter\n\t\t\t\t\t\t\t] : []\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlabelComponents.push(\n\t\t\t\t\tReact.createElement(SvgRectLabel, {\n\t\t\t\t\t\tkey: i, \n\t\t\t\t\t\ttext: chartSetting.label, \n\t\t\t\t\t\tlabelConfig: labelConfig, \n\t\t\t\t\t\tdimensions: this.props.chartAreaDimensions, \n\t\t\t\t\t\tindex: i, \n\t\t\t\t\t\tenableDrag: this._enableDrag, \n\t\t\t\t\t\tonPositionUpdate: this._handleLabelPositionUpdate, \n\t\t\t\t\t\teditable: props.editable, \n\t\t\t\t\t\toffset: { x: displayConfig.margin.left, y: this.state.yOffset}, \n\t\t\t\t\t\tcolorIndex: chartSetting.colorIndex, \n\t\t\t\t\t\tsettings: labelSettings, \n\t\t\t\t\t\tprevNode: prevNode, \n\t\t\t\t\t\tscale: scale}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}, this);\n\t\t}\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tref: \"chartAnnotations\", \n\t\t\t\tclassName: \"renderer-annotations\", \n\t\t\t\ttransform: \"translate(\" + [displayConfig.margin.left, this.state.yOffset] + \")\"\n\t\t\t}, \n\t\t\t\tlabelComponents\n\t\t\t)\n\t\t);\n\t}\n\n}",
                        "path": "src/js/components/chart-xy/XYRenderer.jsx",
                        "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/chart-xy/XYRenderer.jsx#L510-L520"
                      },
                      "params": [
                        {
                          "title": "param",
                          "description": "The index of this undragged node in an array of undragged nodes",
                          "type": {
                            "type": "NameExpression",
                            "name": "number"
                          },
                          "name": "ix"
                        },
                        {
                          "title": "param",
                          "description": "Position and size settings for all undraggedlabels",
                          "type": {
                            "type": "TypeApplication",
                            "expression": {
                              "type": "NameExpression",
                              "name": "Array"
                            },
                            "applications": [
                              {
                                "type": "NameExpression",
                                "name": "object"
                              }
                            ]
                          },
                          "name": "undraggedLabels"
                        }
                      ],
                      "scope": "instance",
                      "memberof": "XYLabels",
                      "name": "_getPrevUndraggedNode",
                      "kind": "function",
                      "members": {
                        "instance": [],
                        "static": []
                      },
                      "path": [
                        "renderers",
                        "XYRenderer",
                        "XYLabels",
                        "_getPrevUndraggedNode"
                      ]
                    }
                  ],
                  "static": []
                },
                "path": [
                  "renderers",
                  "XYRenderer",
                  "XYLabels"
                ]
              }
            ],
            "static": []
          },
          "path": [
            "renderers",
            "XYRenderer"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "renderers"
    ]
  },
  {
    "description": "### RendererWrapper\nWrapper component that determines which type of chart to render, wrapping it\nin Svg and telling it to draw.",
    "tags": [
      {
        "title": "name",
        "name": "RendererWrapper"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 44,
          "column": 0
        },
        "end": {
          "line": 332,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/RendererWrapper.jsx",
      "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\n\nvar assign = require(\"lodash/object/assign\");\nvar clone = require(\"lodash/lang/clone\");\nvar isDate = require(\"lodash/lang/isDate\");\nvar isEqual = require(\"lodash/lang/isEqual\");\nvar throttle = require(\"lodash/function/throttle\");\nvar reduce = require(\"lodash/collection/reduce\");\nvar keys = require(\"lodash/object/keys\");\nvar update = React.addons.update;\n\nvar SvgText = require(\"./svg/SvgText.jsx\");\n\nvar ChartViewActions = require(\"../actions/ChartViewActions\");\nvar convertConfig = require(\"../util/parse-config-values\");\nvar SessionStore = require(\"../stores/SessionStore\");\nvar breakpoints = require(\"../config/chart-breakpoints\");\nvar ChartFooter = require(\"./svg/ChartFooter.jsx\");\n\nvar CVM = require(\"react-component-visibility\");\n\n/*\n * `chartConfig` is an object that sets default properties for chart types, and\n * also associates a given chart type with its Editor and Renderer components.\n * Used here to identify the Renderer.\n*/\nvar chartConfigs = require(\"../charts/chart-config\");\nvar chartStyle = require(\"../config/chart-style\");\nvar chartRenderers = require(\"../charts/renderers\");\n\n/**\n * ### RendererWrapper\n * Wrapper component that determines which type of chart to render, wrapping it\n * in Svg and telling it to draw.\n*/\nvar RendererWrapper = React.createClass({displayName: \"RendererWrapper\",\n\n\tpropTypes: {\n\t\tmodel: PropTypes.shape({\n\t\t\tchartProps: PropTypes.object.isRequired,\n\t\t\tmetadata: PropTypes.object.isRequired\n\t\t}),\n\t\twidth: PropTypes.number,\n\t\tenableResponsive: PropTypes.bool,\n\t\tshowMetadata: PropTypes.bool\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tif (!nextProps.model.chartProps.input.valid) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tmixins: [ CVM ],\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tdomNodeWidth: null,\n\t\t\textraHeight: 0,\n\t\t\temSize: null,\n\t\t\tsvgSizeClass: null,\n\t\t\tchartConfig: {},\n\t\t\tstyleConfig: {}\n\t\t};\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar newType = nextProps.model.metadata.chartType;\n\t\tvar prevType = this.props.model.metadata.chartType;\n\t\tif (newType !== prevType) {\n\t\t\tvar chartConfig = convertConfig(chartConfigs[newType], null, this.state.emSize, this.state.domNodeWidth);\n\t\t\tthis.setState({ chartConfig: chartConfig });\n\t\t}\n\t},\n\n\tcomponentWillMount: function() {\n\t\tvar chartType = this.props.model.metadata.chartType;\n\t\tvar size_calcs = {};\n\t\tif (this.props.width) {\n\t\t\tvar bp = this._getBreakpointObj(this.props.width);\n\t\t\tsize_calcs = this._resizeUpdate(this.props, bp, this.props.width);\n\t\t}\n\n\t\tvar chartProps = null;\n\t\tif (this.props.model.chartProps.scale.hasDate && !this.props.editable) {\n\t\t\tvar _chartProps = clone(this.props.model.chartProps, true);\n\t\t\tvar newData = _chartProps.data.map(function(d) {\n\t\t\t\td.values = d.values.map(function(val) {\n\t\t\t\t\tif (!isDate(val.entry)) {\n\t\t\t\t\t\tval.entry = new Date(val.entry);\n\t\t\t\t\t}\n\t\t\t\t\treturn val;\n\t\t\t\t});\n\t\t\t\treturn d;\n\t\t\t});\n\t\t\t_chartProps.data = newData;\n\t\t\tchartProps = _chartProps;\n\t\t}\n\n\t\tvar state = assign({}, { chartProps: chartProps }, size_calcs);\n\t\tthis.setState(state);\n\t},\n\n\t_resizeUpdate: function(props, bp, domNodeWidth) {\n\t\tvar chartType = props.model.metadata.chartType;\n\t\treturn {\n\t\t\tdomNodeWidth: domNodeWidth,\n\t\t\temSize: bp.em_size,\n\t\t\tsvgSizeClass: bp.class_name,\n\t\t\tchartConfig: convertConfig(chartConfigs[chartType], null, bp.em_size, domNodeWidth),\n\t\t\tstyleConfig: convertConfig(chartStyle, null, bp.em_size, domNodeWidth)\n\t\t};\n\t},\n\n\tcomponentVisibilityChanged: function() {\n\t\tthis._updateWidth();\n\t},\n\n\t_updateWidth: function(force) {\n\t\t//if (this.state.visible || force === true) {\n\t\t\tvar domNodeWidth = this.getDOMNode().offsetWidth;\n\t\t\tvar bp = this._getBreakpointObj(domNodeWidth);\n\t\t\tif (domNodeWidth !== this.state.domNodeWidth) {\n\t\t\t\tvar resized = this._resizeUpdate(this.props, bp, domNodeWidth);\n\t\t\t\tif (resized) {\n\t\t\t\t\tthis.setState(resized);\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\t},\n\n\tcomponentDidMount: function() {\n\t\tif (this.props.enableResponsive) {\n\t\t\tthis._updateWidth(true);\n\t\t\tthis._updateWidth = throttle(this._updateWidth, 50);\n\t\t\twindow.addEventListener(\"resize\", this._updateWidth);\n\t\t}\n\t},\n\n\tcomponentWillUnmount: function() {\n\t\tif (this.props.enableResponsive) {\n\t\t\twindow.removeEventListener(\"resize\", this._updateWidth);\n\t\t}\n\t},\n\n\t_getBreakpointObj: function(width) {\n\t\tif (this.props.enableResponsive || !width) {\n\t\t\treturn breakpoints.filter(function(bp) {\n\t\t\t\treturn width > bp.min_size;\n\t\t\t})[0];\n\t\t} else {\n\t\t\treturn breakpoints[1];\n\t\t}\n\t},\n\n\t_getMobileMetadata: function(metadata, mobileSettings) {\n\t\tvar setMobile = reduce(keys(metadata), function(obj, key) {\n\t\t\tif (mobileSettings[key] && mobileSettings[key] !== \"\") {\n\t\t\t\tobj[key] = mobileSettings[key];\n\t\t\t\treturn obj;\n\t\t\t} else {\n\t\t\t\tobj[key] = metadata[key];\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}, {});\n\t\treturn setMobile;\n\t},\n\n\t_handleSvgUpdate: function(k, v) {\n\t\tvar newSetting = {};\n\t\tnewSetting[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newSetting }));\n\t},\n\n\t_calculateDimensions: function(width, displayConfig) {\n\t\tvar calculator = this.state.chartConfig.calculateDimensions;\n\t\treturn calculator(width, {\n\t\t\tmodel: this.props.model,\n\t\t\tdisplayConfig: displayConfig,\n\t\t\tenableResponsive: this.props.enableResponsive,\n\t\t\textraHeight: this.state.extraHeight,\n\t\t\tshowMetadata: this.props.showMetadata\n\t\t});\n\t},\n\n\trender: function() {\n\t\tvar chartType = this.props.model.metadata.chartType;\n\t\tvar width = this.props.width || this.state.domNodeWidth;\n\t\tvar displayConfig = this.state.chartConfig.display;\n\n\t\tif (!width) {\n\t\t\treturn React.createElement(\"div\", {style: { width: \"100%\"}});\n\t\t}\n\n\t\t// Reduce padding and margin if metadata is not shown\n\t\tif (this.props.showMetadata === false) {\n\t\t\tvar _padding = {\n\t\t\t\ttop: displayConfig.padding.top,\n\t\t\t\tright: displayConfig.padding.right,\n\t\t\t\tbottom: displayConfig.bottomPaddingWithoutFooter,\n\t\t\t\tleft: displayConfig.padding.left,\n\t\t\t};\n\t\t\tvar _margin = {\n\t\t\t\ttop: displayConfig.margin.top,\n\t\t\t\tright: 3,\n\t\t\t\tbottom: 3,\n\t\t\t\tleft: 3\n\t\t\t};\n\t\t\tdisplayConfig = update(displayConfig, { $merge: {\n\t\t\t\tpadding: _padding,\n\t\t\t\tmargin: _margin\n\t\t\t}});\n\t\t}\n\n\t\tvar dimensions = this._calculateDimensions(width, displayConfig);\n\n\t\ttry {\n\t\t\tif (isNaN(dimensions.width)) {\n\t\t\t\tthrow new TypeError(\"In RendererWrapper, `dimensions.height` must be a number\");\n\t\t\t}\n\t\t\tif (isNaN(dimensions.height)) {\n\t\t\t\tthrow new TypeError(\"In RendererWrapper, `dimensions.width` must be a number\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e.name, e.message);\n\t\t}\n\n\t\tvar Renderer = chartRenderers[chartType];\n\t\tvar chartProps;\n\t\tvar metadata;\n\n\t\t// If rendered chart is not editable and has a date, we presume data is\n\t\t// being passed in and we need to use the data with processed dates\n\t\tif (this.props.model.chartProps.scale.hasDate && !this.props.editable) {\n\t\t\tchartProps = this.state.chartProps;\n\t\t} else {\n\t\t\tchartProps = this.props.model.chartProps;\n\t\t}\n\n\t\tvar isSmall = (this.state.svgSizeClass === \"small\");\n\n\t\t// override metadats with mobile-specific settings if defined\n\t\tif (this.props.enableResponsive && this.props.model.chartProps.mobile && isSmall) {\n\t\t\tmetadata = this._getMobileMetadata(this.props.model.metadata, this.props.model.chartProps.mobile);\n\t\t} else {\n\t\t\tmetadata = this.props.model.metadata;\n\t\t}\n\n\t\tvar margin = this.state.chartConfig.display.margin;\n\t\tvar metadataSvg = [];\n\t\tvar title;\n\n\t\tvar translate = {\n\t\t\ttop: margin.top,\n\t\t\tright: dimensions.width - margin.right,\n\t\t\tbottom: dimensions.height - margin.bottom,\n\t\t\tleft: margin.left\n\t\t};\n\n\t\tif (this.props.showMetadata) {\n\t\t\tif (metadata.title && metadata.title !== \"\") {\n\t\t\t\ttitle = (\n\t\t\t\t\tReact.createElement(SvgText, {\n\t\t\t\t\t\ttext: metadata.title, \n\t\t\t\t\t\tkey: \"title\", \n\t\t\t\t\t\ttranslate: [translate.left, translate.top], \n\t\t\t\t\t\talign: \"top\", \n\t\t\t\t\t\tclassName: \"svg-text-title\"}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tmetadataSvg.push(title);\n\t\t\t}\n\n\t\t\tmetadataSvg.push(\n\t\t\t\tReact.createElement(ChartFooter, {\n\t\t\t\t\tmetadata: metadata, \n\t\t\t\t\textraHeight: this.state.extraHeight, \n\t\t\t\t\tkey: \"chartFooter\", \n\t\t\t\t\ttranslate: translate, \n\t\t\t\t\tonUpdate: this._handleSvgUpdate.bind(null, \"extraHeight\"), \n\t\t\t\t\tchartWidth: dimensions.width - margin.left - margin.right, \n\t\t\t\t\tclassName: \"svg-credit-data\"}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"div\", {className: [\"renderer-wrapper\", this.state.svgSizeClass, this.props.className].join(\" \")}, \n\t\t\t\tReact.createElement(\"svg\", {\n\t\t\t\t\tkey: chartType, \n\t\t\t\t\tclassName: \"renderer-svg\", \n\t\t\t\t\twidth: dimensions.width, \n\t\t\t\t\theight: dimensions.height\n\t\t\t\t}, \n\t\t\t\t\tReact.createElement(\"g\", {className: \"svg-background-wrap\"}, \n\t\t\t\t\t\tReact.createElement(\"rect\", {\n\t\t\t\t\t\t\tclassName: \"svg-background\", \n\t\t\t\t\t\t\twidth: dimensions.width, \n\t\t\t\t\t\t\theight: dimensions.height, \n\t\t\t\t\t\t\tx: 0, \n\t\t\t\t\t\t\ty: 0}\n\t\t\t\t\t\t)\n\t\t\t\t\t), \n\t\t\t\t\tReact.createElement(Renderer, {\n\t\t\t\t\t\twidth: width, \n\t\t\t\t\t\textraHeight: this.state.extraHeight, \n\t\t\t\t\t\tchartProps: chartProps, \n\t\t\t\t\t\tdimensions: dimensions, \n\t\t\t\t\t\tisSmall: isSmall, \n\t\t\t\t\t\tdisplayConfig: displayConfig, \n\t\t\t\t\t\tstyleConfig: this.state.styleConfig, \n\t\t\t\t\t\tshowMetadata: this.props.showMetadata, \n\t\t\t\t\t\tmetadata: metadata, \n\t\t\t\t\t\teditable: this.props.editable, \n\t\t\t\t\t\tenableResponsive: this.props.enableResponsive}\n\t\t\t\t\t), \n\t\t\t\t\tmetadataSvg\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = RendererWrapper;",
      "path": "src/js/components/RendererWrapper.jsx",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/RendererWrapper.jsx#L44-L332"
    },
    "name": "RendererWrapper",
    "kind": "function",
    "members": {
      "instance": [
        {
          "description": "Render a footer with the chart credit and source",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "RendererWrapper"
            },
            {
              "title": "name",
              "name": "ChartFooter"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 17,
                "column": 0
              },
              "end": {
                "line": 117,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/svg/ChartFooter.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar shallowEqual = require(\"react/lib/shallowEqual\");\nvar SvgText = require(\"./SvgText.jsx\");\nvar update = React.addons.update;\n\n/**\n * Render a footer with the chart credit and source\n * @instance\n * @memberof RendererWrapper\n */\nvar ChartFooter = React.createClass({displayName: \"ChartFooter\",\n\n\tpropTypes: {\n\t\tmetadata: PropTypes.object,\n\t\textraHeight: PropTypes.number,\n\t\ttranslate: PropTypes.object,\n\t\tonUpdate: PropTypes.func,\n\t\tchartWidth: PropTypes.number\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tcreditDimensions: {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t},\n\t\t\tpixelsPerCharacter: 0\n\t\t};\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\treturn true;\n\t},\n\n\t_config: {\n\t\tcreditSourcePadding: 20,\n\t\theightPerLine: 15,\n\t\tsampleString: \"Data: abcdefg hijkl mnop qrstu vwxyz 1234 56789\"\n\t},\n\n\t_handleStateUpdate: function(k, v) {\n\t\tvar newValue = {};\n\t\tnewValue[k] = v;\n\t\tthis.setState(update(this.state, { $merge: newValue }));\n\t},\n\n\t_createSourceLine: function() {\n\t\tvar sourceText;\n\t\tvar sourceLine;\n\t\tif (this.props.metadata.source && this.props.metadata.source !== \"\") {\n\t\t\tsourceText = \"Data: \" + this.props.metadata.source;\n\t\t} else {\n\t\t\tsourceText = \"\";\n\t\t}\n\n\t\tif (this.props.metadata.notes && this.props.metadata.notes !== \"\") {\n\t\t\tsourceLine = [sourceText, this.props.metadata.notes].join(\" | \");\n\t\t} else {\n\t\t\tsourceLine = sourceText;\n\t\t}\n\n\t\treturn sourceLine;\n\t},\n\n\trender: function() {\n\t\tvar sourceLineText = this._createSourceLine();\n\t\tvar chartSource = null;\n\t\tvar chartCredit;\n\t\tif (sourceLineText.length > 0) {\n\t\t\tchartSource = (\n\t\t\t\tReact.createElement(ChartSourceText, {\n\t\t\t\t\ttext: sourceLineText, \n\t\t\t\t\tcreditSourcePadding: this._config.creditSourcePadding, \n\t\t\t\t\tclassName: \"svg-text-source\", \n\t\t\t\t\ttranslate: this.props.translate, \n\t\t\t\t\theightPerLine: this._config.heightPerLine, \n\t\t\t\t\textraHeight: this.props.extraHeight, \n\t\t\t\t\tcreditMargin: this.props.creditMargin, \n\t\t\t\t\tcreditDimensions: this.state.creditDimensions, \n\t\t\t\t\tpixelsPerCharacter: this.state.pixelsPerCharacter, \n\t\t\t\t\tchartWidth: this.props.chartWidth, \n\t\t\t\t\tupdateState: this._handleStateUpdate, \n\t\t\t\t\tonUpdate: this.props.onUpdate}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tchartCredit = (\n\t\t\tReact.createElement(ChartCreditText, {\n\t\t\t\ttext: this.props.metadata.credit, \n\t\t\t\tclassName: \"svg-text-credit\", \n\t\t\t\tonUpdate: this.props.onUpdate, \n\t\t\t\ttranslate: [this.props.translate.left, this.props.translate.bottom - this.props.extraHeight], \n\t\t\t\tupdateState: this._handleStateUpdate.bind(null, \"creditWidth\")}\n\t\t\t)\n\t\t);\n\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: this.props.className}, \n\t\t\t\tReact.createElement(HiddenPixelMeasure, {\n\t\t\t\t\tsampleString: this._config.sampleString, \n\t\t\t\t\tpixelsPerCharacter: this.state.pixelsPerCharacter, \n\t\t\t\t\tonUpdate: this._handleStateUpdate.bind(null, \"pixelsPerCharacter\")}\n\t\t\t\t), \n\t\t\t\tchartCredit, \n\t\t\t\tchartSource\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n// Credit text\nvar ChartCreditText = React.createClass({displayName: \"ChartCreditText\",\n\n\tcomponentDidMount: function() {\n\t\tvar node = this.getDOMNode();\n\t\tvar bbox = node.getBBox();\n\t\tthis.props.updateState(bbox.width);\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(SvgText, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\ttranslate: this.props.translate, \n\t\t\t\tclassName: \"svg-text-credit\"}\n\t\t\t)\n\t\t);\n\t}\n});\n\n// Source text\nvar ChartSourceText = React.createClass({displayName: \"ChartSourceText\",\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\townLine: false // whether source will fall onto its own line\n\t\t}\n\t},\n\n\t_handleHeightUpdate: function(height) {\n\t\tthis.props.onUpdate(height);\n\t},\n\n\trender: function() {\n\t\tvar _translate = this.props.translate;\n\t\tvar translate;\n\t\tvar classNameDirection;\n\t\tvar maxWidth;\n\n\t\tif (this.state.ownLine) {\n\t\t\ttranslate = [_translate.left, _translate.bottom - this.props.extraHeight + this.props.heightPerLine];\n\t\t\tclassNameDirection = \"left\"\n\t\t\tmaxWidth = this.props.chartWidth;\n\t\t} else {\n\t\t\ttranslate = [_translate.right, _translate.bottom];\n\t\t\tclassNameDirection = \"right\"\n\t\t\tmaxWidth = this.props.chartWidth - this.props.creditDimensions.width - this.props.creditSourcePadding;\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(SvgText, {\n\t\t\t\ttext: this.props.text, \n\t\t\t\twrap: false, \n\t\t\t\theightPerLine: this.props.heightPerLine, \n\t\t\t\tpixelsPerCharacter: this.props.pixelsPerCharacter, \n\t\t\t\tmaxWidth: this.props.chartWidth, \n\t\t\t\ttranslate: translate, \n\t\t\t\tonUpdate: this._handleHeightUpdate, \n\t\t\t\tclassName: \"svg-text-source \" + classNameDirection}\n\t\t\t));\n\t}\n});\n\n// Hidden element that renders the text of parent's `sampleString` and sets in\n// parent state the sample string's width per character.\nvar HiddenPixelMeasure = React.createClass({displayName: \"HiddenPixelMeasure\",\n\n\tcomponentDidMount: function() {\n\t\tvar textLength = this.getDOMNode().getComputedTextLength();\n\t\tthis.props.onUpdate(textLength / this.props.sampleString.length);\n\t},\n\n\tcomponentDidUpdate: function() {\n\t\tvar textLength = this.getDOMNode().getComputedTextLength();\n\t\tvar ppc = textLength / this.props.sampleString.length;\n\t\tif (ppc !== this.props.pixelsPerCharacter) {\n\t\t\tthis.props.onUpdate(ppc);\n\t\t}\n\t},\n\n\trender: function() {\n\t\treturn (\n\t\t\tReact.createElement(\"text\", {className: \"hidden-svg svg-text svg-text-source\"}, \n\t\t\t\tthis.props.sampleString\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = ChartFooter;",
            "path": "src/js/components/svg/ChartFooter.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/svg/ChartFooter.jsx#L17-L117"
          },
          "scope": "instance",
          "memberof": "RendererWrapper",
          "name": "ChartFooter",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "RendererWrapper",
            "ChartFooter"
          ]
        },
        {
          "description": "Given a set of formatted text, render hidden axis ticks and find the largest\nwidth among them, sending that number back to the parent",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "RendererWrapper"
            },
            {
              "title": "name",
              "name": "HiddenSvgAxis"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 29,
                "column": 0
              },
              "end": {
                "line": 103,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/svg/HiddenSvg.jsx",
            "code": "var React = require(\"react\");\nvar isEqual = require(\"lodash/lang/isEqual\");\nvar reduce = require(\"lodash/collection/reduce\");\n\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\n\n/*\n * Render hidden SVG elements that we will use to compute their properties\n * post-render, most importantly `getBBox()` or `getBoundingClientRect()`\n * We do this in React so that these values can be incorporated into the\n * React/Flux data flow.\n *\n * We are more aggressive with using `shouldComponentUpdate` in these components\n * because they have to talk to the actual DOM (not virtual DOM) and are\n * therefore expensive\n*/\n\n// TODO: We should make these more general components. Right now they are specific\n// to axes/bar labels, but they could easily be in the form of `findWidestText`\n// or `getFurthestRigth` or that kind of thing.\n\n/**\n * Given a set of formatted text, render hidden axis ticks and find the largest\n * width among them, sending that number back to the parent\n * @instance\n * @memberof RendererWrapper\n */\nvar HiddenSvgAxis = React.createClass({displayName: \"HiddenSvgAxis\",\n\n\tpropTypes: {\n\t\tclassName: PropTypes.string,\n\t\tonUpdate: PropTypes.func.isRequired,\n\t\tformattedText: PropTypes.array.isRequired,\n\t\tblockerRectOffset: PropTypes.number.isRequired,\n\t\tmaxTickWidth: PropTypes.number\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar isTextNew = !isEqual(this.props.formattedText, nextProps.formattedText);\n\t\tif (isTextNew) {\n\t\t\treturn true;\n\t\t}\n\t\tvar isMaxNew = (this.props.maxTickWidth !== nextProps.maxTickWidth);\n\t\tif (isMaxNew) {\n\t\t\treturn true;\n\t\t}\n\t\tvar isWidthNew = (this.props.chartWidth !== nextProps.chartWidth);\n\t\tif (isWidthNew) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_getMaxTickWidth: function(el) {\n\t\tvar text = el.getElementsByTagName(\"text\");\n\n\t\tvar newMaxTickWidth = reduce(text, function(prevWidth, currNode) {\n\t\t\tvar currWidth = currNode.getComputedTextLength();\n\t\t\treturn Math.max(prevWidth, currWidth);\n\t\t}, 0);\n\n\t\t// `newMaxTickWidth` accounts for size of the text, but we need to\n\t\t// add the size of the offset of the background blocker rect\n\t\tnewMaxTickWidth = newMaxTickWidth + this.props.blockerRectOffset;\n\t\treturn newMaxTickWidth;\n\t},\n\n\tcomponentDidMount: function(prevProps, prevState) {\n\t\tvar newMaxTickWidth = this._getMaxTickWidth(this.getDOMNode());\n\t\tthis.props.onUpdate(newMaxTickWidth);\n\t},\n\n\tcomponentDidUpdate: function(prevProps, prevState) {\n\t\tvar newMaxTickWidth = this._getMaxTickWidth(this.getDOMNode());\n\t\tif (newMaxTickWidth !== this.props.maxTickWidth) {\n\t\t\t// update `maxTickWidth` object in parent component, as it gets passed to\n\t\t\t// `XYChart`, a sibling of this component.\n\t\t\tthis.props.onUpdate(newMaxTickWidth);\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar tickText = this.props.formattedText.map(function(tick, i) {\n\t\t\t// FYI: these classNames must match the classNames used to render your\n\t\t\t// actual ticks in order for this to work\n\t\t\t// TODO: pass className via prop\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", {key: i, className: this.props.className}, \n\t\t\t\t\tReact.createElement(\"text\", {style: {\"textAnchor\": \"start\"}, x: \"0\", y: \"0\", dy: \"0.32em\"}, tick)\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"d4 hidden-svg\", transform: \"translate(\" + [0, -100] + \")\"}, \n\t\t\t\tReact.createElement(\"g\", {className: \"axis\"}, \n\t\t\t\t\ttickText\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * Given a scale, render hidden bar grid labels to find which is furthest right.\n * This allows us to increase the padding of these charts to account for the\n * extra width\n * @instance\n * @memberof RendererWrapper\n */\nvar HiddenSvgBarLabels = React.createClass({displayName: \"HiddenSvgBarLabels\",\n\n\tpropTypes: {\n\t\tonUpdate: PropTypes.func.isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tblockerRectOffset: PropTypes.number.isRequired,\n\t\tchartWidth: PropTypes.number.isRequired,\n\t\tlabelOverlap: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\teffectiveWidth: 0, // width of the chart accounting for margin/padding\n\t\t\tparentSVG: null\n\t\t}\n\t},\n\n\t_getSVGParent: function(el) {\n\t\t// we need the parent SVG to compute mouse position\n\t\tif (el.parentNode.tagName == \"svg\") {\n\t\t\treturn el.parentNode;\n\t\t} else {\n\t\t\treturn this._getSVGParent(el.parentNode);\n\t\t}\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar prevScale = this.props.scale;\n\t\tvar newScale = nextProps.scale;\n\t\tvar newPrefix = (prevScale.prefix !== newScale.prefix);\n\t\tvar newSuffix = (prevScale.suffix !== newScale.suffix);\n\t\tif (newPrefix || newSuffix) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!isEqual(prevScale.domain, newScale.domain)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.state.effectiveWidth !== nextState.effectiveWidth) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_getLabelOverlap: function(chartWidth) {\n\t\tvar el = this.getDOMNode();\n\t\tvar text = el.querySelectorAll(\"text\");\n\t\t// Find the top bar grid label that is furthest to the right\n\t\tvar furthestRight = reduce(text, function(prevRight, currNode, ix) {\n\t\t\tvar currRight = currNode.getBoundingClientRect().right;\n\t\t\treturn Math.max(prevRight, currRight);\n\t\t}, 0);\n\n\t\t// Find the label that is furthest to the right, accounting for the\n\t\t// block rect and margin\n\t\tvar parentLeft = this.state.parentSVG.getBoundingClientRect().left;\n\t\tfurthestRight += this.props.blockerRectOffset * 2 + this.props.margin.right;\n\n\t\tif (furthestRight > (chartWidth + parentLeft)) {\n\t\t\treturn furthestRight - (chartWidth + parentLeft);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\t_createScale: function(props) {\n\t\t// Create a d3 scale based on our chart properties, so that we can \"place\"\n\t\t// the hidden label and see if it is too far to the right\n\t\treturn d3.scale.linear()\n\t\t\t.range([props.offset.left, props.chartWidth - props.offset.right])\n\t\t\t.domain(props.scale.domain);\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Find the effective width of the chart area and set this in current\n\t\t// component's state\n\t\tthis.setState({\n\t\t\teffectiveWidth: nextProps.chartWidth - nextProps.margin.right - nextProps.margin.left\n\t\t});\n\t},\n\n\tcomponentDidMount: function(prevProps, prevState) {\n\t\t// Set the initial labelOverlap on mount\n\t\tthis.setState({ parentSVG: this._getSVGParent(this.getDOMNode())}, function() {\n\t\t\tvar labelOverlap = this._getLabelOverlap(this.props.chartWidth);\n\t\t\tthis.props.onUpdate(labelOverlap);\n\t\t})\n\t},\n\n\tcomponentDidUpdate: function(prevProps, prevState) {\n\t\tvar labelOverlap = this._getLabelOverlap(this.props.chartWidth);\n\t\tif (labelOverlap !== this.props.labelOverlap) {\n\t\t\t// Update new `labelOverlap` if it has changed\n\t\t\tthis.props.onUpdate(labelOverlap);\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar scale = this.props.scale;\n\t\tvar d3scale = this._createScale(this.props);\n\n\t\tvar labelText = this.props.formattedText.map(function(label, i) {\n\t\t\tvar translateX;\n\t\t\tif (label == \"no data\") {\n\t\t\t\ttranslateX = d3scale(scale.domain[0]);\n\t\t\t} else {\n\t\t\t\ttranslateX = d3scale(label.value);\n\t\t\t}\n\t\t\tvar translate = [ translateX, -100 ];\n\t\t\t// ATTN: these classNames must match the classNames used to render your\n\t\t\t// actual ticks in order for this to work\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", {\n\t\t\t\t\tkey: i, \n\t\t\t\t\tclassName: this.props.className, \n\t\t\t\t\ttransform: \"translate(\" + translate + \")\"\n\t\t\t\t}, \n\t\t\t\t\tReact.createElement(\"text\", null, label.formatted)\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"d4 hidden-svg\"}, \n\t\t\t\tReact.createElement(\"g\", {className: \"axis\"}, \n\t\t\t\t\tlabelText\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = {\n\tHiddenSvgAxis: HiddenSvgAxis,\n\tHiddenSvgBarLabels: HiddenSvgBarLabels\n};",
            "path": "src/js/components/svg/HiddenSvg.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/svg/HiddenSvg.jsx#L29-L103"
          },
          "scope": "instance",
          "memberof": "RendererWrapper",
          "name": "HiddenSvgAxis",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "RendererWrapper",
            "HiddenSvgAxis"
          ]
        },
        {
          "description": "Given a scale, render hidden bar grid labels to find which is furthest right.\nThis allows us to increase the padding of these charts to account for the\nextra width",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "RendererWrapper"
            },
            {
              "title": "name",
              "name": "HiddenSvgBarLabels"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 112,
                "column": 0
              },
              "end": {
                "line": 241,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/svg/HiddenSvg.jsx",
            "code": "var React = require(\"react\");\nvar isEqual = require(\"lodash/lang/isEqual\");\nvar reduce = require(\"lodash/collection/reduce\");\n\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar PropTypes = React.PropTypes;\n\n/*\n * Render hidden SVG elements that we will use to compute their properties\n * post-render, most importantly `getBBox()` or `getBoundingClientRect()`\n * We do this in React so that these values can be incorporated into the\n * React/Flux data flow.\n *\n * We are more aggressive with using `shouldComponentUpdate` in these components\n * because they have to talk to the actual DOM (not virtual DOM) and are\n * therefore expensive\n*/\n\n// TODO: We should make these more general components. Right now they are specific\n// to axes/bar labels, but they could easily be in the form of `findWidestText`\n// or `getFurthestRigth` or that kind of thing.\n\n/**\n * Given a set of formatted text, render hidden axis ticks and find the largest\n * width among them, sending that number back to the parent\n * @instance\n * @memberof RendererWrapper\n */\nvar HiddenSvgAxis = React.createClass({displayName: \"HiddenSvgAxis\",\n\n\tpropTypes: {\n\t\tclassName: PropTypes.string,\n\t\tonUpdate: PropTypes.func.isRequired,\n\t\tformattedText: PropTypes.array.isRequired,\n\t\tblockerRectOffset: PropTypes.number.isRequired,\n\t\tmaxTickWidth: PropTypes.number\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar isTextNew = !isEqual(this.props.formattedText, nextProps.formattedText);\n\t\tif (isTextNew) {\n\t\t\treturn true;\n\t\t}\n\t\tvar isMaxNew = (this.props.maxTickWidth !== nextProps.maxTickWidth);\n\t\tif (isMaxNew) {\n\t\t\treturn true;\n\t\t}\n\t\tvar isWidthNew = (this.props.chartWidth !== nextProps.chartWidth);\n\t\tif (isWidthNew) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_getMaxTickWidth: function(el) {\n\t\tvar text = el.getElementsByTagName(\"text\");\n\n\t\tvar newMaxTickWidth = reduce(text, function(prevWidth, currNode) {\n\t\t\tvar currWidth = currNode.getComputedTextLength();\n\t\t\treturn Math.max(prevWidth, currWidth);\n\t\t}, 0);\n\n\t\t// `newMaxTickWidth` accounts for size of the text, but we need to\n\t\t// add the size of the offset of the background blocker rect\n\t\tnewMaxTickWidth = newMaxTickWidth + this.props.blockerRectOffset;\n\t\treturn newMaxTickWidth;\n\t},\n\n\tcomponentDidMount: function(prevProps, prevState) {\n\t\tvar newMaxTickWidth = this._getMaxTickWidth(this.getDOMNode());\n\t\tthis.props.onUpdate(newMaxTickWidth);\n\t},\n\n\tcomponentDidUpdate: function(prevProps, prevState) {\n\t\tvar newMaxTickWidth = this._getMaxTickWidth(this.getDOMNode());\n\t\tif (newMaxTickWidth !== this.props.maxTickWidth) {\n\t\t\t// update `maxTickWidth` object in parent component, as it gets passed to\n\t\t\t// `XYChart`, a sibling of this component.\n\t\t\tthis.props.onUpdate(newMaxTickWidth);\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar tickText = this.props.formattedText.map(function(tick, i) {\n\t\t\t// FYI: these classNames must match the classNames used to render your\n\t\t\t// actual ticks in order for this to work\n\t\t\t// TODO: pass className via prop\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", {key: i, className: this.props.className}, \n\t\t\t\t\tReact.createElement(\"text\", {style: {\"textAnchor\": \"start\"}, x: \"0\", y: \"0\", dy: \"0.32em\"}, tick)\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"d4 hidden-svg\", transform: \"translate(\" + [0, -100] + \")\"}, \n\t\t\t\tReact.createElement(\"g\", {className: \"axis\"}, \n\t\t\t\t\ttickText\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\n/**\n * Given a scale, render hidden bar grid labels to find which is furthest right.\n * This allows us to increase the padding of these charts to account for the\n * extra width\n * @instance\n * @memberof RendererWrapper\n */\nvar HiddenSvgBarLabels = React.createClass({displayName: \"HiddenSvgBarLabels\",\n\n\tpropTypes: {\n\t\tonUpdate: PropTypes.func.isRequired,\n\t\tscale: PropTypes.object.isRequired,\n\t\tblockerRectOffset: PropTypes.number.isRequired,\n\t\tchartWidth: PropTypes.number.isRequired,\n\t\tlabelOverlap: PropTypes.number.isRequired\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\teffectiveWidth: 0, // width of the chart accounting for margin/padding\n\t\t\tparentSVG: null\n\t\t}\n\t},\n\n\t_getSVGParent: function(el) {\n\t\t// we need the parent SVG to compute mouse position\n\t\tif (el.parentNode.tagName == \"svg\") {\n\t\t\treturn el.parentNode;\n\t\t} else {\n\t\t\treturn this._getSVGParent(el.parentNode);\n\t\t}\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar prevScale = this.props.scale;\n\t\tvar newScale = nextProps.scale;\n\t\tvar newPrefix = (prevScale.prefix !== newScale.prefix);\n\t\tvar newSuffix = (prevScale.suffix !== newScale.suffix);\n\t\tif (newPrefix || newSuffix) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!isEqual(prevScale.domain, newScale.domain)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.state.effectiveWidth !== nextState.effectiveWidth) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_getLabelOverlap: function(chartWidth) {\n\t\tvar el = this.getDOMNode();\n\t\tvar text = el.querySelectorAll(\"text\");\n\t\t// Find the top bar grid label that is furthest to the right\n\t\tvar furthestRight = reduce(text, function(prevRight, currNode, ix) {\n\t\t\tvar currRight = currNode.getBoundingClientRect().right;\n\t\t\treturn Math.max(prevRight, currRight);\n\t\t}, 0);\n\n\t\t// Find the label that is furthest to the right, accounting for the\n\t\t// block rect and margin\n\t\tvar parentLeft = this.state.parentSVG.getBoundingClientRect().left;\n\t\tfurthestRight += this.props.blockerRectOffset * 2 + this.props.margin.right;\n\n\t\tif (furthestRight > (chartWidth + parentLeft)) {\n\t\t\treturn furthestRight - (chartWidth + parentLeft);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\t_createScale: function(props) {\n\t\t// Create a d3 scale based on our chart properties, so that we can \"place\"\n\t\t// the hidden label and see if it is too far to the right\n\t\treturn d3.scale.linear()\n\t\t\t.range([props.offset.left, props.chartWidth - props.offset.right])\n\t\t\t.domain(props.scale.domain);\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\t// Find the effective width of the chart area and set this in current\n\t\t// component's state\n\t\tthis.setState({\n\t\t\teffectiveWidth: nextProps.chartWidth - nextProps.margin.right - nextProps.margin.left\n\t\t});\n\t},\n\n\tcomponentDidMount: function(prevProps, prevState) {\n\t\t// Set the initial labelOverlap on mount\n\t\tthis.setState({ parentSVG: this._getSVGParent(this.getDOMNode())}, function() {\n\t\t\tvar labelOverlap = this._getLabelOverlap(this.props.chartWidth);\n\t\t\tthis.props.onUpdate(labelOverlap);\n\t\t})\n\t},\n\n\tcomponentDidUpdate: function(prevProps, prevState) {\n\t\tvar labelOverlap = this._getLabelOverlap(this.props.chartWidth);\n\t\tif (labelOverlap !== this.props.labelOverlap) {\n\t\t\t// Update new `labelOverlap` if it has changed\n\t\t\tthis.props.onUpdate(labelOverlap);\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar scale = this.props.scale;\n\t\tvar d3scale = this._createScale(this.props);\n\n\t\tvar labelText = this.props.formattedText.map(function(label, i) {\n\t\t\tvar translateX;\n\t\t\tif (label == \"no data\") {\n\t\t\t\ttranslateX = d3scale(scale.domain[0]);\n\t\t\t} else {\n\t\t\t\ttranslateX = d3scale(label.value);\n\t\t\t}\n\t\t\tvar translate = [ translateX, -100 ];\n\t\t\t// ATTN: these classNames must match the classNames used to render your\n\t\t\t// actual ticks in order for this to work\n\t\t\treturn (\n\t\t\t\tReact.createElement(\"g\", {\n\t\t\t\t\tkey: i, \n\t\t\t\t\tclassName: this.props.className, \n\t\t\t\t\ttransform: \"translate(\" + translate + \")\"\n\t\t\t\t}, \n\t\t\t\t\tReact.createElement(\"text\", null, label.formatted)\n\t\t\t\t)\n\t\t\t);\n\t\t}, this);\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {className: \"d4 hidden-svg\"}, \n\t\t\t\tReact.createElement(\"g\", {className: \"axis\"}, \n\t\t\t\t\tlabelText\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = {\n\tHiddenSvgAxis: HiddenSvgAxis,\n\tHiddenSvgBarLabels: HiddenSvgBarLabels\n};",
            "path": "src/js/components/svg/HiddenSvg.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/svg/HiddenSvg.jsx#L112-L241"
          },
          "scope": "instance",
          "memberof": "RendererWrapper",
          "name": "HiddenSvgBarLabels",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "RendererWrapper",
            "HiddenSvgBarLabels"
          ]
        },
        {
          "description": "Render labels that are either automatically placed into a legend, or can be\ndragged manually by the user",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "RendererWrapper"
            },
            {
              "title": "name",
              "name": "SvgRectLabel"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 18,
                "column": 0
              },
              "end": {
                "line": 481,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/svg/SvgRectLabel.jsx",
            "code": "var React = require(\"react\");\nvar PureRenderMixin = require('react/addons').addons.PureRenderMixin;\nvar isEqual = require(\"lodash/lang/isEqual\");\nvar PropTypes = React.PropTypes;\nvar d3 = require(\"d3\");\n\n/**\n * Render labels that are either automatically placed into a legend, or can be\n * dragged manually by the user\n * @instance\n * @memberof RendererWrapper\n */\nvar SvgRectLabel = React.createClass({displayName: \"SvgRectLabel\",\n\n\tpropTypes: {\n\t\ttext: PropTypes.string,\n\t\tsettings: PropTypes.shape({\n\t\t\tdragged: PropTypes.bool,\n\t\t\tname: PropTypes.string,\n\t\t\twidth: PropTypes.number,\n\t\t\tx: PropTypes.number,\n\t\t\ty: PropTypes.number,\n\t\t\tval_x: PropTypes.date,\n\t\t\tval_y: PropTypes.number\n\t\t}).isRequired,\n\t\teditable: PropTypes.bool.isRequired,\n\t\tdimensions: PropTypes.shape({\n\t\t\twidth: PropTypes.number,\n\t\t\theight: PropTypes.number\n\t\t}).isRequired,\n\t\tprevNode: PropTypes.object,\n\t\tmargin: PropTypes.object,\n\t\tscale: PropTypes.shape({\n\t\t\tx: PropTypes.object,\n\t\t\ty: PropTypes.object\n\t\t}),\n\t\tonPositionUpdate: PropTypes.func.isRequired\n\t},\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\tsettings: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tval_x: null,\n\t\t\t\tval_y: null,\n\t\t\t\tdragged: false,\n\t\t\t}\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tdragging: false,\n\t\t\torigin: { x: 0, y: 0 },\n\t\t\telement: { x: 0, y: 0 },\n\t\t\tproportionalComputed: { x: 0, y: 0 },\n\t\t\tvalueComputed: {x: 0, y: 0},\n\t\t\tvalues: {x: 0, y: 0},\n\t\t\tyScale: d3.scale.linear()\n\t\t\t\t.domain(this.props.scale.y.domain)\n\t\t\t\t.range(this.props.scale.y.range),\n\t\t\txScale: d3.time.scale()\n\t\t\t\t.domain(this.props.scale.x.domain)\n\t\t\t\t.range(this.props.scale.x.range)\n\t\t};\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tvar newProps = (!isEqual(this.props, nextProps));\n\t\tvar newDrag = (this.state.dragging !== nextState.dragging);\n\t\treturn (newProps || newDrag || nextState.dragging);\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tvar proportionalComputedPos = this._fromPropotionalPostion(nextProps.settings,nextProps);\n\t\tvar valueComputedPos = this._fromValuePosition({x:nextProps.settings.val_x, y:nextProps.settings.val_y});\n\t\tvar elementPos = {\n\t\t\tx: valueComputedPos.x || proportionalComputedPos.x,\n\t\t\ty: valueComputedPos.y || proportionalComputedPos.y\n\t\t}\n\n\t\tthis.setState({\n\t\t\tproportionalComputed: proportionalComputedPos,\n\t\t\tvalueComputed: valueComputedPos,\n\t\t\telement: elementPos,\n\t\t\tyScale: this.state.yScale\n\t\t\t\t.domain(nextProps.scale.y.domain)\n\t\t\t\t.range(nextProps.scale.y.range),\n\t\t\txScale: this.state.xScale\n\t\t\t\t.domain(nextProps.scale.x.domain)\n\t\t\t\t.range(nextProps.scale.x.range),\n\n\t\t\t});\n\n\t},\n\n\t_getSVGParent: function(el) {\n\t\t// we need the parent SVG to compute mouse position\n\t\tif (el.parentNode.tagName == \"svg\") {\n\t\t\treturn el.parentNode;\n\t\t} else {\n\t\t\treturn this._getSVGParent(el.parentNode);\n\t\t}\n\t},\n\n\t_getSVGMousePosition: function(e) {\n\t\t// get SVG mouse position accounting for the location of SVG\n\t\t// see https://stackoverflow.com/questions/10298658/mouse-position-inside-autoscaled-svg\n\t\t// and https://github.com/mbostock/d3/blob/master/src/event/mouse.js\n\t\tvar svg = this.state.parentSVG;\n\t\tvar rect = svg.getBoundingClientRect();\n\t\tvar pos = {\n\t\t\tx: e.clientX - rect.left - svg.clientLeft,\n\t\t\ty: e.clientY - rect.top - svg.clientTop\n\t\t};\n\t\treturn pos;\n\t},\n\n\t_onMouseDown: function(e) {\n\t\t// only respect left mouse button\n\t\tif (e.button !== 0) { return; }\n\t\tvar mousePos = this._getSVGMousePosition(e);\n\t\tthis._updatePosition({\n\t\t\tname: this.props.text,\n\t\t\tx: this.props.settings.x,\n\t\t\ty: this.props.settings.y,\n\t\t\tval_y: this.props.settings.val_y,\n\t\t\tval_x: this.props.settings.val_x,\n\t\t\tdragged: true\n\t\t});\n\n\t\tthis.props.enableDrag(); // set dragged = true in parent app\n\n\t\tthis.setState({\n\t\t\tdragging: true,\n\t\t\torigin: {\n\t\t\t\tx: mousePos.x,\n\t\t\t\ty:  mousePos.y\n\t\t\t},\n\t\t\telement: {\n\t\t\t\tx: this.state.proportionalComputed.x,\n\t\t\t\ty: this.state.proportionalComputed.y\n\t\t\t},\n\t\t\tvalues: {\n\t\t\t\tx: this.props.settings.val_x,\n\t\t\t\ty: this.props.settings.val_y\n\t\t\t},\n\t\t\tvalueComputed : this._toValuePosition({x: this.props.settings.val_x, y:this.props.settings.val_y})\n\t\t});\n\n\n\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\t},\n\n\t_onMouseMove: function(e) {\n\t\tif (!this.state.dragging) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar mousePos = this._getSVGMousePosition(e);\n\t\tvar deltaX = (mousePos.x - this.state.origin.x);\n\t\tvar deltaY = (mousePos.y - this.state.origin.y);\n\n\t\tthis.setState({\n\t\t\tdragging: true,\n\t\t\telement: {\n\t\t\t\tx: (this.state.valueComputed.x || this.state.proportionalComputed.x) + deltaX,\n\t\t\t\ty: (this.state.valueComputed.y || this.state.proportionalComputed.y) + deltaY\n\t\t\t},\n\t\t\tvalues: this._toValuePosition({\n\t\t\t\tx: this.state.valueComputed.x + deltaX,\n\t\t\t\ty: this.state.valueComputed.y + deltaY\n\t\t\t})\n\t\t});\n\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\t},\n\n\t_onMouseUp: function(e) {\n\t\tthis.setState({ dragging: false });\n\t\tvar pos = this._toProportionalPosition(this.state.element);\n\t\tvar vals = this._toValuePosition(this.state.element)\n\t\tthis._updatePosition({\n\t\t\tname: this.props.text,\n\t\t\tx: pos.x,\n\t\t\ty: pos.y,\n\t\t\tval_y: vals.y,\n\t\t\tval_x: vals.x,\n\t\t\tdragged: true\n\t\t});\n\n\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\t},\n\n\t_updatePosition: function(posObj) {\n\t\tthis.props.onPositionUpdate(this.props.index, posObj);\n\t},\n\n\t_toProportionalPosition: function(pos,props){\n\t\tif (!props) {\n\t\t\tprops = this.props;\n\t\t}\n\t\treturn {\n\t\t\tx: pos.x / props.dimensions.width,\n\t\t\ty: pos.y / props.dimensions.height,\n\t\t};\n\t},\n\n\t_fromPropotionalPostion: function(pos,props){\n\t\tif (!props) {\n\t\t\tprops = this.props;\n\t\t}\n\t\treturn {\n\t\t\tx: pos.x * props.dimensions.width,\n\t\t\ty: pos.y * props.dimensions.height,\n\t\t};\n\t},\n\n\t_fromValuePosition: function(vals,xScale,yScale) {\n\t\tif(!xScale) {\n\t\t\txScale = this.state.xScale;\n\t\t}\n\n\t\tif(!yScale) {\n\t\t\tyScale = this.state.yScale;\n\t\t}\n\n\t\treturn {\n\t\t\tx: vals.x ? xScale(vals.x)-this.props.offset.x : 0,\n\t\t\ty: vals.y ? yScale(vals.y)-this.props.offset.y : 0\n\t\t};\n\t},\n\n\t_toValuePosition: function(pos,xScale,yScale) {\n\t\tif(!xScale) {\n\t\t\txScale = this.state.xScale;\n\t\t}\n\n\t\tif(!yScale) {\n\t\t\tyScale = this.state.yScale;\n\t\t}\n\n\n\t\treturn {\n\t\t\tx: pos.y !== 0 ? xScale.invert(pos.x+this.props.offset.x):null,\n\t\t\ty: pos.y !== 0 ? yScale.invert(pos.y+this.props.offset.y):null\n\t\t};\n\t},\n\n\t_setLegendPosition: function(nextProps, node) {\n\t\t// Update label positions\n\t\tvar nodeBBox = node.getBBox();\n\t\tvar prevNode = nextProps.prevNode;\n\t\tvar x;\n\t\tvar y;\n\n\t\t// only place label if it hasn't been dragged\n\t\t// compute based on previous node position, but only if it exists\n\t\t// and if current label is unchanged\n\t\tif (prevNode) {\n\t\t\ty = prevNode.y;\n\t\t\tx = ((prevNode.x * this.props.dimensions.width) +\n\t\t\t\t\t prevNode.width + nextProps.labelConfig.xMargin);\n\n\t\t\t// If no `this.props.prevNode`, this is the first time the label is aware\n\t\t\t// of prevNode's values meaning it has mounted overlapped with it. We can\n\t\t\t// place based on `nextProps.prevNode`.\n\t\t\tif (!this.props.prevNode) {\n\t\t\t\tthis._updatePosition({\n\t\t\t\t\tname: nextProps.text,\n\t\t\t\t\tx: x / nextProps.dimensions.width,\n\t\t\t\t\ty: y,\n\t\t\t\t\tval_y: null,\n\t\t\t\t\tval_x: null,\n\t\t\t\t\tdragged: nextProps.settings.dragged,\n\t\t\t\t\twidth: nodeBBox.width\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// we have to create a new label row\n\t\t\tvar isNewRow = (x + nodeBBox.width + this.props.offset.x > nextProps.dimensions.width);\n\n\t\t\tif (isNewRow) {\n\t\t\t\tx = 0,\n\t\t\t\ty = (prevNode.y * this.props.dimensions.height + this.props.labelConfig.rowHeight) /\n\t\t\t\t\t\tthis.props.dimensions.height;\n\t\t\t}\n\n\t\t\tthis._updatePosition({\n\t\t\t\tname: this.props.text,\n\t\t\t\tx: x / nextProps.dimensions.width,\n\t\t\t\ty: y,\n\t\t\t\tval_y: null,\n\t\t\t\tval_x: null,\n\t\t\t\tdragged: nextProps.settings.dragged,\n\t\t\t\twidth: nodeBBox.width\n\t\t\t});\n\t\t} else if (!nextProps.prevNode && !nextProps.settings.dragged) {\n\t\t\t\tthis._updatePosition({\n\t\t\t\t\tname: nextProps.text,\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t\tval_y: null,\n\t\t\t\t\tval_x: null,\n\t\t\t\t\tdragged: false,\n\t\t\t\t\twidth: nodeBBox.width\n\t\t\t\t});\n\t\t}\n\t},\n\n\tcomponentDidUpdate: function(prevProps) {\n\t\t// when label updates, check if its width is different. if so, update it\n\t\tvar isLabelTextNew = (this.props.text !== prevProps.text);\n\t\tvar isReset = (prevProps.settings.dragged === true && this.props.settings.dragged === false);\n\t\tvar newConfig = !isEqual(this.props.labelConfig, prevProps.labelConfig);\n\n\t\tif (isLabelTextNew || isReset || newConfig) {\n\t\t\tvar node = this.getDOMNode();\n\t\t\tvar nodeBBox = node.getBBox();\n\t\t\tvar prevNode = this.props.prevNode;\n\t\t\tthis._updatePosition({\n\t\t\t\tname: this.props.text,\n\t\t\t\tx: this.props.settings.x,\n\t\t\t\ty: this.props.settings.y,\n\t\t\t\tval_y: this.props.settings.val_y,\n\t\t\t\tval_x: this.props.settings.val_x,\n\t\t\t\tdragged: this.props.settings.dragged,\n\t\t\t\twidth: nodeBBox.width\n\t\t\t});\n\t\t}\n\n\t},\n\n\tcomponentDidMount: function() {\n\t\t// Set default position of left-most label\n\t\tvar node = this.getDOMNode();\n\t\tvar nodeBBox = node.getBBox();\n\t\tvar parentSVG = this._getSVGParent(node);\n\t\tif (!node.previousSibling) {\n\t\t\tthis._updatePosition({\n\t\t\t\tname: this.props.text,\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tval_y: null,\n\t\t\t\tval_x: null,\n\t\t\t\tdragged: false,\n\t\t\t\twidth: nodeBBox.width\n\t\t\t});\n\t\t} else if (this.props.prevNode) {\n\t\t\tvar x = ((this.props.prevNode.x * this.props.dimensions.width) +\n\t\t\t\t\t\t\t this.props.prevNode.width +\n\t\t\t\t\t\t\t this.props.labelConfig.xMargin) / this.props.dimensions.width;\n\n\t\t\tthis._updatePosition({\n\t\t\t\tname: this.props.text,\n\t\t\t\tx: x,\n\t\t\t\ty: 0,\n\t\t\t\tval_y: null,\n\t\t\t\tval_x: null,\n\t\t\t\tdragged: false,\n\t\t\t\twidth: nodeBBox.width\n\t\t\t});\n\t\t}\n\t\tthis.setState({ parentSVG: parentSVG });\n\t},\n\n\t_addDragEvents: function() {\n\t\tdocument.addEventListener(\"mousemove\", this._onMouseMove);\n\t\tdocument.addEventListener(\"mouseup\", this._onMouseUp);\n\t},\n\n\t_removeDragEvents: function() {\n\t\tdocument.removeEventListener(\"mousemove\", this._onMouseMove);\n\t\tdocument.removeEventListener(\"mouseup\", this._onMouseUp);\n\t},\n\n\tcomponentWillUpdate: function(nextProps, nextState) {\n\t\tif (!nextProps.settings.dragged) {\n\t\t\tthis._setLegendPosition(nextProps, this.getDOMNode());\n\t\t}\n\n\t\tif (nextProps.settings.dragged === false) {\n\t\t\treturn;\n\t\t} else if (nextProps.editable === true) {\n\t\t\t// only allow dragging if we are in editable mode\n\t\t\tif (nextState.dragging && !this.state.dragging) {\n\t\t\t\tthis._addDragEvents();\n\t\t\t} else if (!nextState.dragging && this.state.dragging) {\n\t\t\t\tthis._removeDragEvents();\n\t\t\t}\n\t\t}\n\t},\n\n\trender: function() {\n\n\t\tvar colorClass = \"color-index-\" + this.props.colorIndex.toString();\n\t\tvar translate;\n\t\t// if we are dragging, get position from local state\n\t\tif (this.state.dragging) {\n\t\t\ttranslate = [this.state.element.x, this.state.element.y ];\n\t\t// if not dragging, position should be passed down from parent\n\t\t} else if (this.props.settings.dragged) {\n\t\t\ttranslate = [ this.state.valueComputed.x || this.state.proportionalComputed.x, this.state.valueComputed.y ];\n\t\t} else {\n\t\t\ttranslate = [ this.state.proportionalComputed.x, this.state.proportionalComputed.y ];\n\t\t}\n\n\t\t// only add rect if we haven't dragged\n\t\tvar rect = null;\n\t\tvar textOffsetX = null;\n\t\tvar textOffsetY = null;\n\t\tvar dy = \"0.35em\";\n\n\t\tif (!this.props.settings.dragged) {\n\t\t\trect = React.createElement(\"rect\", {\n\t\t\t\tclassName: [\"svg-label-rect\", colorClass].join(\" \"), \n\t\t\t\twidth: this.props.labelConfig.rectSize, \n\t\t\t\theight: this.props.labelConfig.rectSize, \n\t\t\t\ty: this.props.labelConfig.rectSize / 2 * -1}\n\t\t\t)\n\t\t\ttextOffsetX = this.props.labelConfig.rectSize + this.props.labelConfig.textMargin;\n\t\t\ttextOffsetY = 0;\n\t\t} else {\n\t\t\ttextXOffset = 0;\n\t\t\ttextOffsetY = 0;\n\t\t\tdy = 0\n\t\t}\n\n\t\tvar ch_size = 9\n\t\tvar crosshair = null\n\n\t\tif(this.state.dragging) {\n\t\t\tcrosshair = React.createElement(\"g\", {className: \"crosshair\"}, \n\t\t\t\tReact.createElement(\"line\", {\n\t\t\t\t\tx1: ch_size/-2, \n\t\t\t\t\tx2: ch_size/2\n\t\t\t\t\t}\n\t\t\t\t), \n\t\t\t\tReact.createElement(\"line\", {\n\t\t\t\t\ty1: ch_size/-2, \n\t\t\t\t\ty2: ch_size/2\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tclassName: \"svg-label-g\", \n\t\t\t\ttransform: \"translate(\" + translate + \")\"\n\t\t\t}, \n\t\t\t\trect, \n\t\t\t\tReact.createElement(\"text\", {\n\t\t\t\t\tclassName: [\"svg-label-text\", colorClass].join(\" \"), \n\t\t\t\t\tx: textOffsetX, \n\t\t\t\t\ty: textOffsetY, \n\t\t\t\t\tdy: dy, \n\t\t\t\t\tdraggable: this.props.editable, \n\t\t\t\t\tonMouseDown: this._onMouseDown\n\t\t\t\t}, \n\t\t\t\t\tthis.props.text\n\t\t\t\t), \n\t\t\t\tcrosshair\n\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = SvgRectLabel;",
            "path": "src/js/components/svg/SvgRectLabel.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/svg/SvgRectLabel.jsx#L18-L481"
          },
          "scope": "instance",
          "memberof": "RendererWrapper",
          "name": "SvgRectLabel",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "RendererWrapper",
            "SvgRectLabel"
          ]
        },
        {
          "description": "An Svg <text> element with experimental text wrapping support",
          "tags": [
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "RendererWrapper"
            },
            {
              "title": "name",
              "name": "SvgText"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 17,
                "column": 0
              },
              "end": {
                "line": 167,
                "column": 3
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/components/svg/SvgText.jsx",
            "code": "var React = require(\"react\");\nvar PropTypes = React.PropTypes;\nvar shallowEqual = require(\"react/lib/shallowEqual\");\nvar ChartViewActions = require(\"../../actions/ChartViewActions\");\n\nvar config = {\n\ttextDy: 0.7,\n\ttextLineHeight: 1.2\n};\n\n/**\n * An Svg <text> element with experimental text wrapping support\n * @instance\n * @memberof RendererWrapper\n */\nvar SvgText = React.createClass({displayName: \"SvgText\",\n\n\tpropTypes: {\n\t\tclassName: PropTypes.string,\n\t\theightPerLine: PropTypes.number,\n\t\tonUpdate: PropTypes.func,\n\t\ttranslate: PropTypes.array.isRequired,\n\t\ttext: PropTypes.string.isRequired,\n\t\twrap: PropTypes.bool,\n\t\tmaxCharacters: PropTypes.number\n\t},\n\n\tshouldComponentUpdate: function(nextProps, nextState) {\n\t\tif ((nextState.lines.length !== this.state.lines.length) && nextProps.onUpdate && nextProps.wrap) {\n\t\t\tif (nextState.lines.length === 1) {\n\t\t\t\tthis.props.onUpdate(0);\n\t\t\t} else {\n\t\t\t\tthis.props.onUpdate((nextState.lines.length) * this.props.heightPerLine);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (nextProps.text !== this.props.text) {\n\t\t\treturn true;\n\t\t}\n\t\tvar t1 = this.props.translate;\n\t\tvar t2 = nextProps.translate;\n\t\tvar newTrans = ( (t1[0] !== t2[0]) || (t1[1] !== t2[1]) );\n\t\tif (newTrans) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.props.maxWidth !== nextProps.maxWidth) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tgetDefaultProps: function() {\n\t\treturn {\n\t\t\twrap: false,\n\t\t\tmaxCharacters: 100\n\t\t};\n\t},\n\n\tgetInitialState: function() {\n\t\treturn {\n\t\t\tlines: [ this.props.text ]\n\t\t};\n\t},\n\n\t_wrapLines: function(props) {\n\t\tvar lines = [];\n\n\t\tif (props.wrap) {\n\t\t\tmaxCharacters = props.maxCharacters;\n\t\t\tvar newWords = props.text.split(\" \");\n\t\t\tvar words = [];\n\t\t\tvar spanLength = 0;\n\n\t\t\tnewWords.forEach(function(word) {\n\t\t\t\tif (spanLength + word.length > maxCharacters) {\n\t\t\t\t\tlines.push(words.join(\" \"));\n\t\t\t\t\twords.length = 0;\n\t\t\t\t\tspanLength = 0;\n\t\t\t\t}\n\t\t\t\tspanLength += word.length;\n\t\t\t\twords.push(word);\n\t\t\t});\n\n\t\t\tif (words.length) {\n\t\t\t\tlines.push(words.join(\" \"));\n\t\t\t}\n\t\t} else {\n\t\t\tlines = [props.text];\n\t\t}\n\n\t\treturn {\n\t\t\tlines: lines\n\t\t};\n\t},\n\n\tcomponentWillMount: function() {\n\t\tif (this.props.text && this.props.wrap) {\n\t\t\tvar lineSettings = this._wrapLines(this.props, this.state);\n\t\t\tthis.setState(lineSettings);\n\t\t}\n\t},\n\n\tcomponentDidMount: function() {\n\t\tif (this.props.onUpdate && this.props.wrap) {\n\t\t\tif (this.state.lines.length === 1) {\n\t\t\t\tthis.props.onUpdate(0);\n\t\t\t} else {\n\t\t\t\tthis.props.onUpdate((this.state.lines.length) * this.props.heightPerLine);\n\t\t\t}\n\t\t}\n\t},\n\n\tcomponentWillReceiveProps: function(nextProps) {\n\t\tif (this.props.wrap) {\n\t\t\tvar lineSettings = this._wrapLines(nextProps);\n\t\t\tthis.setState(lineSettings);\n\t\t}\n\t},\n\n\trender: function() {\n\t\tvar textNodes;\n\t\tif (this.props.wrap) {\n\t\t\ttextNodes = this.state.lines.map(function(text, i) {\n\t\t\t\treturn (\n\t\t\t\t\tReact.createElement(\"text\", {\n\t\t\t\t\t\tdy: (i * config.textLineHeight).toString() + \"em\", \n\t\t\t\t\t\ty: \"0\", \n\t\t\t\t\t\tx: \"0\", \n\t\t\t\t\t\tkey: i\n\t\t\t\t\t}, \n\t\t\t\t\t\ttext\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tvar dy;\n\t\t\tif (this.props.align === \"bottom\") {\n\t\t\t\tdy = \"-0.35em\";\n\t\t\t} else if (this.props.align === \"top\"){\n\t\t\t\tdy = \"0.35em\";\n\t\t\t} else {\n\t\t\t\tdy = \"0em\";\n\t\t\t}\n\n\t\t\ttextNodes = (\n\t\t\t\tReact.createElement(\"text\", {\n\t\t\t\t\ty: \"0\", \n\t\t\t\t\tx: \"0\", \n\t\t\t\t\tdy: dy\n\t\t\t\t}, \n\t\t\t\t\tthis.props.text\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t\treturn (\n\t\t\tReact.createElement(\"g\", {\n\t\t\t\tclassName: [\"svg-text\", this.props.className].join(\" \"), \n\t\t\t\ttransform: \"translate(\" + this.props.translate + \")\"\n\t\t\t}, \n\t\t\t\ttextNodes\n\t\t\t)\n\t\t);\n\t}\n\n});\n\nmodule.exports = SvgText;",
            "path": "src/js/components/svg/SvgText.jsx",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/components/svg/SvgText.jsx#L17-L167"
          },
          "scope": "instance",
          "memberof": "RendererWrapper",
          "name": "SvgText",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "RendererWrapper",
            "SvgText"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "RendererWrapper"
    ]
  },
  {
    "description": "### SessionStore\nFlux store for the current session, ie session data that persits regardless\ninteraction. Includes locale-aware settings and are unrelated to the actual\nrendering of the chart.",
    "tags": [
      {
        "title": "name",
        "name": "SessionStore"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 23,
          "column": 0
        },
        "end": {
          "line": 57,
          "column": 3
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/SessionStore.js",
      "code": "var assign = require(\"lodash/object/assign\");\nvar EventEmitter = require(\"events\").EventEmitter;\n\n/* Flux dispatcher */\nvar Dispatcher = require(\"../dispatcher/dispatcher\");\n\nvar _session = {\n\tseparators: detectNumberSeparators(),\n\temSize: 10,\n\twidth: 640,\n\ttimerOn: true\n};\n\nvar CHANGE_EVENT = \"change\";\n\n/**\n * ### SessionStore\n * Flux store for the current session, ie session data that persits regardless\n * interaction. Includes locale-aware settings and are unrelated to the actual\n * rendering of the chart.\n*/\nvar SessionStore = assign({}, EventEmitter.prototype, {\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tget: function(k) {\n\t\treturn _session[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all session data\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tgetAll: function() {\n\t\treturn _session;\n\t}\n\n});\n\nDispatcher.register(function(payload) {\n\tvar action = payload.action;\n\n\tswitch(action.eventName) {\n\t\tcase \"start-timer\":\n\t\t\t_session.timerOn = true;\n\t\t\tSessionStore.emitChange();\n\t\t\tbreak;\n\n\t\tcase \"stop-timer\":\n\t\t\t_session.timerOn = false;\n\t\t\tSessionStore.emitChange();\n\t\t\tbreak;\n\n\t\tcase \"update-session\":\n\t\t\t_session[action.key] = action.value;\n\t\t\tSessionStore.emitChange();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// do nothing\n\t}\n\n\treturn true;\n});\n\n// Get thousands and decimal separators based on locale\nfunction detectNumberSeparators() {\n\tvar n = 1000.50;\n\tvar l = n.toLocaleString();\n\tvar s = n.toString();\n\tvar o = {\n\t\tdecimal: l.substring(5,6),\n\t\tthousands: l.substring(1,2)\n\t};\n\n\tif (l.substring(5,6) == s.substring(5,6)) {\n\t\to.decimal = \".\";\n\t}\n\tif (l.substring(1,2) == s.substring(1,2)) {\n\t\to.thousands = \",\";\n\t}\n\n\treturn o;\n}\n\nmodule.exports = SessionStore;",
      "path": "src/js/stores/SessionStore.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/SessionStore.js#L23-L57"
    },
    "name": "SessionStore",
    "kind": "function",
    "members": {
      "instance": [
        {
          "description": "get",
          "tags": [
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "SessionStore"
            },
            {
              "title": "name",
              "name": "get"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 43,
                "column": 1
              },
              "end": {
                "line": 45,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/SessionStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tget: function(k) {\n\t\treturn _session[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all session data\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tgetAll: function() {\n\t\treturn _session;\n\t}\n\n}",
            "path": "src/js/stores/SessionStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/SessionStore.js#L43-L45"
          },
          "returns": [
            {
              "title": "returns",
              "description": "Return value at key `k`",
              "type": {
                "type": "NameExpression",
                "name": "any"
              }
            }
          ],
          "scope": "instance",
          "memberof": "SessionStore",
          "name": "get",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "SessionStore",
            "get"
          ]
        },
        {
          "description": "getAll",
          "tags": [
            {
              "title": "returns",
              "description": "Return all session data",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "SessionStore"
            },
            {
              "title": "name",
              "name": "getAll"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 53,
                "column": 1
              },
              "end": {
                "line": 55,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/stores/SessionStore.js",
            "code": "{\n\n\temitChange: function() {\n\t\tthis.emit(CHANGE_EVENT);\n\t},\n\n\taddChangeListener: function(callback) {\n\t\tthis.on(CHANGE_EVENT, callback);\n\t},\n\n\tremoveChangeListener: function(callback) {\n\t\tthis.removeListener(CHANGE_EVENT, callback);\n\t},\n\n\t/**\n\t * get\n\t * @return {any} - Return value at key `k`\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tget: function(k) {\n\t\treturn _session[k];\n\t},\n\n\t/**\n\t * getAll\n\t * @return {object} - Return all session data\n\t * @instance\n\t * @memberof SessionStore\n\t */\n\tgetAll: function() {\n\t\treturn _session;\n\t}\n\n}",
            "path": "src/js/stores/SessionStore.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/stores/SessionStore.js#L53-L55"
          },
          "returns": [
            {
              "title": "returns",
              "description": "Return all session data",
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "scope": "instance",
          "memberof": "SessionStore",
          "name": "getAll",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "SessionStore",
            "getAll"
          ]
        }
      ],
      "static": []
    },
    "path": [
      "SessionStore"
    ]
  },
  {
    "description": "### Configuration of an XY chart",
    "tags": [
      {
        "title": "name",
        "description": null,
        "name": "xy_config"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 32,
          "column": 0
        },
        "end": {
          "line": 60,
          "column": 2
        }
      },
      "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-config.js",
      "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of an XY chart\n * @name xy_config\n */\n\n/**\n* display\n* @static\n* @memberof xy_config\n* @property {Nem|number} labelRectSize - Size of the legend label rectangle\n* @property {Nem|number} labelXMargin - Horiz distance btwn labels\n* @property {Nem|number} labelTextMargin - Horiz distance btwn label rect and text\n* @property {Nem|number} labelRowHeight - Vert distance btwn rows of labels\n* items with colors the appropriate indexed CSS class\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} columnPaddingCoefficient - Distance relative to\n* width that column charts should be from edge of the chart\n* @property {Nem|number} minPaddingOuter - Minimum distance between the\n* outside of a chart and a graphical element\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} aspectRatio\n* @property {number|fraction} aspectRatio.wide\n* @property {number|fraction} aspectRatio.longSpot\n* @property {number|fraction} aspectRatio.smallSpot\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tlabelRectSize: \"0.6em\",\n\tlabelXMargin: \"0.6em\",\n\tlabelTextMargin: \"0.3em\",\n\tlabelRowHeight: \"1.2em\",\n\tafterTitle: \"1.6em\",\n\tafterLegend: \"1.6em\",\n\tblockerRectOffset: \"0.3em\",\n\tcolumnPaddingCoefficient: 0.3,\n\tminPaddingOuter: \"1em\",\n\tbottomPaddingWithoutFooter: \"3em\",\n\taspectRatio: {\n\t\twide: (9 / 16),\n\t\tlongSpot: (4 / 3),\n\t\tsmallSpot: (3 / 4)\n\t},\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: \"4em\",\n\t\tleft: 0\n\t}\n};\n\n/**\n* @name xy_defaultProps\n* @static\n* @memberof xy_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {array} data\n\t * @property {object} input\n\t * @property {object[]} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _annotations - Additional informative graphical elements\n\t * @property {object} _annotations.labels - If labels are dragged, their\n\t * position settings are saved here\n\t * @property {object[]} _annotations.labels.values - Array of settings for\n\t * dragged labels\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tchartProps: {\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tdata: [],\n\t\tinput: {},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\taltAxis: false,\n\t\t\t\ttype: \"line\",\n\t\t\t\tcolorIndex: 0\n\t\t\t}\n\t\t],\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\t_annotations: {\n\t\t\tlabels: {\n\t\t\t\thasDragged: false,\n\t\t\t\tvalues: []\n\t\t\t}\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tmetadata: {\n\t\tchartType: 'xy',\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar xy_config = new ChartConfig({\n\tdisplayName: \"XY Chart\",\n\tparser: require(\"./parse-xy\"),\n\tcalculateDimensions: require(\"./xy-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = xy_config;",
      "path": "src/js/charts/cb-xy/xy-config.js",
      "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-config.js#L32-L60"
    },
    "name": "xy_config",
    "members": {
      "instance": [
        {
          "description": "see [ChartConfig#calculateDimensions](#chartconfig/calculatedimensions)",
          "tags": [
            {
              "title": "see",
              "description": "ChartConfig#calculateDimensions"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "xy_config"
            },
            {
              "title": "name",
              "name": "calculate_xy_dimensions"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 11,
                "column": 0
              },
              "end": {
                "line": 47,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-dimensions.js",
            "code": "var chartSizes = require(\"../../config/chart-sizes\");\n\n// TODO: jsDocify this if it works\n\n/**\n * see [ChartConfig#calculateDimensions](#chartconfig/calculatedimensions)\n * @see ChartConfig#calculateDimensions\n * @instance\n * @memberof xy_config\n */\nfunction calculate_xy_dimensions(width, opts) {\n\tvar height;\n\tvar aspectRatio = opts.displayConfig.aspectRatio;\n\tvar metadata = opts.model.metadata;\n\n\tif (metadata.size == \"auto\" || opts.enableResponsive) {\n\t\t// use current width\n\t} else {\n\t\twidth = chartSizes[metadata.size].width;\n\t}\n\n\tswitch (metadata.size) {\n\t\tcase \"auto\":\n\t\t\theight = width * aspectRatio.wide;\n\t\t\tbreak;\n\n\t\tcase 'medium':\n\t\t\theight = width * aspectRatio.wide;\n\t\t\tbreak;\n\n\t\tcase \"spotLong\":\n\t\t\theight = width * aspectRatio.longSpot;\n\t\t\tbreak;\n\n\t\tcase \"spotSmall\":\n\t\t\theight = width * aspectRatio.smallSpot;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\theight = width * aspectRatio.wide;\n\t}\n\n\treturn {\n\t\twidth: width,\n\t\theight: height + opts.extraHeight\n\t};\n}\n\nmodule.exports = calculate_xy_dimensions;",
            "path": "src/js/charts/cb-xy/xy-dimensions.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-dimensions.js#L11-L47"
          },
          "scope": "instance",
          "memberof": "xy_config",
          "name": "calculate_xy_dimensions",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "xy_config",
            "calculate_xy_dimensions"
          ]
        },
        {
          "description": "see [ChartConfig#parser](#chartconfig/parser)",
          "tags": [
            {
              "title": "see",
              "description": "ChartConfig#parser"
            },
            {
              "title": "instance",
              "description": null
            },
            {
              "title": "memberof",
              "description": "xy_config"
            },
            {
              "title": "name",
              "name": "parseXY"
            },
            {
              "title": "kind",
              "kind": "function"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 18,
                "column": 0
              },
              "end": {
                "line": 187,
                "column": 1
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/parse-xy.js",
            "code": "var clone = require(\"lodash/lang/clone\");\nvar map = require(\"lodash/collection/map\");\nvar assign = require(\"lodash/object/assign\");\nvar each = require(\"lodash/collection/each\");\nvar filter = require(\"lodash/collection/filter\");\n\nvar dataBySeries = require(\"../../util/parse-data-by-series\");\nvar help = require(\"../../util/helper\");\n\nvar scaleNames = [\"primaryScale\", \"secondaryScale\"];\n\n/**\n * see [ChartConfig#parser](#chartconfig/parser)\n * @see ChartConfig#parser\n * @instance\n * @memberof xy_config\n */\nfunction parseXY(config, _chartProps, callback, parseOpts) {\n\t// Build chart settings from defaults or provided settings\n\n\tparseOpts = parseOpts || {};\n\t// clone so that we aren't modifying original\n\t// this can probably be avoided by applying new settings differently\n\tvar chartProps = JSON.parse(JSON.stringify(_chartProps));\n\n\tvar bySeries = dataBySeries(chartProps.input.raw, { checkForDate: true });\n\tvar labels = chartProps._annotations.labels;\n\tvar allColumn = true;\n\t// check if either scale contains columns, as we'll need to zero the axis\n\tvar _primaryColumn = false;\n\tvar _secondaryColumn = false;\n\tvar _scaleComputed = {};\n\n\teach(scaleNames, function(name) {\n\t\t_scaleComputed[name] = {\n\t\t\tdata: [],\n\t\t\thasColumn: false,\n\t\t\tcount: 0\n\t\t};\n\t});\n\n\tvar chartSettings = map(bySeries.series, function(dataSeries, i) {\n\t\tvar settings;\n\t\tif (chartProps.chartSettings[i]) {\n\t\t\tsettings = chartProps.chartSettings[i];\n\t\t} else {\n\t\t\tsettings = clone(config.defaultProps.chartProps.chartSettings[0]);\n\t\t\tsettings.colorIndex = i;\n\t\t}\n\n\t\tif (parseOpts.columnsChanged) {\n\t\t\tsettings.label = dataSeries.name;\n\t\t} else {\n\t\t\tsettings.label = settings.label || dataSeries.name;\n\t\t}\n\n\t\tvar values = map(dataSeries.values, function(d) {\n\t\t\treturn +d.value;\n\t\t});\n\n\t\t// add data points to relevant scale\n\t\tif (settings.altAxis === false) {\n\t\t\tvar _computed = _scaleComputed.primaryScale;\n\t\t\t_computed.data = _computed.data.concat(values);\n\t\t\t_computed.count += 1;\n\t\t\tif (settings.type == \"column\") {\n\t\t\t\t_computed.hasColumn = true;\n\t\t\t}\n\t\t} else {\n\t\t\tvar _computed = _scaleComputed.secondaryScale;\n\t\t\t_computed.data = _computed.data.concat(values);\n\t\t\t_computed.count += 1;\n\t\t\tif (settings.type == \"column\") {\n\t\t\t\t_computed.hasColumn = true;\n\t\t\t}\n\t\t}\n\t\treturn settings;\n\t});\n\n\tlabels.values = map(bySeries.series, function(dataSeries, i) {\n\t\tif (labels.values[i]) {\n\t\t\treturn assign({}, { name: chartSettings[i].label}, labels.values[i]);\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tname: dataSeries.name\n\t\t\t};\n\t\t}\n\t});\n\n\tvar maxPrecision = 5;\n\tvar factor = Math.pow(10, maxPrecision);\n\n\tvar scale = {};\n\tvar mobileScale = {};\n\n\t// Calculate domain and tick values for any scales that exist\n\teach(scaleNames, function(name) {\n\t\tvar _computed = _scaleComputed[name];\n\t\tif (_computed.count > 0) {\n\t\t\tvar currScale = chartProps.scale[name] || clone(config.defaultProps.chartProps.scale.primaryScale);\n\t\t\tvar domain = help.computeScaleDomain(currScale, _computed.data, {\n\t\t\t\tnice: true,\n\t\t\t\tminZero: _computed.hasColumn\n\t\t\t});\n\t\t\tassign(currScale, domain);\n\n\t\t\tvar ticks;\n\t\t\tif (name === \"primaryScale\") {\n\t\t\t\tticks = currScale.ticks;\n\t\t\t} else {\n\t\t\t\tticks = scale.primaryScale.ticks;\n\t\t\t}\n\n\t\t\tcurrScale.tickValues = help.exactTicks(currScale.domain, ticks);\n\t\t\teach(currScale.tickValues, function(v) {\n\t\t\t\tvar tickPrecision = help.precision(Math.round(v*factor)/factor);\n\t\t\t\tif (tickPrecision > currScale.precision) {\n\t\t\t\t\tcurrScale.precision = tickPrecision;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tscale[name] = currScale;\n\n\t\t\tif (chartProps.mobile) {\n\t\t\t\tif (chartProps.mobile.scale) {\n\t\t\t\t\tvar currMobile = chartProps.mobile.scale[name];\n\t\t\t\t\tif (currMobile) {\n\t\t\t\t\t\tvar domain = help.computeScaleDomain(currMobile, _computed.data, {\n\t\t\t\t\t\t\tnice: true,\n\t\t\t\t\t\t\tminZero: _computed.hasColumn\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassign(currMobile, domain);\n\n\t\t\t\t\t\tvar ticks = (name == \"primaryScale\") ? currMobile.ticks : scale.primaryScale.ticks;\n\t\t\t\t\t\tcurrMobile.tickValues = help.exactTicks(currMobile.domain, ticks);\n\t\t\t\t\t\teach(currMobile.tickValues, function(v) {\n\t\t\t\t\t\t\tvar tickPrecision = help.precision(Math.round(v*factor)/factor);\n\t\t\t\t\t\t\tif (tickPrecision > currMobile.precision) {\n\t\t\t\t\t\t\t\tcurrMobile.precision = tickPrecision;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchartProps.mobile = {};\n\t\t\t}\n\t\t}\n\t});\n\n\t// If there is only one primary and >0 secondary, color the left axis\n\tif (_scaleComputed.primaryScale.count === 1 && _scaleComputed.secondaryScale.count > 0) {\n\t\tscale.primaryScale.colorIndex = filter(chartSettings, function(series) {\n\t\t\treturn (series.altAxis === false);\n\t\t})[0].colorIndex;\n\t} else {\n\t\tscale.primaryScale.colorIndex = null;\n\t}\n\t// If there is only one secondary and >0 primary, color the right axis\n\tif (_scaleComputed.secondaryScale.count === 1 && _scaleComputed.primaryScale.count > 0) {\n\t\tscale.secondaryScale.colorIndex = filter(chartSettings, function(series) {\n\t\t\treturn (series.altAxis === true);\n\t\t})[0].colorIndex;\n\t} else if (_scaleComputed.secondaryScale.count > 0) {\n\t\tscale.secondaryScale.colorIndex = null;\n\t}\n\n\t// create the data structure for the renederer based on input\n\tif (bySeries.hasDate) {\n\t\tscale.hasDate = bySeries.hasDate;\n\t\tscale.dateSettings = chartProps.scale.dateSettings || clone(config.defaultProps.chartProps.scale.dateSettings);\n\t}\n\n\tvar newChartProps = assign(chartProps, {\n\t\tchartSettings: chartSettings,\n\t\tscale: scale,\n\t\tinput: bySeries.input,\n\t\tdata: bySeries.series,\n\t\t_numSecondaryAxis: _scaleComputed.secondaryScale.count\n\t});\n\n\tif (callback) {\n\t\tcallback(newChartProps);\n\t} else {\n\t\treturn newChartProps;\n\t}\n\n}\n\nmodule.exports = parseXY;",
            "path": "src/js/charts/cb-xy/parse-xy.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/parse-xy.js#L18-L187"
          },
          "scope": "instance",
          "memberof": "xy_config",
          "name": "parseXY",
          "kind": "function",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "xy_config",
            "parseXY"
          ]
        }
      ],
      "static": [
        {
          "description": "display",
          "tags": [
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "xy_config"
            },
            {
              "title": "property",
              "description": "Size of the legend label rectangle",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelRectSize"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn labels",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelXMargin"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn label rect and text",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelTextMargin"
            },
            {
              "title": "property",
              "description": "Vert distance btwn rows of labels\nitems with colors the appropriate indexed CSS class",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelRowHeight"
            },
            {
              "title": "property",
              "description": "Distance btwn top of title and top of legend or chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterTitle"
            },
            {
              "title": "property",
              "description": "Distance btwn top of legend and top of chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterLegend"
            },
            {
              "title": "property",
              "description": "Distance btwn text of axis and its background blocker",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "blockerRectOffset"
            },
            {
              "title": "property",
              "description": "Distance relative to\nwidth that column charts should be from edge of the chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "columnPaddingCoefficient"
            },
            {
              "title": "property",
              "description": "Minimum distance between the\noutside of a chart and a graphical element",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "minPaddingOuter"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "aspectRatio"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.wide"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.longSpot"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.smallSpot"
            },
            {
              "title": "property",
              "description": "Distances btwn outer chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "margin"
            },
            {
              "title": "property",
              "description": "Distances btwn inner chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "padding"
            },
            {
              "title": "name",
              "name": "display"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 32,
                "column": 0
              },
              "end": {
                "line": 60,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-config.js",
            "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of an XY chart\n * @name xy_config\n */\n\n/**\n* display\n* @static\n* @memberof xy_config\n* @property {Nem|number} labelRectSize - Size of the legend label rectangle\n* @property {Nem|number} labelXMargin - Horiz distance btwn labels\n* @property {Nem|number} labelTextMargin - Horiz distance btwn label rect and text\n* @property {Nem|number} labelRowHeight - Vert distance btwn rows of labels\n* items with colors the appropriate indexed CSS class\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} columnPaddingCoefficient - Distance relative to\n* width that column charts should be from edge of the chart\n* @property {Nem|number} minPaddingOuter - Minimum distance between the\n* outside of a chart and a graphical element\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} aspectRatio\n* @property {number|fraction} aspectRatio.wide\n* @property {number|fraction} aspectRatio.longSpot\n* @property {number|fraction} aspectRatio.smallSpot\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tlabelRectSize: \"0.6em\",\n\tlabelXMargin: \"0.6em\",\n\tlabelTextMargin: \"0.3em\",\n\tlabelRowHeight: \"1.2em\",\n\tafterTitle: \"1.6em\",\n\tafterLegend: \"1.6em\",\n\tblockerRectOffset: \"0.3em\",\n\tcolumnPaddingCoefficient: 0.3,\n\tminPaddingOuter: \"1em\",\n\tbottomPaddingWithoutFooter: \"3em\",\n\taspectRatio: {\n\t\twide: (9 / 16),\n\t\tlongSpot: (4 / 3),\n\t\tsmallSpot: (3 / 4)\n\t},\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: \"4em\",\n\t\tleft: 0\n\t}\n};\n\n/**\n* @name xy_defaultProps\n* @static\n* @memberof xy_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {array} data\n\t * @property {object} input\n\t * @property {object[]} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _annotations - Additional informative graphical elements\n\t * @property {object} _annotations.labels - If labels are dragged, their\n\t * position settings are saved here\n\t * @property {object[]} _annotations.labels.values - Array of settings for\n\t * dragged labels\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tchartProps: {\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tdata: [],\n\t\tinput: {},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\taltAxis: false,\n\t\t\t\ttype: \"line\",\n\t\t\t\tcolorIndex: 0\n\t\t\t}\n\t\t],\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\t_annotations: {\n\t\t\tlabels: {\n\t\t\t\thasDragged: false,\n\t\t\t\tvalues: []\n\t\t\t}\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tmetadata: {\n\t\tchartType: 'xy',\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar xy_config = new ChartConfig({\n\tdisplayName: \"XY Chart\",\n\tparser: require(\"./parse-xy\"),\n\tcalculateDimensions: require(\"./xy-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = xy_config;",
            "path": "src/js/charts/cb-xy/xy-config.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-config.js#L32-L60"
          },
          "scope": "static",
          "memberof": "xy_config",
          "properties": [
            {
              "title": "property",
              "description": "Size of the legend label rectangle",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelRectSize"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn labels",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelXMargin"
            },
            {
              "title": "property",
              "description": "Horiz distance btwn label rect and text",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelTextMargin"
            },
            {
              "title": "property",
              "description": "Vert distance btwn rows of labels\nitems with colors the appropriate indexed CSS class",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "labelRowHeight"
            },
            {
              "title": "property",
              "description": "Distance btwn top of title and top of legend or chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterTitle"
            },
            {
              "title": "property",
              "description": "Distance btwn top of legend and top of chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "afterLegend"
            },
            {
              "title": "property",
              "description": "Distance btwn text of axis and its background blocker",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "blockerRectOffset"
            },
            {
              "title": "property",
              "description": "Distance relative to\nwidth that column charts should be from edge of the chart",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "columnPaddingCoefficient"
            },
            {
              "title": "property",
              "description": "Minimum distance between the\noutside of a chart and a graphical element",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "minPaddingOuter"
            },
            {
              "title": "property",
              "description": "Bottom padding if footer is not drawn",
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "Nem"
                  },
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              },
              "name": "bottomPaddingWithoutFooter"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "aspectRatio"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.wide"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.longSpot"
            },
            {
              "title": "property",
              "description": null,
              "type": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  },
                  {
                    "type": "NameExpression",
                    "name": "fraction"
                  }
                ]
              },
              "name": "aspectRatio.smallSpot"
            },
            {
              "title": "property",
              "description": "Distances btwn outer chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "margin"
            },
            {
              "title": "property",
              "description": "Distances btwn inner chart elements and container",
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "padding"
            }
          ],
          "name": "display",
          "members": {
            "instance": [],
            "static": []
          },
          "path": [
            "xy_config",
            "display"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "name",
              "description": null,
              "name": "xy_defaultProps"
            },
            {
              "title": "static",
              "description": null
            },
            {
              "title": "memberof",
              "description": "xy_config"
            }
          ],
          "context": {
            "loc": {
              "start": {
                "line": 67,
                "column": 0
              },
              "end": {
                "line": 135,
                "column": 2
              }
            },
            "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-config.js",
            "code": "var ChartConfig = require(\"../ChartConfig\");\n\n/**\n * ### Configuration of an XY chart\n * @name xy_config\n */\n\n/**\n* display\n* @static\n* @memberof xy_config\n* @property {Nem|number} labelRectSize - Size of the legend label rectangle\n* @property {Nem|number} labelXMargin - Horiz distance btwn labels\n* @property {Nem|number} labelTextMargin - Horiz distance btwn label rect and text\n* @property {Nem|number} labelRowHeight - Vert distance btwn rows of labels\n* items with colors the appropriate indexed CSS class\n* @property {Nem|number} afterTitle - Distance btwn top of title and top of legend or chart\n* @property {Nem|number} afterLegend - Distance btwn top of legend and top of chart\n* @property {Nem|number} blockerRectOffset - Distance btwn text of axis and its background blocker\n* @property {Nem|number} columnPaddingCoefficient - Distance relative to\n* width that column charts should be from edge of the chart\n* @property {Nem|number} minPaddingOuter - Minimum distance between the\n* outside of a chart and a graphical element\n* @property {Nem|number} bottomPaddingWithoutFooter - Bottom padding if footer is not drawn\n* @property {object} aspectRatio\n* @property {number|fraction} aspectRatio.wide\n* @property {number|fraction} aspectRatio.longSpot\n* @property {number|fraction} aspectRatio.smallSpot\n* @property {object} margin - Distances btwn outer chart elements and container\n* @property {object} padding - Distances btwn inner chart elements and container\n*/\nvar display = {\n\tlabelRectSize: \"0.6em\",\n\tlabelXMargin: \"0.6em\",\n\tlabelTextMargin: \"0.3em\",\n\tlabelRowHeight: \"1.2em\",\n\tafterTitle: \"1.6em\",\n\tafterLegend: \"1.6em\",\n\tblockerRectOffset: \"0.3em\",\n\tcolumnPaddingCoefficient: 0.3,\n\tminPaddingOuter: \"1em\",\n\tbottomPaddingWithoutFooter: \"3em\",\n\taspectRatio: {\n\t\twide: (9 / 16),\n\t\tlongSpot: (4 / 3),\n\t\tsmallSpot: (3 / 4)\n\t},\n\tmargin: {\n\t\ttop: \"0.8em\",\n\t\tright: \"0.25em\",\n\t\tbottom: \"0.15em\",\n\t\tleft: \"0.25em\"\n\t},\n\tpadding: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: \"4em\",\n\t\tleft: 0\n\t}\n};\n\n/**\n* @name xy_defaultProps\n* @static\n* @memberof xy_config\n*/\nvar defaultProps = {\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {array} data\n\t * @property {object} input\n\t * @property {object[]} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _annotations - Additional informative graphical elements\n\t * @property {object} _annotations.labels - If labels are dragged, their\n\t * position settings are saved here\n\t * @property {object[]} _annotations.labels.values - Array of settings for\n\t * dragged labels\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tchartProps: {\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tdata: [],\n\t\tinput: {},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\taltAxis: false,\n\t\t\t\ttype: \"line\",\n\t\t\t\tcolorIndex: 0\n\t\t\t}\n\t\t],\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\t_annotations: {\n\t\t\tlabels: {\n\t\t\t\thasDragged: false,\n\t\t\t\tvalues: []\n\t\t\t}\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tmetadata: {\n\t\tchartType: 'xy',\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n};\n\nvar xy_config = new ChartConfig({\n\tdisplayName: \"XY Chart\",\n\tparser: require(\"./parse-xy\"),\n\tcalculateDimensions: require(\"./xy-dimensions\"),\n\tdisplay: display,\n\tdefaultProps: defaultProps\n});\n\nmodule.exports = xy_config;",
            "path": "src/js/charts/cb-xy/xy-config.js",
            "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-config.js#L67-L135"
          },
          "name": "xy_defaultProps",
          "scope": "static",
          "memberof": "xy_config",
          "members": {
            "instance": [],
            "static": [
              {
                "description": "",
                "tags": [
                  {
                    "title": "name",
                    "description": null,
                    "name": "chartProps"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for date and primary scales",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "scale"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "array"
                    },
                    "name": "data"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "input"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for a given series (column) of data",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Additional padding. This is a dynamic\nvalue and is mostly changed within the component itself",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "extraPadding"
                  },
                  {
                    "title": "property",
                    "description": "Additional informative graphical elements",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_annotations"
                  },
                  {
                    "title": "property",
                    "description": "If labels are dragged, their\nposition settings are saved here",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_annotations.labels"
                  },
                  {
                    "title": "property",
                    "description": "Array of settings for\ndragged labels",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "_annotations.labels.values"
                  },
                  {
                    "title": "property",
                    "description": "Mobile-specific override settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "mobile"
                  },
                  {
                    "title": "static",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "xy_defaultProps"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 85,
                      "column": 1
                    },
                    "end": {
                      "line": 120,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-config.js",
                  "code": "{\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {array} data\n\t * @property {object} input\n\t * @property {object[]} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _annotations - Additional informative graphical elements\n\t * @property {object} _annotations.labels - If labels are dragged, their\n\t * position settings are saved here\n\t * @property {object[]} _annotations.labels.values - Array of settings for\n\t * dragged labels\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tchartProps: {\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tdata: [],\n\t\tinput: {},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\taltAxis: false,\n\t\t\t\ttype: \"line\",\n\t\t\t\tcolorIndex: 0\n\t\t\t}\n\t\t],\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\t_annotations: {\n\t\t\tlabels: {\n\t\t\t\thasDragged: false,\n\t\t\t\tvalues: []\n\t\t\t}\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tmetadata: {\n\t\tchartType: 'xy',\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n}",
                  "path": "src/js/charts/cb-xy/xy-config.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-config.js#L85-L120"
                },
                "name": "chartProps",
                "properties": [
                  {
                    "title": "property",
                    "description": "Default settings for date and primary scales",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "scale"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "array"
                    },
                    "name": "data"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "input"
                  },
                  {
                    "title": "property",
                    "description": "Default settings for a given series (column) of data",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "chartSettings"
                  },
                  {
                    "title": "property",
                    "description": "Additional padding. This is a dynamic\nvalue and is mostly changed within the component itself",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "extraPadding"
                  },
                  {
                    "title": "property",
                    "description": "Additional informative graphical elements",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_annotations"
                  },
                  {
                    "title": "property",
                    "description": "If labels are dragged, their\nposition settings are saved here",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "_annotations.labels"
                  },
                  {
                    "title": "property",
                    "description": "Array of settings for\ndragged labels",
                    "type": {
                      "type": "TypeApplication",
                      "expression": {
                        "type": "NameExpression",
                        "name": "Array"
                      },
                      "applications": [
                        {
                          "type": "NameExpression",
                          "name": "object"
                        }
                      ]
                    },
                    "name": "_annotations.labels.values"
                  },
                  {
                    "title": "property",
                    "description": "Mobile-specific override settings",
                    "type": {
                      "type": "NameExpression",
                      "name": "object"
                    },
                    "name": "mobile"
                  }
                ],
                "scope": "static",
                "memberof": "xy_defaultProps",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "xy_config",
                  "xy_defaultProps",
                  "chartProps"
                ]
              },
              {
                "description": "",
                "tags": [
                  {
                    "title": "name",
                    "description": null,
                    "name": "metadata"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "chartType"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "size"
                  },
                  {
                    "title": "static",
                    "description": null
                  },
                  {
                    "title": "memberof",
                    "description": "xy_defaultProps"
                  }
                ],
                "context": {
                  "loc": {
                    "start": {
                      "line": 128,
                      "column": 1
                    },
                    "end": {
                      "line": 134,
                      "column": 2
                    }
                  },
                  "file": "/Users/nikhil/docs/source/Chartbuilder/src/js/charts/cb-xy/xy-config.js",
                  "code": "{\n\t/**\n\t * @name chartProps\n\t * @property {object} scale - Default settings for date and primary scales\n\t * @property {array} data\n\t * @property {object} input\n\t * @property {object[]} chartSettings - Default settings for a given series (column) of data\n\t * @property {object} extraPadding - Additional padding. This is a dynamic\n\t * value and is mostly changed within the component itself\n\t * @property {object} _annotations - Additional informative graphical elements\n\t * @property {object} _annotations.labels - If labels are dragged, their\n\t * position settings are saved here\n\t * @property {object[]} _annotations.labels.values - Array of settings for\n\t * dragged labels\n\t * @property {object} mobile - Mobile-specific override settings\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tchartProps: {\n\t\tscale: {\n\t\t\tprimaryScale: {\n\t\t\t\tticks: 5,\n\t\t\t\tprecision: 0,\n\t\t\t\tprefix: \"\",\n\t\t\t\tsuffix: \"\"\n\t\t\t},\n\t\t\tdateSettings: {\n\t\t\t\tdateFrequency: \"auto\",\n\t\t\t\tdateFormat: \"auto\"\n\t\t\t}\n\t\t},\n\t\tdata: [],\n\t\tinput: {},\n\t\tchartSettings: [\n\t\t\t{\n\t\t\t\taltAxis: false,\n\t\t\t\ttype: \"line\",\n\t\t\t\tcolorIndex: 0\n\t\t\t}\n\t\t],\n\t\textraPadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t},\n\t\t_annotations: {\n\t\t\tlabels: {\n\t\t\t\thasDragged: false,\n\t\t\t\tvalues: []\n\t\t\t}\n\t\t},\n\t\tmobile: {}\n\t},\n\t/**\n\t * @name metadata\n\t * @property {string} chartType\n\t * @property {string} size\n\t * @static\n\t * @memberof xy_defaultProps\n\t */\n\tmetadata: {\n\t\tchartType: 'xy',\n\t\ttitle: \"\",\n\t\tsource: \"\",\n\t\tcredit: \"Made with Chartbuilder\",\n\t\tsize: \"auto\"\n\t}\n}",
                  "path": "src/js/charts/cb-xy/xy-config.js",
                  "github": "https://github.com/Quartz/Chartbuilder/blob/d4165f010361cf5a1ebf6f475bb0adb24d657c81/src/js/charts/cb-xy/xy-config.js#L128-L134"
                },
                "name": "metadata",
                "properties": [
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "chartType"
                  },
                  {
                    "title": "property",
                    "description": null,
                    "type": {
                      "type": "NameExpression",
                      "name": "string"
                    },
                    "name": "size"
                  }
                ],
                "scope": "static",
                "memberof": "xy_defaultProps",
                "members": {
                  "instance": [],
                  "static": []
                },
                "path": [
                  "xy_config",
                  "xy_defaultProps",
                  "metadata"
                ]
              }
            ]
          },
          "path": [
            "xy_config",
            "xy_defaultProps"
          ]
        }
      ]
    },
    "path": [
      "xy_config"
    ]
  }
]